///////////////////////////////////////////////////////////////////////////////
//     Filter-Adapted Spatio-Temporal Sampling With General Distributions    //
//        Copyright (c) 2025 Electronic Arts Inc. All rights reserved.       //
///////////////////////////////////////////////////////////////////////////////

#include "../public/technique.h"
#include "DX12Utils/dxutils.h"
#include "DX12Utils/DelayedReleaseTracker.h"
#include "DX12Utils/HeapAllocationTracker.h"
#include "DX12Utils/TextureCache.h"

#include <vector>
#include <chrono>

namespace FastBokeh
{
    static std::vector<Context*> s_allContexts;

    static DX12Utils::Heap                  s_srvHeap;
    static DX12Utils::Heap                  s_rtvHeap;
    static DX12Utils::Heap                  s_dsvHeap;
    static DX12Utils::UploadBufferTracker   s_ubTracker;
    static DX12Utils::DelayedReleaseTracker s_delayedRelease;
    static DX12Utils::HeapAllocationTracker s_heapAllocationTrackerRTV;
    static DX12Utils::HeapAllocationTracker s_heapAllocationTrackerDSV;

    TLogFn Context::LogFn = [] (LogLevel level, const char* msg, ...) {};
    TPerfEventBeginFn Context::PerfEventBeginFn = [] (const char* name, ID3D12GraphicsCommandList* commandList, int index) {};
    TPerfEventEndFn Context::PerfEventEndFn = [] (ID3D12GraphicsCommandList* commandList) {};

    std::wstring Context::s_techniqueLocation = L"./";
    static unsigned int s_timerIndex = 0;

    ID3D12CommandSignature* ContextInternal::s_commandSignatureDispatch = nullptr;

    ID3D12StateObject* ContextInternal::rayShader_Raytrace_rtso = nullptr;
    ID3D12RootSignature* ContextInternal::rayShader_Raytrace_rootSig = nullptr;
    ID3D12Resource* ContextInternal::rayShader_Raytrace_shaderTableRayGen = nullptr;
    unsigned int    ContextInternal::rayShader_Raytrace_shaderTableRayGenSize = 0;
    ID3D12Resource* ContextInternal::rayShader_Raytrace_shaderTableMiss = nullptr;
    unsigned int    ContextInternal::rayShader_Raytrace_shaderTableMissSize = 0;
    ID3D12Resource* ContextInternal::rayShader_Raytrace_shaderTableHitGroup = nullptr;
    unsigned int    ContextInternal::rayShader_Raytrace_shaderTableHitGroupSize = 0;

    ID3D12PipelineState* ContextInternal::computeShader_GatherDOF_Setup_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_GatherDOF_Setup_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_GatherDOF_NearBorder_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_GatherDOF_NearBorder_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_GatherDOF_BlurFar_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_GatherDOF_BlurFar_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_GatherDOF_FloodFillFar_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_GatherDOF_FloodFillFar_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_GatherDOF_NearHalo_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_GatherDOF_NearHalo_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_GatherDOF_NearBlur_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_GatherDOF_NearBlur_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_GatherDOF_FloodFillNear_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_GatherDOF_FloodFillNear_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_GatherDOF_Recombine_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_GatherDOF_Recombine_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_GaussBlur_DoBlur_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_GaussBlur_DoBlur_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_TemporalAccumulation_DoAccum_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_TemporalAccumulation_DoAccum_rootSig = nullptr;

    ID3D12PipelineState* ContextInternal::computeShader_ToneMap_Tonemap_pso = nullptr;
    ID3D12RootSignature* ContextInternal::computeShader_ToneMap_Tonemap_rootSig = nullptr;

    template <typename T>
    T Pow2GE(const T& A)
    {
        float f = std::log2(float(A));
        f = std::ceilf(f);
        return (T)std::pow(2.0f, f);
    }

    bool CreateShared(ID3D12Device* device)
    {

        ID3D12Device5* dxrDevice = nullptr;
        device->QueryInterface(IID_PPV_ARGS(&dxrDevice));

        // Ray Shader: Raytrace
        {
            D3D12_STATIC_SAMPLER_DESC samplers[2];

            // PointWrapSampler
            samplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_POINT;
            samplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
            samplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
            samplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
            samplers[0].MipLODBias  = 0;
            samplers[0].MaxAnisotropy  = 0;
            samplers[0].ComparisonFunc  = D3D12_COMPARISON_FUNC_NEVER;
            samplers[0].BorderColor  = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
            samplers[0].MinLOD = 0.0f;
            samplers[0].MaxLOD = D3D12_FLOAT32_MAX;
            samplers[0].ShaderRegister = 0;
            samplers[0].RegisterSpace = 0;
            samplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

            // PointClampSampler
            samplers[1].Filter = D3D12_FILTER_MIN_MAG_MIP_POINT;
            samplers[1].AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[1].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[1].AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[1].MipLODBias  = 0;
            samplers[1].MaxAnisotropy  = 0;
            samplers[1].ComparisonFunc  = D3D12_COMPARISON_FUNC_NEVER;
            samplers[1].BorderColor  = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
            samplers[1].MinLOD = 0.0f;
            samplers[1].MaxLOD = D3D12_FLOAT32_MAX;
            samplers[1].ShaderRegister = 1;
            samplers[1].RegisterSpace = 0;
            samplers[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

            D3D12_DESCRIPTOR_RANGE ranges[203];

            // Output
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // LinearDepth
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 1;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            // Scene
            ranges[2].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[2].NumDescriptors = 1;
            ranges[2].BaseShaderRegister = 0;
            ranges[2].RegisterSpace = 0;
            ranges[2].OffsetInDescriptorsFromTableStart = 2;

            // VertexBuffer
            ranges[3].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[3].NumDescriptors = 1;
            ranges[3].BaseShaderRegister = 1;
            ranges[3].RegisterSpace = 0;
            ranges[3].OffsetInDescriptorsFromTableStart = 3;

            // PixelDebug
            ranges[4].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[4].NumDescriptors = 1;
            ranges[4].BaseShaderRegister = 2;
            ranges[4].RegisterSpace = 0;
            ranges[4].OffsetInDescriptorsFromTableStart = 4;

            // DebugTex
            ranges[5].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[5].NumDescriptors = 1;
            ranges[5].BaseShaderRegister = 3;
            ranges[5].RegisterSpace = 0;
            ranges[5].OffsetInDescriptorsFromTableStart = 5;

            // _loadedTexture_0
            ranges[6].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[6].NumDescriptors = 1;
            ranges[6].BaseShaderRegister = 2;
            ranges[6].RegisterSpace = 0;
            ranges[6].OffsetInDescriptorsFromTableStart = 6;

            // _loadedTexture_1
            ranges[7].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[7].NumDescriptors = 1;
            ranges[7].BaseShaderRegister = 3;
            ranges[7].RegisterSpace = 0;
            ranges[7].OffsetInDescriptorsFromTableStart = 7;

            // _loadedTexture_2
            ranges[8].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[8].NumDescriptors = 1;
            ranges[8].BaseShaderRegister = 4;
            ranges[8].RegisterSpace = 0;
            ranges[8].OffsetInDescriptorsFromTableStart = 8;

            // _loadedTexture_3
            ranges[9].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[9].NumDescriptors = 1;
            ranges[9].BaseShaderRegister = 5;
            ranges[9].RegisterSpace = 0;
            ranges[9].OffsetInDescriptorsFromTableStart = 9;

            // _loadedTexture_4
            ranges[10].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[10].NumDescriptors = 1;
            ranges[10].BaseShaderRegister = 6;
            ranges[10].RegisterSpace = 0;
            ranges[10].OffsetInDescriptorsFromTableStart = 10;

            // _loadedTexture_5
            ranges[11].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[11].NumDescriptors = 1;
            ranges[11].BaseShaderRegister = 7;
            ranges[11].RegisterSpace = 0;
            ranges[11].OffsetInDescriptorsFromTableStart = 11;

            // _loadedTexture_6
            ranges[12].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[12].NumDescriptors = 1;
            ranges[12].BaseShaderRegister = 8;
            ranges[12].RegisterSpace = 0;
            ranges[12].OffsetInDescriptorsFromTableStart = 12;

            // _loadedTexture_7
            ranges[13].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[13].NumDescriptors = 1;
            ranges[13].BaseShaderRegister = 9;
            ranges[13].RegisterSpace = 0;
            ranges[13].OffsetInDescriptorsFromTableStart = 13;

            // _loadedTexture_8
            ranges[14].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[14].NumDescriptors = 1;
            ranges[14].BaseShaderRegister = 10;
            ranges[14].RegisterSpace = 0;
            ranges[14].OffsetInDescriptorsFromTableStart = 14;

            // _loadedTexture_9
            ranges[15].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[15].NumDescriptors = 1;
            ranges[15].BaseShaderRegister = 11;
            ranges[15].RegisterSpace = 0;
            ranges[15].OffsetInDescriptorsFromTableStart = 15;

            // _loadedTexture_10
            ranges[16].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[16].NumDescriptors = 1;
            ranges[16].BaseShaderRegister = 12;
            ranges[16].RegisterSpace = 0;
            ranges[16].OffsetInDescriptorsFromTableStart = 16;

            // _loadedTexture_11
            ranges[17].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[17].NumDescriptors = 1;
            ranges[17].BaseShaderRegister = 13;
            ranges[17].RegisterSpace = 0;
            ranges[17].OffsetInDescriptorsFromTableStart = 17;

            // _loadedTexture_12
            ranges[18].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[18].NumDescriptors = 1;
            ranges[18].BaseShaderRegister = 14;
            ranges[18].RegisterSpace = 0;
            ranges[18].OffsetInDescriptorsFromTableStart = 18;

            // _loadedTexture_13
            ranges[19].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[19].NumDescriptors = 1;
            ranges[19].BaseShaderRegister = 15;
            ranges[19].RegisterSpace = 0;
            ranges[19].OffsetInDescriptorsFromTableStart = 19;

            // _loadedTexture_14
            ranges[20].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[20].NumDescriptors = 1;
            ranges[20].BaseShaderRegister = 16;
            ranges[20].RegisterSpace = 0;
            ranges[20].OffsetInDescriptorsFromTableStart = 20;

            // _loadedTexture_15
            ranges[21].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[21].NumDescriptors = 1;
            ranges[21].BaseShaderRegister = 17;
            ranges[21].RegisterSpace = 0;
            ranges[21].OffsetInDescriptorsFromTableStart = 21;

            // _loadedTexture_16
            ranges[22].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[22].NumDescriptors = 1;
            ranges[22].BaseShaderRegister = 18;
            ranges[22].RegisterSpace = 0;
            ranges[22].OffsetInDescriptorsFromTableStart = 22;

            // _loadedTexture_17
            ranges[23].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[23].NumDescriptors = 1;
            ranges[23].BaseShaderRegister = 19;
            ranges[23].RegisterSpace = 0;
            ranges[23].OffsetInDescriptorsFromTableStart = 23;

            // _loadedTexture_18
            ranges[24].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[24].NumDescriptors = 1;
            ranges[24].BaseShaderRegister = 20;
            ranges[24].RegisterSpace = 0;
            ranges[24].OffsetInDescriptorsFromTableStart = 24;

            // _loadedTexture_19
            ranges[25].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[25].NumDescriptors = 1;
            ranges[25].BaseShaderRegister = 21;
            ranges[25].RegisterSpace = 0;
            ranges[25].OffsetInDescriptorsFromTableStart = 25;

            // _loadedTexture_20
            ranges[26].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[26].NumDescriptors = 1;
            ranges[26].BaseShaderRegister = 22;
            ranges[26].RegisterSpace = 0;
            ranges[26].OffsetInDescriptorsFromTableStart = 26;

            // _loadedTexture_21
            ranges[27].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[27].NumDescriptors = 1;
            ranges[27].BaseShaderRegister = 23;
            ranges[27].RegisterSpace = 0;
            ranges[27].OffsetInDescriptorsFromTableStart = 27;

            // _loadedTexture_22
            ranges[28].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[28].NumDescriptors = 1;
            ranges[28].BaseShaderRegister = 24;
            ranges[28].RegisterSpace = 0;
            ranges[28].OffsetInDescriptorsFromTableStart = 28;

            // _loadedTexture_23
            ranges[29].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[29].NumDescriptors = 1;
            ranges[29].BaseShaderRegister = 25;
            ranges[29].RegisterSpace = 0;
            ranges[29].OffsetInDescriptorsFromTableStart = 29;

            // _loadedTexture_24
            ranges[30].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[30].NumDescriptors = 1;
            ranges[30].BaseShaderRegister = 26;
            ranges[30].RegisterSpace = 0;
            ranges[30].OffsetInDescriptorsFromTableStart = 30;

            // _loadedTexture_25
            ranges[31].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[31].NumDescriptors = 1;
            ranges[31].BaseShaderRegister = 27;
            ranges[31].RegisterSpace = 0;
            ranges[31].OffsetInDescriptorsFromTableStart = 31;

            // _loadedTexture_26
            ranges[32].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[32].NumDescriptors = 1;
            ranges[32].BaseShaderRegister = 28;
            ranges[32].RegisterSpace = 0;
            ranges[32].OffsetInDescriptorsFromTableStart = 32;

            // _loadedTexture_27
            ranges[33].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[33].NumDescriptors = 1;
            ranges[33].BaseShaderRegister = 29;
            ranges[33].RegisterSpace = 0;
            ranges[33].OffsetInDescriptorsFromTableStart = 33;

            // _loadedTexture_28
            ranges[34].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[34].NumDescriptors = 1;
            ranges[34].BaseShaderRegister = 30;
            ranges[34].RegisterSpace = 0;
            ranges[34].OffsetInDescriptorsFromTableStart = 34;

            // _loadedTexture_29
            ranges[35].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[35].NumDescriptors = 1;
            ranges[35].BaseShaderRegister = 31;
            ranges[35].RegisterSpace = 0;
            ranges[35].OffsetInDescriptorsFromTableStart = 35;

            // _loadedTexture_30
            ranges[36].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[36].NumDescriptors = 1;
            ranges[36].BaseShaderRegister = 32;
            ranges[36].RegisterSpace = 0;
            ranges[36].OffsetInDescriptorsFromTableStart = 36;

            // _loadedTexture_31
            ranges[37].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[37].NumDescriptors = 1;
            ranges[37].BaseShaderRegister = 33;
            ranges[37].RegisterSpace = 0;
            ranges[37].OffsetInDescriptorsFromTableStart = 37;

            // _loadedTexture_32
            ranges[38].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[38].NumDescriptors = 1;
            ranges[38].BaseShaderRegister = 34;
            ranges[38].RegisterSpace = 0;
            ranges[38].OffsetInDescriptorsFromTableStart = 38;

            // _loadedTexture_33
            ranges[39].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[39].NumDescriptors = 1;
            ranges[39].BaseShaderRegister = 35;
            ranges[39].RegisterSpace = 0;
            ranges[39].OffsetInDescriptorsFromTableStart = 39;

            // _loadedTexture_34
            ranges[40].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[40].NumDescriptors = 1;
            ranges[40].BaseShaderRegister = 36;
            ranges[40].RegisterSpace = 0;
            ranges[40].OffsetInDescriptorsFromTableStart = 40;

            // _loadedTexture_35
            ranges[41].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[41].NumDescriptors = 1;
            ranges[41].BaseShaderRegister = 37;
            ranges[41].RegisterSpace = 0;
            ranges[41].OffsetInDescriptorsFromTableStart = 41;

            // _loadedTexture_36
            ranges[42].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[42].NumDescriptors = 1;
            ranges[42].BaseShaderRegister = 38;
            ranges[42].RegisterSpace = 0;
            ranges[42].OffsetInDescriptorsFromTableStart = 42;

            // _loadedTexture_37
            ranges[43].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[43].NumDescriptors = 1;
            ranges[43].BaseShaderRegister = 39;
            ranges[43].RegisterSpace = 0;
            ranges[43].OffsetInDescriptorsFromTableStart = 43;

            // _loadedTexture_38
            ranges[44].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[44].NumDescriptors = 1;
            ranges[44].BaseShaderRegister = 40;
            ranges[44].RegisterSpace = 0;
            ranges[44].OffsetInDescriptorsFromTableStart = 44;

            // _loadedTexture_39
            ranges[45].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[45].NumDescriptors = 1;
            ranges[45].BaseShaderRegister = 41;
            ranges[45].RegisterSpace = 0;
            ranges[45].OffsetInDescriptorsFromTableStart = 45;

            // _loadedTexture_40
            ranges[46].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[46].NumDescriptors = 1;
            ranges[46].BaseShaderRegister = 42;
            ranges[46].RegisterSpace = 0;
            ranges[46].OffsetInDescriptorsFromTableStart = 46;

            // _loadedTexture_41
            ranges[47].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[47].NumDescriptors = 1;
            ranges[47].BaseShaderRegister = 43;
            ranges[47].RegisterSpace = 0;
            ranges[47].OffsetInDescriptorsFromTableStart = 47;

            // _loadedTexture_42
            ranges[48].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[48].NumDescriptors = 1;
            ranges[48].BaseShaderRegister = 44;
            ranges[48].RegisterSpace = 0;
            ranges[48].OffsetInDescriptorsFromTableStart = 48;

            // _loadedTexture_43
            ranges[49].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[49].NumDescriptors = 1;
            ranges[49].BaseShaderRegister = 45;
            ranges[49].RegisterSpace = 0;
            ranges[49].OffsetInDescriptorsFromTableStart = 49;

            // _loadedTexture_44
            ranges[50].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[50].NumDescriptors = 1;
            ranges[50].BaseShaderRegister = 46;
            ranges[50].RegisterSpace = 0;
            ranges[50].OffsetInDescriptorsFromTableStart = 50;

            // _loadedTexture_45
            ranges[51].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[51].NumDescriptors = 1;
            ranges[51].BaseShaderRegister = 47;
            ranges[51].RegisterSpace = 0;
            ranges[51].OffsetInDescriptorsFromTableStart = 51;

            // _loadedTexture_46
            ranges[52].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[52].NumDescriptors = 1;
            ranges[52].BaseShaderRegister = 48;
            ranges[52].RegisterSpace = 0;
            ranges[52].OffsetInDescriptorsFromTableStart = 52;

            // _loadedTexture_47
            ranges[53].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[53].NumDescriptors = 1;
            ranges[53].BaseShaderRegister = 49;
            ranges[53].RegisterSpace = 0;
            ranges[53].OffsetInDescriptorsFromTableStart = 53;

            // _loadedTexture_48
            ranges[54].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[54].NumDescriptors = 1;
            ranges[54].BaseShaderRegister = 50;
            ranges[54].RegisterSpace = 0;
            ranges[54].OffsetInDescriptorsFromTableStart = 54;

            // _loadedTexture_49
            ranges[55].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[55].NumDescriptors = 1;
            ranges[55].BaseShaderRegister = 51;
            ranges[55].RegisterSpace = 0;
            ranges[55].OffsetInDescriptorsFromTableStart = 55;

            // _loadedTexture_50
            ranges[56].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[56].NumDescriptors = 1;
            ranges[56].BaseShaderRegister = 52;
            ranges[56].RegisterSpace = 0;
            ranges[56].OffsetInDescriptorsFromTableStart = 56;

            // _loadedTexture_51
            ranges[57].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[57].NumDescriptors = 1;
            ranges[57].BaseShaderRegister = 53;
            ranges[57].RegisterSpace = 0;
            ranges[57].OffsetInDescriptorsFromTableStart = 57;

            // _loadedTexture_52
            ranges[58].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[58].NumDescriptors = 1;
            ranges[58].BaseShaderRegister = 54;
            ranges[58].RegisterSpace = 0;
            ranges[58].OffsetInDescriptorsFromTableStart = 58;

            // _loadedTexture_53
            ranges[59].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[59].NumDescriptors = 1;
            ranges[59].BaseShaderRegister = 55;
            ranges[59].RegisterSpace = 0;
            ranges[59].OffsetInDescriptorsFromTableStart = 59;

            // _loadedTexture_54
            ranges[60].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[60].NumDescriptors = 1;
            ranges[60].BaseShaderRegister = 56;
            ranges[60].RegisterSpace = 0;
            ranges[60].OffsetInDescriptorsFromTableStart = 60;

            // _loadedTexture_55
            ranges[61].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[61].NumDescriptors = 1;
            ranges[61].BaseShaderRegister = 57;
            ranges[61].RegisterSpace = 0;
            ranges[61].OffsetInDescriptorsFromTableStart = 61;

            // _loadedTexture_56
            ranges[62].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[62].NumDescriptors = 1;
            ranges[62].BaseShaderRegister = 58;
            ranges[62].RegisterSpace = 0;
            ranges[62].OffsetInDescriptorsFromTableStart = 62;

            // _loadedTexture_57
            ranges[63].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[63].NumDescriptors = 1;
            ranges[63].BaseShaderRegister = 59;
            ranges[63].RegisterSpace = 0;
            ranges[63].OffsetInDescriptorsFromTableStart = 63;

            // _loadedTexture_58
            ranges[64].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[64].NumDescriptors = 1;
            ranges[64].BaseShaderRegister = 60;
            ranges[64].RegisterSpace = 0;
            ranges[64].OffsetInDescriptorsFromTableStart = 64;

            // _loadedTexture_59
            ranges[65].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[65].NumDescriptors = 1;
            ranges[65].BaseShaderRegister = 61;
            ranges[65].RegisterSpace = 0;
            ranges[65].OffsetInDescriptorsFromTableStart = 65;

            // _loadedTexture_60
            ranges[66].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[66].NumDescriptors = 1;
            ranges[66].BaseShaderRegister = 62;
            ranges[66].RegisterSpace = 0;
            ranges[66].OffsetInDescriptorsFromTableStart = 66;

            // _loadedTexture_61
            ranges[67].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[67].NumDescriptors = 1;
            ranges[67].BaseShaderRegister = 63;
            ranges[67].RegisterSpace = 0;
            ranges[67].OffsetInDescriptorsFromTableStart = 67;

            // _loadedTexture_62
            ranges[68].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[68].NumDescriptors = 1;
            ranges[68].BaseShaderRegister = 64;
            ranges[68].RegisterSpace = 0;
            ranges[68].OffsetInDescriptorsFromTableStart = 68;

            // _loadedTexture_63
            ranges[69].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[69].NumDescriptors = 1;
            ranges[69].BaseShaderRegister = 65;
            ranges[69].RegisterSpace = 0;
            ranges[69].OffsetInDescriptorsFromTableStart = 69;

            // _loadedTexture_64
            ranges[70].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[70].NumDescriptors = 1;
            ranges[70].BaseShaderRegister = 66;
            ranges[70].RegisterSpace = 0;
            ranges[70].OffsetInDescriptorsFromTableStart = 70;

            // _loadedTexture_65
            ranges[71].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[71].NumDescriptors = 1;
            ranges[71].BaseShaderRegister = 67;
            ranges[71].RegisterSpace = 0;
            ranges[71].OffsetInDescriptorsFromTableStart = 71;

            // _loadedTexture_66
            ranges[72].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[72].NumDescriptors = 1;
            ranges[72].BaseShaderRegister = 68;
            ranges[72].RegisterSpace = 0;
            ranges[72].OffsetInDescriptorsFromTableStart = 72;

            // _loadedTexture_67
            ranges[73].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[73].NumDescriptors = 1;
            ranges[73].BaseShaderRegister = 69;
            ranges[73].RegisterSpace = 0;
            ranges[73].OffsetInDescriptorsFromTableStart = 73;

            // _loadedTexture_68
            ranges[74].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[74].NumDescriptors = 1;
            ranges[74].BaseShaderRegister = 70;
            ranges[74].RegisterSpace = 0;
            ranges[74].OffsetInDescriptorsFromTableStart = 74;

            // _loadedTexture_69
            ranges[75].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[75].NumDescriptors = 1;
            ranges[75].BaseShaderRegister = 71;
            ranges[75].RegisterSpace = 0;
            ranges[75].OffsetInDescriptorsFromTableStart = 75;

            // _loadedTexture_70
            ranges[76].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[76].NumDescriptors = 1;
            ranges[76].BaseShaderRegister = 72;
            ranges[76].RegisterSpace = 0;
            ranges[76].OffsetInDescriptorsFromTableStart = 76;

            // _loadedTexture_71
            ranges[77].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[77].NumDescriptors = 1;
            ranges[77].BaseShaderRegister = 73;
            ranges[77].RegisterSpace = 0;
            ranges[77].OffsetInDescriptorsFromTableStart = 77;

            // _loadedTexture_72
            ranges[78].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[78].NumDescriptors = 1;
            ranges[78].BaseShaderRegister = 74;
            ranges[78].RegisterSpace = 0;
            ranges[78].OffsetInDescriptorsFromTableStart = 78;

            // _loadedTexture_73
            ranges[79].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[79].NumDescriptors = 1;
            ranges[79].BaseShaderRegister = 75;
            ranges[79].RegisterSpace = 0;
            ranges[79].OffsetInDescriptorsFromTableStart = 79;

            // _loadedTexture_74
            ranges[80].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[80].NumDescriptors = 1;
            ranges[80].BaseShaderRegister = 76;
            ranges[80].RegisterSpace = 0;
            ranges[80].OffsetInDescriptorsFromTableStart = 80;

            // _loadedTexture_75
            ranges[81].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[81].NumDescriptors = 1;
            ranges[81].BaseShaderRegister = 77;
            ranges[81].RegisterSpace = 0;
            ranges[81].OffsetInDescriptorsFromTableStart = 81;

            // _loadedTexture_76
            ranges[82].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[82].NumDescriptors = 1;
            ranges[82].BaseShaderRegister = 78;
            ranges[82].RegisterSpace = 0;
            ranges[82].OffsetInDescriptorsFromTableStart = 82;

            // _loadedTexture_77
            ranges[83].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[83].NumDescriptors = 1;
            ranges[83].BaseShaderRegister = 79;
            ranges[83].RegisterSpace = 0;
            ranges[83].OffsetInDescriptorsFromTableStart = 83;

            // _loadedTexture_78
            ranges[84].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[84].NumDescriptors = 1;
            ranges[84].BaseShaderRegister = 80;
            ranges[84].RegisterSpace = 0;
            ranges[84].OffsetInDescriptorsFromTableStart = 84;

            // _loadedTexture_79
            ranges[85].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[85].NumDescriptors = 1;
            ranges[85].BaseShaderRegister = 81;
            ranges[85].RegisterSpace = 0;
            ranges[85].OffsetInDescriptorsFromTableStart = 85;

            // _loadedTexture_80
            ranges[86].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[86].NumDescriptors = 1;
            ranges[86].BaseShaderRegister = 82;
            ranges[86].RegisterSpace = 0;
            ranges[86].OffsetInDescriptorsFromTableStart = 86;

            // _loadedTexture_81
            ranges[87].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[87].NumDescriptors = 1;
            ranges[87].BaseShaderRegister = 83;
            ranges[87].RegisterSpace = 0;
            ranges[87].OffsetInDescriptorsFromTableStart = 87;

            // _loadedTexture_82
            ranges[88].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[88].NumDescriptors = 1;
            ranges[88].BaseShaderRegister = 84;
            ranges[88].RegisterSpace = 0;
            ranges[88].OffsetInDescriptorsFromTableStart = 88;

            // _loadedTexture_83
            ranges[89].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[89].NumDescriptors = 1;
            ranges[89].BaseShaderRegister = 85;
            ranges[89].RegisterSpace = 0;
            ranges[89].OffsetInDescriptorsFromTableStart = 89;

            // _loadedTexture_84
            ranges[90].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[90].NumDescriptors = 1;
            ranges[90].BaseShaderRegister = 86;
            ranges[90].RegisterSpace = 0;
            ranges[90].OffsetInDescriptorsFromTableStart = 90;

            // _loadedTexture_85
            ranges[91].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[91].NumDescriptors = 1;
            ranges[91].BaseShaderRegister = 87;
            ranges[91].RegisterSpace = 0;
            ranges[91].OffsetInDescriptorsFromTableStart = 91;

            // _loadedTexture_86
            ranges[92].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[92].NumDescriptors = 1;
            ranges[92].BaseShaderRegister = 88;
            ranges[92].RegisterSpace = 0;
            ranges[92].OffsetInDescriptorsFromTableStart = 92;

            // _loadedTexture_87
            ranges[93].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[93].NumDescriptors = 1;
            ranges[93].BaseShaderRegister = 89;
            ranges[93].RegisterSpace = 0;
            ranges[93].OffsetInDescriptorsFromTableStart = 93;

            // _loadedTexture_88
            ranges[94].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[94].NumDescriptors = 1;
            ranges[94].BaseShaderRegister = 90;
            ranges[94].RegisterSpace = 0;
            ranges[94].OffsetInDescriptorsFromTableStart = 94;

            // _loadedTexture_89
            ranges[95].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[95].NumDescriptors = 1;
            ranges[95].BaseShaderRegister = 91;
            ranges[95].RegisterSpace = 0;
            ranges[95].OffsetInDescriptorsFromTableStart = 95;

            // _loadedTexture_90
            ranges[96].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[96].NumDescriptors = 1;
            ranges[96].BaseShaderRegister = 92;
            ranges[96].RegisterSpace = 0;
            ranges[96].OffsetInDescriptorsFromTableStart = 96;

            // _loadedTexture_91
            ranges[97].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[97].NumDescriptors = 1;
            ranges[97].BaseShaderRegister = 93;
            ranges[97].RegisterSpace = 0;
            ranges[97].OffsetInDescriptorsFromTableStart = 97;

            // _loadedTexture_92
            ranges[98].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[98].NumDescriptors = 1;
            ranges[98].BaseShaderRegister = 94;
            ranges[98].RegisterSpace = 0;
            ranges[98].OffsetInDescriptorsFromTableStart = 98;

            // _loadedTexture_93
            ranges[99].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[99].NumDescriptors = 1;
            ranges[99].BaseShaderRegister = 95;
            ranges[99].RegisterSpace = 0;
            ranges[99].OffsetInDescriptorsFromTableStart = 99;

            // _loadedTexture_94
            ranges[100].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[100].NumDescriptors = 1;
            ranges[100].BaseShaderRegister = 96;
            ranges[100].RegisterSpace = 0;
            ranges[100].OffsetInDescriptorsFromTableStart = 100;

            // _loadedTexture_95
            ranges[101].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[101].NumDescriptors = 1;
            ranges[101].BaseShaderRegister = 97;
            ranges[101].RegisterSpace = 0;
            ranges[101].OffsetInDescriptorsFromTableStart = 101;

            // _loadedTexture_96
            ranges[102].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[102].NumDescriptors = 1;
            ranges[102].BaseShaderRegister = 98;
            ranges[102].RegisterSpace = 0;
            ranges[102].OffsetInDescriptorsFromTableStart = 102;

            // _loadedTexture_97
            ranges[103].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[103].NumDescriptors = 1;
            ranges[103].BaseShaderRegister = 99;
            ranges[103].RegisterSpace = 0;
            ranges[103].OffsetInDescriptorsFromTableStart = 103;

            // _loadedTexture_98
            ranges[104].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[104].NumDescriptors = 1;
            ranges[104].BaseShaderRegister = 100;
            ranges[104].RegisterSpace = 0;
            ranges[104].OffsetInDescriptorsFromTableStart = 104;

            // _loadedTexture_99
            ranges[105].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[105].NumDescriptors = 1;
            ranges[105].BaseShaderRegister = 101;
            ranges[105].RegisterSpace = 0;
            ranges[105].OffsetInDescriptorsFromTableStart = 105;

            // _loadedTexture_100
            ranges[106].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[106].NumDescriptors = 1;
            ranges[106].BaseShaderRegister = 102;
            ranges[106].RegisterSpace = 0;
            ranges[106].OffsetInDescriptorsFromTableStart = 106;

            // _loadedTexture_101
            ranges[107].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[107].NumDescriptors = 1;
            ranges[107].BaseShaderRegister = 103;
            ranges[107].RegisterSpace = 0;
            ranges[107].OffsetInDescriptorsFromTableStart = 107;

            // _loadedTexture_102
            ranges[108].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[108].NumDescriptors = 1;
            ranges[108].BaseShaderRegister = 104;
            ranges[108].RegisterSpace = 0;
            ranges[108].OffsetInDescriptorsFromTableStart = 108;

            // _loadedTexture_103
            ranges[109].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[109].NumDescriptors = 1;
            ranges[109].BaseShaderRegister = 105;
            ranges[109].RegisterSpace = 0;
            ranges[109].OffsetInDescriptorsFromTableStart = 109;

            // _loadedTexture_104
            ranges[110].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[110].NumDescriptors = 1;
            ranges[110].BaseShaderRegister = 106;
            ranges[110].RegisterSpace = 0;
            ranges[110].OffsetInDescriptorsFromTableStart = 110;

            // _loadedTexture_105
            ranges[111].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[111].NumDescriptors = 1;
            ranges[111].BaseShaderRegister = 107;
            ranges[111].RegisterSpace = 0;
            ranges[111].OffsetInDescriptorsFromTableStart = 111;

            // _loadedTexture_106
            ranges[112].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[112].NumDescriptors = 1;
            ranges[112].BaseShaderRegister = 108;
            ranges[112].RegisterSpace = 0;
            ranges[112].OffsetInDescriptorsFromTableStart = 112;

            // _loadedTexture_107
            ranges[113].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[113].NumDescriptors = 1;
            ranges[113].BaseShaderRegister = 109;
            ranges[113].RegisterSpace = 0;
            ranges[113].OffsetInDescriptorsFromTableStart = 113;

            // _loadedTexture_108
            ranges[114].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[114].NumDescriptors = 1;
            ranges[114].BaseShaderRegister = 110;
            ranges[114].RegisterSpace = 0;
            ranges[114].OffsetInDescriptorsFromTableStart = 114;

            // _loadedTexture_109
            ranges[115].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[115].NumDescriptors = 1;
            ranges[115].BaseShaderRegister = 111;
            ranges[115].RegisterSpace = 0;
            ranges[115].OffsetInDescriptorsFromTableStart = 115;

            // _loadedTexture_110
            ranges[116].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[116].NumDescriptors = 1;
            ranges[116].BaseShaderRegister = 112;
            ranges[116].RegisterSpace = 0;
            ranges[116].OffsetInDescriptorsFromTableStart = 116;

            // _loadedTexture_111
            ranges[117].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[117].NumDescriptors = 1;
            ranges[117].BaseShaderRegister = 113;
            ranges[117].RegisterSpace = 0;
            ranges[117].OffsetInDescriptorsFromTableStart = 117;

            // _loadedTexture_112
            ranges[118].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[118].NumDescriptors = 1;
            ranges[118].BaseShaderRegister = 114;
            ranges[118].RegisterSpace = 0;
            ranges[118].OffsetInDescriptorsFromTableStart = 118;

            // _loadedTexture_113
            ranges[119].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[119].NumDescriptors = 1;
            ranges[119].BaseShaderRegister = 115;
            ranges[119].RegisterSpace = 0;
            ranges[119].OffsetInDescriptorsFromTableStart = 119;

            // _loadedTexture_114
            ranges[120].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[120].NumDescriptors = 1;
            ranges[120].BaseShaderRegister = 116;
            ranges[120].RegisterSpace = 0;
            ranges[120].OffsetInDescriptorsFromTableStart = 120;

            // _loadedTexture_115
            ranges[121].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[121].NumDescriptors = 1;
            ranges[121].BaseShaderRegister = 117;
            ranges[121].RegisterSpace = 0;
            ranges[121].OffsetInDescriptorsFromTableStart = 121;

            // _loadedTexture_116
            ranges[122].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[122].NumDescriptors = 1;
            ranges[122].BaseShaderRegister = 118;
            ranges[122].RegisterSpace = 0;
            ranges[122].OffsetInDescriptorsFromTableStart = 122;

            // _loadedTexture_117
            ranges[123].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[123].NumDescriptors = 1;
            ranges[123].BaseShaderRegister = 119;
            ranges[123].RegisterSpace = 0;
            ranges[123].OffsetInDescriptorsFromTableStart = 123;

            // _loadedTexture_118
            ranges[124].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[124].NumDescriptors = 1;
            ranges[124].BaseShaderRegister = 120;
            ranges[124].RegisterSpace = 0;
            ranges[124].OffsetInDescriptorsFromTableStart = 124;

            // _loadedTexture_119
            ranges[125].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[125].NumDescriptors = 1;
            ranges[125].BaseShaderRegister = 121;
            ranges[125].RegisterSpace = 0;
            ranges[125].OffsetInDescriptorsFromTableStart = 125;

            // _loadedTexture_120
            ranges[126].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[126].NumDescriptors = 1;
            ranges[126].BaseShaderRegister = 122;
            ranges[126].RegisterSpace = 0;
            ranges[126].OffsetInDescriptorsFromTableStart = 126;

            // _loadedTexture_121
            ranges[127].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[127].NumDescriptors = 1;
            ranges[127].BaseShaderRegister = 123;
            ranges[127].RegisterSpace = 0;
            ranges[127].OffsetInDescriptorsFromTableStart = 127;

            // _loadedTexture_122
            ranges[128].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[128].NumDescriptors = 1;
            ranges[128].BaseShaderRegister = 124;
            ranges[128].RegisterSpace = 0;
            ranges[128].OffsetInDescriptorsFromTableStart = 128;

            // _loadedTexture_123
            ranges[129].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[129].NumDescriptors = 1;
            ranges[129].BaseShaderRegister = 125;
            ranges[129].RegisterSpace = 0;
            ranges[129].OffsetInDescriptorsFromTableStart = 129;

            // _loadedTexture_124
            ranges[130].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[130].NumDescriptors = 1;
            ranges[130].BaseShaderRegister = 126;
            ranges[130].RegisterSpace = 0;
            ranges[130].OffsetInDescriptorsFromTableStart = 130;

            // _loadedTexture_125
            ranges[131].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[131].NumDescriptors = 1;
            ranges[131].BaseShaderRegister = 127;
            ranges[131].RegisterSpace = 0;
            ranges[131].OffsetInDescriptorsFromTableStart = 131;

            // _loadedTexture_126
            ranges[132].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[132].NumDescriptors = 1;
            ranges[132].BaseShaderRegister = 128;
            ranges[132].RegisterSpace = 0;
            ranges[132].OffsetInDescriptorsFromTableStart = 132;

            // _loadedTexture_127
            ranges[133].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[133].NumDescriptors = 1;
            ranges[133].BaseShaderRegister = 129;
            ranges[133].RegisterSpace = 0;
            ranges[133].OffsetInDescriptorsFromTableStart = 133;

            // _loadedTexture_128
            ranges[134].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[134].NumDescriptors = 1;
            ranges[134].BaseShaderRegister = 130;
            ranges[134].RegisterSpace = 0;
            ranges[134].OffsetInDescriptorsFromTableStart = 134;

            // _loadedTexture_129
            ranges[135].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[135].NumDescriptors = 1;
            ranges[135].BaseShaderRegister = 131;
            ranges[135].RegisterSpace = 0;
            ranges[135].OffsetInDescriptorsFromTableStart = 135;

            // _loadedTexture_130
            ranges[136].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[136].NumDescriptors = 1;
            ranges[136].BaseShaderRegister = 132;
            ranges[136].RegisterSpace = 0;
            ranges[136].OffsetInDescriptorsFromTableStart = 136;

            // _loadedTexture_131
            ranges[137].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[137].NumDescriptors = 1;
            ranges[137].BaseShaderRegister = 133;
            ranges[137].RegisterSpace = 0;
            ranges[137].OffsetInDescriptorsFromTableStart = 137;

            // _loadedTexture_132
            ranges[138].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[138].NumDescriptors = 1;
            ranges[138].BaseShaderRegister = 134;
            ranges[138].RegisterSpace = 0;
            ranges[138].OffsetInDescriptorsFromTableStart = 138;

            // _loadedTexture_133
            ranges[139].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[139].NumDescriptors = 1;
            ranges[139].BaseShaderRegister = 135;
            ranges[139].RegisterSpace = 0;
            ranges[139].OffsetInDescriptorsFromTableStart = 139;

            // _loadedTexture_134
            ranges[140].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[140].NumDescriptors = 1;
            ranges[140].BaseShaderRegister = 136;
            ranges[140].RegisterSpace = 0;
            ranges[140].OffsetInDescriptorsFromTableStart = 140;

            // _loadedTexture_135
            ranges[141].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[141].NumDescriptors = 1;
            ranges[141].BaseShaderRegister = 137;
            ranges[141].RegisterSpace = 0;
            ranges[141].OffsetInDescriptorsFromTableStart = 141;

            // _loadedTexture_136
            ranges[142].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[142].NumDescriptors = 1;
            ranges[142].BaseShaderRegister = 138;
            ranges[142].RegisterSpace = 0;
            ranges[142].OffsetInDescriptorsFromTableStart = 142;

            // _loadedTexture_137
            ranges[143].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[143].NumDescriptors = 1;
            ranges[143].BaseShaderRegister = 139;
            ranges[143].RegisterSpace = 0;
            ranges[143].OffsetInDescriptorsFromTableStart = 143;

            // _loadedTexture_138
            ranges[144].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[144].NumDescriptors = 1;
            ranges[144].BaseShaderRegister = 140;
            ranges[144].RegisterSpace = 0;
            ranges[144].OffsetInDescriptorsFromTableStart = 144;

            // _loadedTexture_139
            ranges[145].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[145].NumDescriptors = 1;
            ranges[145].BaseShaderRegister = 141;
            ranges[145].RegisterSpace = 0;
            ranges[145].OffsetInDescriptorsFromTableStart = 145;

            // _loadedTexture_140
            ranges[146].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[146].NumDescriptors = 1;
            ranges[146].BaseShaderRegister = 142;
            ranges[146].RegisterSpace = 0;
            ranges[146].OffsetInDescriptorsFromTableStart = 146;

            // _loadedTexture_141
            ranges[147].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[147].NumDescriptors = 1;
            ranges[147].BaseShaderRegister = 143;
            ranges[147].RegisterSpace = 0;
            ranges[147].OffsetInDescriptorsFromTableStart = 147;

            // _loadedTexture_142
            ranges[148].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[148].NumDescriptors = 1;
            ranges[148].BaseShaderRegister = 144;
            ranges[148].RegisterSpace = 0;
            ranges[148].OffsetInDescriptorsFromTableStart = 148;

            // _loadedTexture_143
            ranges[149].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[149].NumDescriptors = 1;
            ranges[149].BaseShaderRegister = 145;
            ranges[149].RegisterSpace = 0;
            ranges[149].OffsetInDescriptorsFromTableStart = 149;

            // _loadedTexture_144
            ranges[150].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[150].NumDescriptors = 1;
            ranges[150].BaseShaderRegister = 146;
            ranges[150].RegisterSpace = 0;
            ranges[150].OffsetInDescriptorsFromTableStart = 150;

            // _loadedTexture_145
            ranges[151].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[151].NumDescriptors = 1;
            ranges[151].BaseShaderRegister = 147;
            ranges[151].RegisterSpace = 0;
            ranges[151].OffsetInDescriptorsFromTableStart = 151;

            // _loadedTexture_146
            ranges[152].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[152].NumDescriptors = 1;
            ranges[152].BaseShaderRegister = 148;
            ranges[152].RegisterSpace = 0;
            ranges[152].OffsetInDescriptorsFromTableStart = 152;

            // _loadedTexture_147
            ranges[153].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[153].NumDescriptors = 1;
            ranges[153].BaseShaderRegister = 149;
            ranges[153].RegisterSpace = 0;
            ranges[153].OffsetInDescriptorsFromTableStart = 153;

            // _loadedTexture_148
            ranges[154].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[154].NumDescriptors = 1;
            ranges[154].BaseShaderRegister = 150;
            ranges[154].RegisterSpace = 0;
            ranges[154].OffsetInDescriptorsFromTableStart = 154;

            // _loadedTexture_149
            ranges[155].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[155].NumDescriptors = 1;
            ranges[155].BaseShaderRegister = 151;
            ranges[155].RegisterSpace = 0;
            ranges[155].OffsetInDescriptorsFromTableStart = 155;

            // _loadedTexture_150
            ranges[156].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[156].NumDescriptors = 1;
            ranges[156].BaseShaderRegister = 152;
            ranges[156].RegisterSpace = 0;
            ranges[156].OffsetInDescriptorsFromTableStart = 156;

            // _loadedTexture_151
            ranges[157].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[157].NumDescriptors = 1;
            ranges[157].BaseShaderRegister = 153;
            ranges[157].RegisterSpace = 0;
            ranges[157].OffsetInDescriptorsFromTableStart = 157;

            // _loadedTexture_152
            ranges[158].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[158].NumDescriptors = 1;
            ranges[158].BaseShaderRegister = 154;
            ranges[158].RegisterSpace = 0;
            ranges[158].OffsetInDescriptorsFromTableStart = 158;

            // _loadedTexture_153
            ranges[159].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[159].NumDescriptors = 1;
            ranges[159].BaseShaderRegister = 155;
            ranges[159].RegisterSpace = 0;
            ranges[159].OffsetInDescriptorsFromTableStart = 159;

            // _loadedTexture_154
            ranges[160].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[160].NumDescriptors = 1;
            ranges[160].BaseShaderRegister = 156;
            ranges[160].RegisterSpace = 0;
            ranges[160].OffsetInDescriptorsFromTableStart = 160;

            // _loadedTexture_155
            ranges[161].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[161].NumDescriptors = 1;
            ranges[161].BaseShaderRegister = 157;
            ranges[161].RegisterSpace = 0;
            ranges[161].OffsetInDescriptorsFromTableStart = 161;

            // _loadedTexture_156
            ranges[162].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[162].NumDescriptors = 1;
            ranges[162].BaseShaderRegister = 158;
            ranges[162].RegisterSpace = 0;
            ranges[162].OffsetInDescriptorsFromTableStart = 162;

            // _loadedTexture_157
            ranges[163].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[163].NumDescriptors = 1;
            ranges[163].BaseShaderRegister = 159;
            ranges[163].RegisterSpace = 0;
            ranges[163].OffsetInDescriptorsFromTableStart = 163;

            // _loadedTexture_158
            ranges[164].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[164].NumDescriptors = 1;
            ranges[164].BaseShaderRegister = 160;
            ranges[164].RegisterSpace = 0;
            ranges[164].OffsetInDescriptorsFromTableStart = 164;

            // _loadedTexture_159
            ranges[165].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[165].NumDescriptors = 1;
            ranges[165].BaseShaderRegister = 161;
            ranges[165].RegisterSpace = 0;
            ranges[165].OffsetInDescriptorsFromTableStart = 165;

            // _loadedTexture_160
            ranges[166].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[166].NumDescriptors = 1;
            ranges[166].BaseShaderRegister = 162;
            ranges[166].RegisterSpace = 0;
            ranges[166].OffsetInDescriptorsFromTableStart = 166;

            // _loadedTexture_161
            ranges[167].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[167].NumDescriptors = 1;
            ranges[167].BaseShaderRegister = 163;
            ranges[167].RegisterSpace = 0;
            ranges[167].OffsetInDescriptorsFromTableStart = 167;

            // _loadedTexture_162
            ranges[168].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[168].NumDescriptors = 1;
            ranges[168].BaseShaderRegister = 164;
            ranges[168].RegisterSpace = 0;
            ranges[168].OffsetInDescriptorsFromTableStart = 168;

            // _loadedTexture_163
            ranges[169].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[169].NumDescriptors = 1;
            ranges[169].BaseShaderRegister = 165;
            ranges[169].RegisterSpace = 0;
            ranges[169].OffsetInDescriptorsFromTableStart = 169;

            // _loadedTexture_164
            ranges[170].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[170].NumDescriptors = 1;
            ranges[170].BaseShaderRegister = 166;
            ranges[170].RegisterSpace = 0;
            ranges[170].OffsetInDescriptorsFromTableStart = 170;

            // _loadedTexture_165
            ranges[171].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[171].NumDescriptors = 1;
            ranges[171].BaseShaderRegister = 167;
            ranges[171].RegisterSpace = 0;
            ranges[171].OffsetInDescriptorsFromTableStart = 171;

            // _loadedTexture_166
            ranges[172].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[172].NumDescriptors = 1;
            ranges[172].BaseShaderRegister = 168;
            ranges[172].RegisterSpace = 0;
            ranges[172].OffsetInDescriptorsFromTableStart = 172;

            // _loadedTexture_167
            ranges[173].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[173].NumDescriptors = 1;
            ranges[173].BaseShaderRegister = 169;
            ranges[173].RegisterSpace = 0;
            ranges[173].OffsetInDescriptorsFromTableStart = 173;

            // _loadedTexture_168
            ranges[174].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[174].NumDescriptors = 1;
            ranges[174].BaseShaderRegister = 170;
            ranges[174].RegisterSpace = 0;
            ranges[174].OffsetInDescriptorsFromTableStart = 174;

            // _loadedTexture_169
            ranges[175].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[175].NumDescriptors = 1;
            ranges[175].BaseShaderRegister = 171;
            ranges[175].RegisterSpace = 0;
            ranges[175].OffsetInDescriptorsFromTableStart = 175;

            // _loadedTexture_170
            ranges[176].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[176].NumDescriptors = 1;
            ranges[176].BaseShaderRegister = 172;
            ranges[176].RegisterSpace = 0;
            ranges[176].OffsetInDescriptorsFromTableStart = 176;

            // _loadedTexture_171
            ranges[177].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[177].NumDescriptors = 1;
            ranges[177].BaseShaderRegister = 173;
            ranges[177].RegisterSpace = 0;
            ranges[177].OffsetInDescriptorsFromTableStart = 177;

            // _loadedTexture_172
            ranges[178].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[178].NumDescriptors = 1;
            ranges[178].BaseShaderRegister = 174;
            ranges[178].RegisterSpace = 0;
            ranges[178].OffsetInDescriptorsFromTableStart = 178;

            // _loadedTexture_173
            ranges[179].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[179].NumDescriptors = 1;
            ranges[179].BaseShaderRegister = 175;
            ranges[179].RegisterSpace = 0;
            ranges[179].OffsetInDescriptorsFromTableStart = 179;

            // _loadedTexture_174
            ranges[180].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[180].NumDescriptors = 1;
            ranges[180].BaseShaderRegister = 176;
            ranges[180].RegisterSpace = 0;
            ranges[180].OffsetInDescriptorsFromTableStart = 180;

            // _loadedTexture_175
            ranges[181].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[181].NumDescriptors = 1;
            ranges[181].BaseShaderRegister = 177;
            ranges[181].RegisterSpace = 0;
            ranges[181].OffsetInDescriptorsFromTableStart = 181;

            // _loadedTexture_176
            ranges[182].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[182].NumDescriptors = 1;
            ranges[182].BaseShaderRegister = 178;
            ranges[182].RegisterSpace = 0;
            ranges[182].OffsetInDescriptorsFromTableStart = 182;

            // _loadedTexture_177
            ranges[183].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[183].NumDescriptors = 1;
            ranges[183].BaseShaderRegister = 179;
            ranges[183].RegisterSpace = 0;
            ranges[183].OffsetInDescriptorsFromTableStart = 183;

            // _loadedTexture_178
            ranges[184].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[184].NumDescriptors = 1;
            ranges[184].BaseShaderRegister = 180;
            ranges[184].RegisterSpace = 0;
            ranges[184].OffsetInDescriptorsFromTableStart = 184;

            // _loadedTexture_179
            ranges[185].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[185].NumDescriptors = 1;
            ranges[185].BaseShaderRegister = 181;
            ranges[185].RegisterSpace = 0;
            ranges[185].OffsetInDescriptorsFromTableStart = 185;

            // _loadedTexture_180
            ranges[186].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[186].NumDescriptors = 1;
            ranges[186].BaseShaderRegister = 182;
            ranges[186].RegisterSpace = 0;
            ranges[186].OffsetInDescriptorsFromTableStart = 186;

            // _loadedTexture_181
            ranges[187].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[187].NumDescriptors = 1;
            ranges[187].BaseShaderRegister = 183;
            ranges[187].RegisterSpace = 0;
            ranges[187].OffsetInDescriptorsFromTableStart = 187;

            // _loadedTexture_182
            ranges[188].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[188].NumDescriptors = 1;
            ranges[188].BaseShaderRegister = 184;
            ranges[188].RegisterSpace = 0;
            ranges[188].OffsetInDescriptorsFromTableStart = 188;

            // _loadedTexture_183
            ranges[189].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[189].NumDescriptors = 1;
            ranges[189].BaseShaderRegister = 185;
            ranges[189].RegisterSpace = 0;
            ranges[189].OffsetInDescriptorsFromTableStart = 189;

            // _loadedTexture_184
            ranges[190].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[190].NumDescriptors = 1;
            ranges[190].BaseShaderRegister = 186;
            ranges[190].RegisterSpace = 0;
            ranges[190].OffsetInDescriptorsFromTableStart = 190;

            // _loadedTexture_185
            ranges[191].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[191].NumDescriptors = 1;
            ranges[191].BaseShaderRegister = 187;
            ranges[191].RegisterSpace = 0;
            ranges[191].OffsetInDescriptorsFromTableStart = 191;

            // _loadedTexture_186
            ranges[192].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[192].NumDescriptors = 1;
            ranges[192].BaseShaderRegister = 188;
            ranges[192].RegisterSpace = 0;
            ranges[192].OffsetInDescriptorsFromTableStart = 192;

            // _loadedTexture_187
            ranges[193].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[193].NumDescriptors = 1;
            ranges[193].BaseShaderRegister = 189;
            ranges[193].RegisterSpace = 0;
            ranges[193].OffsetInDescriptorsFromTableStart = 193;

            // _loadedTexture_188
            ranges[194].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[194].NumDescriptors = 1;
            ranges[194].BaseShaderRegister = 190;
            ranges[194].RegisterSpace = 0;
            ranges[194].OffsetInDescriptorsFromTableStart = 194;

            // _loadedTexture_189
            ranges[195].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[195].NumDescriptors = 1;
            ranges[195].BaseShaderRegister = 191;
            ranges[195].RegisterSpace = 0;
            ranges[195].OffsetInDescriptorsFromTableStart = 195;

            // _loadedTexture_190
            ranges[196].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[196].NumDescriptors = 1;
            ranges[196].BaseShaderRegister = 192;
            ranges[196].RegisterSpace = 0;
            ranges[196].OffsetInDescriptorsFromTableStart = 196;

            // _loadedTexture_191
            ranges[197].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[197].NumDescriptors = 1;
            ranges[197].BaseShaderRegister = 193;
            ranges[197].RegisterSpace = 0;
            ranges[197].OffsetInDescriptorsFromTableStart = 197;

            // _loadedTexture_192
            ranges[198].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[198].NumDescriptors = 1;
            ranges[198].BaseShaderRegister = 194;
            ranges[198].RegisterSpace = 0;
            ranges[198].OffsetInDescriptorsFromTableStart = 198;

            // _loadedTexture_193
            ranges[199].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[199].NumDescriptors = 1;
            ranges[199].BaseShaderRegister = 195;
            ranges[199].RegisterSpace = 0;
            ranges[199].OffsetInDescriptorsFromTableStart = 199;

            // _loadedTexture_194
            ranges[200].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[200].NumDescriptors = 1;
            ranges[200].BaseShaderRegister = 196;
            ranges[200].RegisterSpace = 0;
            ranges[200].OffsetInDescriptorsFromTableStart = 200;

            // _loadedTexture_195
            ranges[201].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[201].NumDescriptors = 1;
            ranges[201].BaseShaderRegister = 197;
            ranges[201].RegisterSpace = 0;
            ranges[201].OffsetInDescriptorsFromTableStart = 201;

            // _RayGenCB
            ranges[202].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
            ranges[202].NumDescriptors = 1;
            ranges[202].BaseShaderRegister = 0;
            ranges[202].RegisterSpace = 0;
            ranges[202].OffsetInDescriptorsFromTableStart = 202;

            if(!DX12Utils::MakeRootSig(device, ranges, 203, samplers, 2, &ContextInternal::rayShader_Raytrace_rootSig, (c_debugNames ? L"Raytrace" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.shaderModel = "lib_6_3";
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
                shaderCompilationInfo.defines.emplace_back("MAX_RECURSION_DEPTH","3");
                shaderCompilationInfo.defines.emplace_back("RT_HIT_GROUP_COUNT","2");

            // Compile shaders
            std::vector<unsigned char> shaderCode[3];

            // Compile RTMiss : RT_exterior.hlsl Miss()
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "RT_exterior.hlsl";
            shaderCode[0] = DX12Utils::CompileShaderToByteCode_DXC(shaderCompilationInfo, Context::LogFn);
            if (shaderCode[0].empty())
                return false;

            // Compile RTClosestHit : RT_exterior.hlsl ClosestHit()
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "RT_exterior.hlsl";
            shaderCode[1] = DX12Utils::CompileShaderToByteCode_DXC(shaderCompilationInfo, Context::LogFn);
            if (shaderCode[1].empty())
                return false;

            // Compile RTRayGen : RT_exterior.hlsl RayGen()
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "RT_exterior.hlsl";
            shaderCode[2] = DX12Utils::CompileShaderToByteCode_DXC(shaderCompilationInfo, Context::LogFn);
            if (shaderCode[2].empty())
                return false;

            // Make the state object
            D3D12_STATE_SUBOBJECT subObjects[9];

            D3D12_STATE_OBJECT_DESC soDesc;
            soDesc.Type = D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE;
            soDesc.NumSubobjects = 9;
            soDesc.pSubobjects = subObjects;

            // DXIL Library for RTMiss : RT_exterior.hlsl Miss()
            {
                static D3D12_EXPORT_DESC exportDesc;
                exportDesc.Name = L"Miss_0";
                exportDesc.ExportToRename = L"Miss";
                exportDesc.Flags = D3D12_EXPORT_FLAG_NONE;

                static D3D12_DXIL_LIBRARY_DESC libDesc;
                libDesc.DXILLibrary.BytecodeLength = shaderCode[0].size();
                libDesc.DXILLibrary.pShaderBytecode = shaderCode[0].data();
                libDesc.NumExports = 1;
                libDesc.pExports = &exportDesc;

                subObjects[0].Type = D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY;
                subObjects[0].pDesc = &libDesc;
            }

            // DXIL Library for RTClosestHit : RT_exterior.hlsl ClosestHit()
            {
                static D3D12_EXPORT_DESC exportDesc;
                exportDesc.Name = L"ClosestHit_1";
                exportDesc.ExportToRename = L"ClosestHit";
                exportDesc.Flags = D3D12_EXPORT_FLAG_NONE;

                static D3D12_DXIL_LIBRARY_DESC libDesc;
                libDesc.DXILLibrary.BytecodeLength = shaderCode[1].size();
                libDesc.DXILLibrary.pShaderBytecode = shaderCode[1].data();
                libDesc.NumExports = 1;
                libDesc.pExports = &exportDesc;

                subObjects[1].Type = D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY;
                subObjects[1].pDesc = &libDesc;
            }

            // DXIL Library for RTRayGen : RT_exterior.hlsl RayGen()
            {
                static D3D12_EXPORT_DESC exportDesc;
                exportDesc.Name = L"RayGen_2";
                exportDesc.ExportToRename = L"RayGen";
                exportDesc.Flags = D3D12_EXPORT_FLAG_NONE;

                static D3D12_DXIL_LIBRARY_DESC libDesc;
                libDesc.DXILLibrary.BytecodeLength = shaderCode[2].size();
                libDesc.DXILLibrary.pShaderBytecode = shaderCode[2].data();
                libDesc.NumExports = 1;
                libDesc.pExports = &exportDesc;

                subObjects[2].Type = D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY;
                subObjects[2].pDesc = &libDesc;
            }

            // Make the hit group sub objects
            D3D12_HIT_GROUP_DESC hitGroupDescs[2];

            // Hit group: HitGroupPathTrace
            {
                D3D12_HIT_GROUP_DESC& hitGroupDesc = hitGroupDescs[0];
                hitGroupDesc.HitGroupExport = L"hitgroup0";
                hitGroupDesc.AnyHitShaderImport = nullptr;
                hitGroupDesc.ClosestHitShaderImport = L"ClosestHit_1";
                hitGroupDesc.IntersectionShaderImport = nullptr;
                hitGroupDesc.Type = D3D12_HIT_GROUP_TYPE_TRIANGLES;
                subObjects[3].Type = D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP;
                subObjects[3].pDesc = &hitGroupDesc;
            }

            // Hit group: HitGroupPathTrace
            {
                D3D12_HIT_GROUP_DESC& hitGroupDesc = hitGroupDescs[1];
                hitGroupDesc.HitGroupExport = L"hitgroup1";
                hitGroupDesc.AnyHitShaderImport = nullptr;
                hitGroupDesc.ClosestHitShaderImport = L"ClosestHit_1";
                hitGroupDesc.IntersectionShaderImport = nullptr;
                hitGroupDesc.Type = D3D12_HIT_GROUP_TYPE_TRIANGLES;
                subObjects[4].Type = D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP;
                subObjects[4].pDesc = &hitGroupDesc;
            }

            // Payload
            D3D12_RAYTRACING_SHADER_CONFIG payloadDesc;
            payloadDesc.MaxPayloadSizeInBytes = 64;
            payloadDesc.MaxAttributeSizeInBytes = D3D12_RAYTRACING_MAX_ATTRIBUTE_SIZE_IN_BYTES;

            subObjects[5].Type = D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_SHADER_CONFIG;
            subObjects[5].pDesc = &payloadDesc;

            // Associate payload with shaders
            const WCHAR* shaderExports[] = { L"Miss_0", L"ClosestHit_1", L"RayGen_2" };

            D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION shaderPayloadAssociation = {};
            shaderPayloadAssociation.NumExports = 3;
            shaderPayloadAssociation.pExports = shaderExports;
            shaderPayloadAssociation.pSubobjectToAssociate = &subObjects[5];

            subObjects[6].Type = D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION;
            subObjects[6].pDesc = &shaderPayloadAssociation;

            // Pipeline Config
            D3D12_RAYTRACING_PIPELINE_CONFIG pipelineConfig;
            pipelineConfig.MaxTraceRecursionDepth = 3;

            subObjects[7].Type = D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG;
            subObjects[7].pDesc = &pipelineConfig;

            // Global Root Signature
            subObjects[8].Type = D3D12_STATE_SUBOBJECT_TYPE_GLOBAL_ROOT_SIGNATURE;
            subObjects[8].pDesc = &ContextInternal::rayShader_Raytrace_rootSig;
            if (FAILED(dxrDevice->CreateStateObject(&soDesc, IID_PPV_ARGS(&ContextInternal::rayShader_Raytrace_rtso))))
                return false;

            if (c_debugNames)
                ContextInternal::rayShader_Raytrace_rtso->SetName(L"Raytrace state object");

            // Create the shader tables
            {
                ID3D12StateObjectProperties* soprops = nullptr;
                if(FAILED(ContextInternal::rayShader_Raytrace_rtso->QueryInterface(IID_PPV_ARGS(&soprops))))
                    return false;

                // make the ray gen shader table and fill it out
                {
                    ContextInternal::rayShader_Raytrace_shaderTableRayGenSize = ALIGN(D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT, (unsigned int)(1 * D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT));
                    ContextInternal::rayShader_Raytrace_shaderTableRayGen = DX12Utils::CreateBuffer(device, ContextInternal::rayShader_Raytrace_shaderTableRayGenSize, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_HEAP_TYPE_UPLOAD, (c_debugNames ? L"Raytrace shader table ray gen" : nullptr), nullptr);

                    unsigned char* shaderTableBytes = nullptr;
                    D3D12_RANGE readRange = { 0, 0 };
                    ContextInternal::rayShader_Raytrace_shaderTableRayGen->Map(0, &readRange, (void**)&shaderTableBytes);

                    memcpy(shaderTableBytes, soprops->GetShaderIdentifier(L"RayGen_2"), D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT);
                    shaderTableBytes += D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT;

                    ContextInternal::rayShader_Raytrace_shaderTableRayGen->Unmap(0, nullptr);
                }

                // make the miss shader table and fill it out
                {
                    ContextInternal::rayShader_Raytrace_shaderTableMissSize = ALIGN(D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT, (unsigned int)(1 * D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT));
                    ContextInternal::rayShader_Raytrace_shaderTableMiss = DX12Utils::CreateBuffer(device, ContextInternal::rayShader_Raytrace_shaderTableMissSize, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_HEAP_TYPE_UPLOAD, (c_debugNames ? L"Raytrace shader table miss" : nullptr), nullptr);

                    unsigned char* shaderTableBytes = nullptr;
                    D3D12_RANGE readRange = { 0, 0 };
                    ContextInternal::rayShader_Raytrace_shaderTableMiss->Map(0, &readRange, (void**)&shaderTableBytes);

                    memcpy(shaderTableBytes, soprops->GetShaderIdentifier(L"Miss_0"), D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT);
                    shaderTableBytes += D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT;

                    ContextInternal::rayShader_Raytrace_shaderTableMiss->Unmap(0, nullptr);
                }

                // make the hit group shader table and fill it out
                {
                    ContextInternal::rayShader_Raytrace_shaderTableHitGroupSize = ALIGN(D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT, (unsigned int)(2 * D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT));
                    ContextInternal::rayShader_Raytrace_shaderTableHitGroup = DX12Utils::CreateBuffer(device, ContextInternal::rayShader_Raytrace_shaderTableHitGroupSize, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_GENERIC_READ, D3D12_HEAP_TYPE_UPLOAD, (c_debugNames ? L"Raytrace shader table hit group" : nullptr), nullptr);

                    unsigned char* shaderTableBytes = nullptr;
                    D3D12_RANGE readRange = { 0, 0 };
                    ContextInternal::rayShader_Raytrace_shaderTableHitGroup->Map(0, &readRange, (void**)&shaderTableBytes);

                    memcpy(shaderTableBytes, soprops->GetShaderIdentifier(L"hitgroup0"), D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT);
                    shaderTableBytes += D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT;
                    memcpy(shaderTableBytes, soprops->GetShaderIdentifier(L"hitgroup1"), D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT);
                    shaderTableBytes += D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT;

                    ContextInternal::rayShader_Raytrace_shaderTableHitGroup->Unmap(0, nullptr);
                }

                soprops->Release();
            }
        }

        // Compute Shader: GatherDOF_Setup
        {
            D3D12_STATIC_SAMPLER_DESC* samplers = nullptr;

            D3D12_DESCRIPTOR_RANGE ranges[6];

            // Color
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // Depth
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 1;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            // FarFieldColorCoC
            ranges[2].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[2].NumDescriptors = 1;
            ranges[2].BaseShaderRegister = 0;
            ranges[2].RegisterSpace = 0;
            ranges[2].OffsetInDescriptorsFromTableStart = 2;

            // NearFieldColorCoC
            ranges[3].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[3].NumDescriptors = 1;
            ranges[3].BaseShaderRegister = 1;
            ranges[3].RegisterSpace = 0;
            ranges[3].OffsetInDescriptorsFromTableStart = 3;

            // NearMaxCocTilemap
            ranges[4].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[4].NumDescriptors = 1;
            ranges[4].BaseShaderRegister = 2;
            ranges[4].RegisterSpace = 0;
            ranges[4].OffsetInDescriptorsFromTableStart = 4;

            // _GatherDOF_SetupCSCB
            ranges[5].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
            ranges[5].NumDescriptors = 1;
            ranges[5].BaseShaderRegister = 0;
            ranges[5].RegisterSpace = 0;
            ranges[5].OffsetInDescriptorsFromTableStart = 5;

            if(!DX12Utils::MakeRootSig(device, ranges, 6, samplers, 0, &ContextInternal::computeShader_GatherDOF_Setup_rootSig, (c_debugNames ? L"GatherDOF_Setup" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "dof_GatherDOF/SetupCS.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "GatherDOF_Setup" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_GatherDOF_Setup_rootSig, &ContextInternal::computeShader_GatherDOF_Setup_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: GatherDOF_NearBorder
        {
            D3D12_STATIC_SAMPLER_DESC* samplers = nullptr;

            D3D12_DESCRIPTOR_RANGE ranges[2];

            // NearFieldColorCoC
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // NearFieldColorCoCBorder
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 0;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            if(!DX12Utils::MakeRootSig(device, ranges, 2, samplers, 0, &ContextInternal::computeShader_GatherDOF_NearBorder_rootSig, (c_debugNames ? L"GatherDOF_NearBorder" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "dof_GatherDOF/NearBorderCS.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "GatherDOF_NearBorder" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_GatherDOF_NearBorder_rootSig, &ContextInternal::computeShader_GatherDOF_NearBorder_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: GatherDOF_BlurFar
        {
            D3D12_STATIC_SAMPLER_DESC samplers[1];

            // linearClampSampler
            samplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
            samplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].MipLODBias  = 0;
            samplers[0].MaxAnisotropy  = 0;
            samplers[0].ComparisonFunc  = D3D12_COMPARISON_FUNC_NEVER;
            samplers[0].BorderColor  = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
            samplers[0].MinLOD = 0.0f;
            samplers[0].MaxLOD = D3D12_FLOAT32_MAX;
            samplers[0].ShaderRegister = 0;
            samplers[0].RegisterSpace = 0;
            samplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

            D3D12_DESCRIPTOR_RANGE ranges[21];

            // FarFieldColorCoC
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // BlurredFarFieldColorAlpha
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 0;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            // _loadedTexture_179
            ranges[2].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[2].NumDescriptors = 1;
            ranges[2].BaseShaderRegister = 1;
            ranges[2].RegisterSpace = 0;
            ranges[2].OffsetInDescriptorsFromTableStart = 2;

            // _loadedTexture_180
            ranges[3].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[3].NumDescriptors = 1;
            ranges[3].BaseShaderRegister = 2;
            ranges[3].RegisterSpace = 0;
            ranges[3].OffsetInDescriptorsFromTableStart = 3;

            // _loadedTexture_181
            ranges[4].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[4].NumDescriptors = 1;
            ranges[4].BaseShaderRegister = 3;
            ranges[4].RegisterSpace = 0;
            ranges[4].OffsetInDescriptorsFromTableStart = 4;

            // _loadedTexture_182
            ranges[5].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[5].NumDescriptors = 1;
            ranges[5].BaseShaderRegister = 4;
            ranges[5].RegisterSpace = 0;
            ranges[5].OffsetInDescriptorsFromTableStart = 5;

            // _loadedTexture_183
            ranges[6].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[6].NumDescriptors = 1;
            ranges[6].BaseShaderRegister = 5;
            ranges[6].RegisterSpace = 0;
            ranges[6].OffsetInDescriptorsFromTableStart = 6;

            // _loadedTexture_171
            ranges[7].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[7].NumDescriptors = 1;
            ranges[7].BaseShaderRegister = 6;
            ranges[7].RegisterSpace = 0;
            ranges[7].OffsetInDescriptorsFromTableStart = 7;

            // _loadedTexture_184
            ranges[8].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[8].NumDescriptors = 1;
            ranges[8].BaseShaderRegister = 7;
            ranges[8].RegisterSpace = 0;
            ranges[8].OffsetInDescriptorsFromTableStart = 8;

            // _loadedTexture_185
            ranges[9].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[9].NumDescriptors = 1;
            ranges[9].BaseShaderRegister = 8;
            ranges[9].RegisterSpace = 0;
            ranges[9].OffsetInDescriptorsFromTableStart = 9;

            // _loadedTexture_187
            ranges[10].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[10].NumDescriptors = 1;
            ranges[10].BaseShaderRegister = 9;
            ranges[10].RegisterSpace = 0;
            ranges[10].OffsetInDescriptorsFromTableStart = 10;

            // _loadedTexture_188
            ranges[11].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[11].NumDescriptors = 1;
            ranges[11].BaseShaderRegister = 10;
            ranges[11].RegisterSpace = 0;
            ranges[11].OffsetInDescriptorsFromTableStart = 11;

            // _loadedTexture_186
            ranges[12].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[12].NumDescriptors = 1;
            ranges[12].BaseShaderRegister = 11;
            ranges[12].RegisterSpace = 0;
            ranges[12].OffsetInDescriptorsFromTableStart = 12;

            // _loadedTexture_189
            ranges[13].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[13].NumDescriptors = 1;
            ranges[13].BaseShaderRegister = 12;
            ranges[13].RegisterSpace = 0;
            ranges[13].OffsetInDescriptorsFromTableStart = 13;

            // _loadedTexture_190
            ranges[14].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[14].NumDescriptors = 1;
            ranges[14].BaseShaderRegister = 13;
            ranges[14].RegisterSpace = 0;
            ranges[14].OffsetInDescriptorsFromTableStart = 14;

            // _loadedTexture_191
            ranges[15].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[15].NumDescriptors = 1;
            ranges[15].BaseShaderRegister = 14;
            ranges[15].RegisterSpace = 0;
            ranges[15].OffsetInDescriptorsFromTableStart = 15;

            // _loadedTexture_192
            ranges[16].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[16].NumDescriptors = 1;
            ranges[16].BaseShaderRegister = 15;
            ranges[16].RegisterSpace = 0;
            ranges[16].OffsetInDescriptorsFromTableStart = 16;

            // _loadedTexture_193
            ranges[17].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[17].NumDescriptors = 1;
            ranges[17].BaseShaderRegister = 16;
            ranges[17].RegisterSpace = 0;
            ranges[17].OffsetInDescriptorsFromTableStart = 17;

            // _loadedTexture_194
            ranges[18].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[18].NumDescriptors = 1;
            ranges[18].BaseShaderRegister = 17;
            ranges[18].RegisterSpace = 0;
            ranges[18].OffsetInDescriptorsFromTableStart = 18;

            // _loadedTexture_195
            ranges[19].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[19].NumDescriptors = 1;
            ranges[19].BaseShaderRegister = 18;
            ranges[19].RegisterSpace = 0;
            ranges[19].OffsetInDescriptorsFromTableStart = 19;

            // _GatherDOF_BlurFarCSCB
            ranges[20].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
            ranges[20].NumDescriptors = 1;
            ranges[20].BaseShaderRegister = 0;
            ranges[20].RegisterSpace = 0;
            ranges[20].OffsetInDescriptorsFromTableStart = 20;

            if(!DX12Utils::MakeRootSig(device, ranges, 21, samplers, 1, &ContextInternal::computeShader_GatherDOF_BlurFar_rootSig, (c_debugNames ? L"GatherDOF_BlurFar" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "dof_GatherDOF/BlurFarCS.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "GatherDOF_BlurFar" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_GatherDOF_BlurFar_rootSig, &ContextInternal::computeShader_GatherDOF_BlurFar_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: GatherDOF_FloodFillFar
        {
            D3D12_STATIC_SAMPLER_DESC samplers[1];

            // linearClampSampler
            samplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
            samplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].MipLODBias  = 0;
            samplers[0].MaxAnisotropy  = 0;
            samplers[0].ComparisonFunc  = D3D12_COMPARISON_FUNC_NEVER;
            samplers[0].BorderColor  = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
            samplers[0].MinLOD = 0.0f;
            samplers[0].MaxLOD = D3D12_FLOAT32_MAX;
            samplers[0].ShaderRegister = 0;
            samplers[0].RegisterSpace = 0;
            samplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

            D3D12_DESCRIPTOR_RANGE ranges[22];

            // MaxCoCTileMap
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // ColorCoc
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 1;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            // BlurredFieldColorAlpha
            ranges[2].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[2].NumDescriptors = 1;
            ranges[2].BaseShaderRegister = 0;
            ranges[2].RegisterSpace = 0;
            ranges[2].OffsetInDescriptorsFromTableStart = 2;

            // _loadedTexture_179
            ranges[3].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[3].NumDescriptors = 1;
            ranges[3].BaseShaderRegister = 2;
            ranges[3].RegisterSpace = 0;
            ranges[3].OffsetInDescriptorsFromTableStart = 3;

            // _loadedTexture_180
            ranges[4].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[4].NumDescriptors = 1;
            ranges[4].BaseShaderRegister = 3;
            ranges[4].RegisterSpace = 0;
            ranges[4].OffsetInDescriptorsFromTableStart = 4;

            // _loadedTexture_181
            ranges[5].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[5].NumDescriptors = 1;
            ranges[5].BaseShaderRegister = 4;
            ranges[5].RegisterSpace = 0;
            ranges[5].OffsetInDescriptorsFromTableStart = 5;

            // _loadedTexture_182
            ranges[6].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[6].NumDescriptors = 1;
            ranges[6].BaseShaderRegister = 5;
            ranges[6].RegisterSpace = 0;
            ranges[6].OffsetInDescriptorsFromTableStart = 6;

            // _loadedTexture_183
            ranges[7].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[7].NumDescriptors = 1;
            ranges[7].BaseShaderRegister = 6;
            ranges[7].RegisterSpace = 0;
            ranges[7].OffsetInDescriptorsFromTableStart = 7;

            // _loadedTexture_171
            ranges[8].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[8].NumDescriptors = 1;
            ranges[8].BaseShaderRegister = 7;
            ranges[8].RegisterSpace = 0;
            ranges[8].OffsetInDescriptorsFromTableStart = 8;

            // _loadedTexture_184
            ranges[9].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[9].NumDescriptors = 1;
            ranges[9].BaseShaderRegister = 8;
            ranges[9].RegisterSpace = 0;
            ranges[9].OffsetInDescriptorsFromTableStart = 9;

            // _loadedTexture_185
            ranges[10].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[10].NumDescriptors = 1;
            ranges[10].BaseShaderRegister = 9;
            ranges[10].RegisterSpace = 0;
            ranges[10].OffsetInDescriptorsFromTableStart = 10;

            // _loadedTexture_186
            ranges[11].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[11].NumDescriptors = 1;
            ranges[11].BaseShaderRegister = 10;
            ranges[11].RegisterSpace = 0;
            ranges[11].OffsetInDescriptorsFromTableStart = 11;

            // _loadedTexture_187
            ranges[12].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[12].NumDescriptors = 1;
            ranges[12].BaseShaderRegister = 11;
            ranges[12].RegisterSpace = 0;
            ranges[12].OffsetInDescriptorsFromTableStart = 12;

            // _loadedTexture_188
            ranges[13].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[13].NumDescriptors = 1;
            ranges[13].BaseShaderRegister = 12;
            ranges[13].RegisterSpace = 0;
            ranges[13].OffsetInDescriptorsFromTableStart = 13;

            // _loadedTexture_189
            ranges[14].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[14].NumDescriptors = 1;
            ranges[14].BaseShaderRegister = 13;
            ranges[14].RegisterSpace = 0;
            ranges[14].OffsetInDescriptorsFromTableStart = 14;

            // _loadedTexture_190
            ranges[15].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[15].NumDescriptors = 1;
            ranges[15].BaseShaderRegister = 14;
            ranges[15].RegisterSpace = 0;
            ranges[15].OffsetInDescriptorsFromTableStart = 15;

            // _loadedTexture_191
            ranges[16].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[16].NumDescriptors = 1;
            ranges[16].BaseShaderRegister = 15;
            ranges[16].RegisterSpace = 0;
            ranges[16].OffsetInDescriptorsFromTableStart = 16;

            // _loadedTexture_192
            ranges[17].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[17].NumDescriptors = 1;
            ranges[17].BaseShaderRegister = 16;
            ranges[17].RegisterSpace = 0;
            ranges[17].OffsetInDescriptorsFromTableStart = 17;

            // _loadedTexture_193
            ranges[18].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[18].NumDescriptors = 1;
            ranges[18].BaseShaderRegister = 17;
            ranges[18].RegisterSpace = 0;
            ranges[18].OffsetInDescriptorsFromTableStart = 18;

            // _loadedTexture_194
            ranges[19].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[19].NumDescriptors = 1;
            ranges[19].BaseShaderRegister = 18;
            ranges[19].RegisterSpace = 0;
            ranges[19].OffsetInDescriptorsFromTableStart = 19;

            // _loadedTexture_195
            ranges[20].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[20].NumDescriptors = 1;
            ranges[20].BaseShaderRegister = 19;
            ranges[20].RegisterSpace = 0;
            ranges[20].OffsetInDescriptorsFromTableStart = 20;

            // _GatherDOF_FloodFillFarCS_0CB
            ranges[21].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
            ranges[21].NumDescriptors = 1;
            ranges[21].BaseShaderRegister = 0;
            ranges[21].RegisterSpace = 0;
            ranges[21].OffsetInDescriptorsFromTableStart = 21;

            if(!DX12Utils::MakeRootSig(device, ranges, 22, samplers, 1, &ContextInternal::computeShader_GatherDOF_FloodFillFar_rootSig, (c_debugNames ? L"GatherDOF_FloodFillFar" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "dof_GatherDOF/FloodFillFarCS_0.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "GatherDOF_FloodFillFar" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("COC_TILEMAP","0");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_GatherDOF_FloodFillFar_rootSig, &ContextInternal::computeShader_GatherDOF_FloodFillFar_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: GatherDOF_DownscaleTileMap_1_4
        {
            D3D12_STATIC_SAMPLER_DESC* samplers = nullptr;

            D3D12_DESCRIPTOR_RANGE ranges[2];

            // Source
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // Dest
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 0;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            if(!DX12Utils::MakeRootSig(device, ranges, 2, samplers, 0, &ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_rootSig, (c_debugNames ? L"GatherDOF_DownscaleTileMap_1_4" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "dof_GatherDOF/DownscaleTileMap_1_4.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "GatherDOF_DownscaleTileMap_1_4" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_rootSig, &ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: GatherDOF_DownscaleTileMap_1_8
        {
            D3D12_STATIC_SAMPLER_DESC* samplers = nullptr;

            D3D12_DESCRIPTOR_RANGE ranges[2];

            // Source
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // Dest
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 0;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            if(!DX12Utils::MakeRootSig(device, ranges, 2, samplers, 0, &ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_rootSig, (c_debugNames ? L"GatherDOF_DownscaleTileMap_1_8" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "dof_GatherDOF/DownscaleTileMap_1_4.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "GatherDOF_DownscaleTileMap_1_8" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_rootSig, &ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: GatherDOF_NearHalo
        {
            D3D12_STATIC_SAMPLER_DESC* samplers = nullptr;

            D3D12_DESCRIPTOR_RANGE ranges[2];

            // NearMaxCocTilemap_1_8
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // NearMaxCocTilemap_1_8_Halo
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 0;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            if(!DX12Utils::MakeRootSig(device, ranges, 2, samplers, 0, &ContextInternal::computeShader_GatherDOF_NearHalo_rootSig, (c_debugNames ? L"GatherDOF_NearHalo" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "dof_GatherDOF/NearHaloCS.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "GatherDOF_NearHalo" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_GatherDOF_NearHalo_rootSig, &ContextInternal::computeShader_GatherDOF_NearHalo_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: GatherDOF_NearBlur
        {
            D3D12_STATIC_SAMPLER_DESC samplers[1];

            // linearClampSampler
            samplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
            samplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].MipLODBias  = 0;
            samplers[0].MaxAnisotropy  = 0;
            samplers[0].ComparisonFunc  = D3D12_COMPARISON_FUNC_NEVER;
            samplers[0].BorderColor  = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
            samplers[0].MinLOD = 0.0f;
            samplers[0].MaxLOD = D3D12_FLOAT32_MAX;
            samplers[0].ShaderRegister = 0;
            samplers[0].RegisterSpace = 0;
            samplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

            D3D12_DESCRIPTOR_RANGE ranges[22];

            // NearFieldColorCoCBorder
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // NearmaxCoCTilemap_1_8_Halo
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 1;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            // NearFieldColorCoCBorderBlurred
            ranges[2].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[2].NumDescriptors = 1;
            ranges[2].BaseShaderRegister = 0;
            ranges[2].RegisterSpace = 0;
            ranges[2].OffsetInDescriptorsFromTableStart = 2;

            // _loadedTexture_179
            ranges[3].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[3].NumDescriptors = 1;
            ranges[3].BaseShaderRegister = 2;
            ranges[3].RegisterSpace = 0;
            ranges[3].OffsetInDescriptorsFromTableStart = 3;

            // _loadedTexture_180
            ranges[4].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[4].NumDescriptors = 1;
            ranges[4].BaseShaderRegister = 3;
            ranges[4].RegisterSpace = 0;
            ranges[4].OffsetInDescriptorsFromTableStart = 4;

            // _loadedTexture_181
            ranges[5].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[5].NumDescriptors = 1;
            ranges[5].BaseShaderRegister = 4;
            ranges[5].RegisterSpace = 0;
            ranges[5].OffsetInDescriptorsFromTableStart = 5;

            // _loadedTexture_182
            ranges[6].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[6].NumDescriptors = 1;
            ranges[6].BaseShaderRegister = 5;
            ranges[6].RegisterSpace = 0;
            ranges[6].OffsetInDescriptorsFromTableStart = 6;

            // _loadedTexture_183
            ranges[7].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[7].NumDescriptors = 1;
            ranges[7].BaseShaderRegister = 6;
            ranges[7].RegisterSpace = 0;
            ranges[7].OffsetInDescriptorsFromTableStart = 7;

            // _loadedTexture_171
            ranges[8].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[8].NumDescriptors = 1;
            ranges[8].BaseShaderRegister = 7;
            ranges[8].RegisterSpace = 0;
            ranges[8].OffsetInDescriptorsFromTableStart = 8;

            // _loadedTexture_184
            ranges[9].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[9].NumDescriptors = 1;
            ranges[9].BaseShaderRegister = 8;
            ranges[9].RegisterSpace = 0;
            ranges[9].OffsetInDescriptorsFromTableStart = 9;

            // _loadedTexture_185
            ranges[10].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[10].NumDescriptors = 1;
            ranges[10].BaseShaderRegister = 9;
            ranges[10].RegisterSpace = 0;
            ranges[10].OffsetInDescriptorsFromTableStart = 10;

            // _loadedTexture_186
            ranges[11].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[11].NumDescriptors = 1;
            ranges[11].BaseShaderRegister = 10;
            ranges[11].RegisterSpace = 0;
            ranges[11].OffsetInDescriptorsFromTableStart = 11;

            // _loadedTexture_187
            ranges[12].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[12].NumDescriptors = 1;
            ranges[12].BaseShaderRegister = 11;
            ranges[12].RegisterSpace = 0;
            ranges[12].OffsetInDescriptorsFromTableStart = 12;

            // _loadedTexture_188
            ranges[13].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[13].NumDescriptors = 1;
            ranges[13].BaseShaderRegister = 12;
            ranges[13].RegisterSpace = 0;
            ranges[13].OffsetInDescriptorsFromTableStart = 13;

            // _loadedTexture_189
            ranges[14].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[14].NumDescriptors = 1;
            ranges[14].BaseShaderRegister = 13;
            ranges[14].RegisterSpace = 0;
            ranges[14].OffsetInDescriptorsFromTableStart = 14;

            // _loadedTexture_190
            ranges[15].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[15].NumDescriptors = 1;
            ranges[15].BaseShaderRegister = 14;
            ranges[15].RegisterSpace = 0;
            ranges[15].OffsetInDescriptorsFromTableStart = 15;

            // _loadedTexture_191
            ranges[16].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[16].NumDescriptors = 1;
            ranges[16].BaseShaderRegister = 15;
            ranges[16].RegisterSpace = 0;
            ranges[16].OffsetInDescriptorsFromTableStart = 16;

            // _loadedTexture_192
            ranges[17].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[17].NumDescriptors = 1;
            ranges[17].BaseShaderRegister = 16;
            ranges[17].RegisterSpace = 0;
            ranges[17].OffsetInDescriptorsFromTableStart = 17;

            // _loadedTexture_193
            ranges[18].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[18].NumDescriptors = 1;
            ranges[18].BaseShaderRegister = 17;
            ranges[18].RegisterSpace = 0;
            ranges[18].OffsetInDescriptorsFromTableStart = 18;

            // _loadedTexture_194
            ranges[19].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[19].NumDescriptors = 1;
            ranges[19].BaseShaderRegister = 18;
            ranges[19].RegisterSpace = 0;
            ranges[19].OffsetInDescriptorsFromTableStart = 19;

            // _loadedTexture_195
            ranges[20].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[20].NumDescriptors = 1;
            ranges[20].BaseShaderRegister = 19;
            ranges[20].RegisterSpace = 0;
            ranges[20].OffsetInDescriptorsFromTableStart = 20;

            // _GatherDOF_NearBlurCB
            ranges[21].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
            ranges[21].NumDescriptors = 1;
            ranges[21].BaseShaderRegister = 0;
            ranges[21].RegisterSpace = 0;
            ranges[21].OffsetInDescriptorsFromTableStart = 21;

            if(!DX12Utils::MakeRootSig(device, ranges, 22, samplers, 1, &ContextInternal::computeShader_GatherDOF_NearBlur_rootSig, (c_debugNames ? L"GatherDOF_NearBlur" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "dof_GatherDOF/NearBlurCS.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "GatherDOF_NearBlur" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_GatherDOF_NearBlur_rootSig, &ContextInternal::computeShader_GatherDOF_NearBlur_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: GatherDOF_FloodFillNear
        {
            D3D12_STATIC_SAMPLER_DESC samplers[1];

            // linearClampSampler
            samplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
            samplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].MipLODBias  = 0;
            samplers[0].MaxAnisotropy  = 0;
            samplers[0].ComparisonFunc  = D3D12_COMPARISON_FUNC_NEVER;
            samplers[0].BorderColor  = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
            samplers[0].MinLOD = 0.0f;
            samplers[0].MaxLOD = D3D12_FLOAT32_MAX;
            samplers[0].ShaderRegister = 0;
            samplers[0].RegisterSpace = 0;
            samplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

            D3D12_DESCRIPTOR_RANGE ranges[22];

            // MaxCoCTileMap
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // ColorCoc
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 1;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            // BlurredFieldColorAlpha
            ranges[2].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[2].NumDescriptors = 1;
            ranges[2].BaseShaderRegister = 0;
            ranges[2].RegisterSpace = 0;
            ranges[2].OffsetInDescriptorsFromTableStart = 2;

            // _loadedTexture_179
            ranges[3].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[3].NumDescriptors = 1;
            ranges[3].BaseShaderRegister = 2;
            ranges[3].RegisterSpace = 0;
            ranges[3].OffsetInDescriptorsFromTableStart = 3;

            // _loadedTexture_180
            ranges[4].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[4].NumDescriptors = 1;
            ranges[4].BaseShaderRegister = 3;
            ranges[4].RegisterSpace = 0;
            ranges[4].OffsetInDescriptorsFromTableStart = 4;

            // _loadedTexture_181
            ranges[5].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[5].NumDescriptors = 1;
            ranges[5].BaseShaderRegister = 4;
            ranges[5].RegisterSpace = 0;
            ranges[5].OffsetInDescriptorsFromTableStart = 5;

            // _loadedTexture_182
            ranges[6].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[6].NumDescriptors = 1;
            ranges[6].BaseShaderRegister = 5;
            ranges[6].RegisterSpace = 0;
            ranges[6].OffsetInDescriptorsFromTableStart = 6;

            // _loadedTexture_183
            ranges[7].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[7].NumDescriptors = 1;
            ranges[7].BaseShaderRegister = 6;
            ranges[7].RegisterSpace = 0;
            ranges[7].OffsetInDescriptorsFromTableStart = 7;

            // _loadedTexture_171
            ranges[8].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[8].NumDescriptors = 1;
            ranges[8].BaseShaderRegister = 7;
            ranges[8].RegisterSpace = 0;
            ranges[8].OffsetInDescriptorsFromTableStart = 8;

            // _loadedTexture_184
            ranges[9].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[9].NumDescriptors = 1;
            ranges[9].BaseShaderRegister = 8;
            ranges[9].RegisterSpace = 0;
            ranges[9].OffsetInDescriptorsFromTableStart = 9;

            // _loadedTexture_185
            ranges[10].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[10].NumDescriptors = 1;
            ranges[10].BaseShaderRegister = 9;
            ranges[10].RegisterSpace = 0;
            ranges[10].OffsetInDescriptorsFromTableStart = 10;

            // _loadedTexture_186
            ranges[11].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[11].NumDescriptors = 1;
            ranges[11].BaseShaderRegister = 10;
            ranges[11].RegisterSpace = 0;
            ranges[11].OffsetInDescriptorsFromTableStart = 11;

            // _loadedTexture_187
            ranges[12].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[12].NumDescriptors = 1;
            ranges[12].BaseShaderRegister = 11;
            ranges[12].RegisterSpace = 0;
            ranges[12].OffsetInDescriptorsFromTableStart = 12;

            // _loadedTexture_188
            ranges[13].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[13].NumDescriptors = 1;
            ranges[13].BaseShaderRegister = 12;
            ranges[13].RegisterSpace = 0;
            ranges[13].OffsetInDescriptorsFromTableStart = 13;

            // _loadedTexture_189
            ranges[14].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[14].NumDescriptors = 1;
            ranges[14].BaseShaderRegister = 13;
            ranges[14].RegisterSpace = 0;
            ranges[14].OffsetInDescriptorsFromTableStart = 14;

            // _loadedTexture_190
            ranges[15].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[15].NumDescriptors = 1;
            ranges[15].BaseShaderRegister = 14;
            ranges[15].RegisterSpace = 0;
            ranges[15].OffsetInDescriptorsFromTableStart = 15;

            // _loadedTexture_191
            ranges[16].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[16].NumDescriptors = 1;
            ranges[16].BaseShaderRegister = 15;
            ranges[16].RegisterSpace = 0;
            ranges[16].OffsetInDescriptorsFromTableStart = 16;

            // _loadedTexture_192
            ranges[17].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[17].NumDescriptors = 1;
            ranges[17].BaseShaderRegister = 16;
            ranges[17].RegisterSpace = 0;
            ranges[17].OffsetInDescriptorsFromTableStart = 17;

            // _loadedTexture_193
            ranges[18].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[18].NumDescriptors = 1;
            ranges[18].BaseShaderRegister = 17;
            ranges[18].RegisterSpace = 0;
            ranges[18].OffsetInDescriptorsFromTableStart = 18;

            // _loadedTexture_194
            ranges[19].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[19].NumDescriptors = 1;
            ranges[19].BaseShaderRegister = 18;
            ranges[19].RegisterSpace = 0;
            ranges[19].OffsetInDescriptorsFromTableStart = 19;

            // _loadedTexture_195
            ranges[20].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[20].NumDescriptors = 1;
            ranges[20].BaseShaderRegister = 19;
            ranges[20].RegisterSpace = 0;
            ranges[20].OffsetInDescriptorsFromTableStart = 20;

            // _GatherDOF_FloodFillFarCS_1CB
            ranges[21].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
            ranges[21].NumDescriptors = 1;
            ranges[21].BaseShaderRegister = 0;
            ranges[21].RegisterSpace = 0;
            ranges[21].OffsetInDescriptorsFromTableStart = 21;

            if(!DX12Utils::MakeRootSig(device, ranges, 22, samplers, 1, &ContextInternal::computeShader_GatherDOF_FloodFillNear_rootSig, (c_debugNames ? L"GatherDOF_FloodFillNear" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "dof_GatherDOF/FloodFillFarCS_1.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "GatherDOF_FloodFillNear" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("COC_TILEMAP","1");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_GatherDOF_FloodFillNear_rootSig, &ContextInternal::computeShader_GatherDOF_FloodFillNear_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: GatherDOF_Recombine
        {
            D3D12_STATIC_SAMPLER_DESC samplers[1];

            // linearClampSampler
            samplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
            samplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
            samplers[0].MipLODBias  = 0;
            samplers[0].MaxAnisotropy  = 0;
            samplers[0].ComparisonFunc  = D3D12_COMPARISON_FUNC_NEVER;
            samplers[0].BorderColor  = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
            samplers[0].MinLOD = 0.0f;
            samplers[0].MaxLOD = D3D12_FLOAT32_MAX;
            samplers[0].ShaderRegister = 0;
            samplers[0].RegisterSpace = 0;
            samplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

            D3D12_DESCRIPTOR_RANGE ranges[6];

            // NearField
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // Color
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 1;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            // Depth
            ranges[2].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[2].NumDescriptors = 1;
            ranges[2].BaseShaderRegister = 2;
            ranges[2].RegisterSpace = 0;
            ranges[2].OffsetInDescriptorsFromTableStart = 2;

            // FarField
            ranges[3].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[3].NumDescriptors = 1;
            ranges[3].BaseShaderRegister = 3;
            ranges[3].RegisterSpace = 0;
            ranges[3].OffsetInDescriptorsFromTableStart = 3;

            // Output
            ranges[4].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[4].NumDescriptors = 1;
            ranges[4].BaseShaderRegister = 0;
            ranges[4].RegisterSpace = 0;
            ranges[4].OffsetInDescriptorsFromTableStart = 4;

            // _GatherDOF_RecombineCSCB
            ranges[5].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
            ranges[5].NumDescriptors = 1;
            ranges[5].BaseShaderRegister = 0;
            ranges[5].RegisterSpace = 0;
            ranges[5].OffsetInDescriptorsFromTableStart = 5;

            if(!DX12Utils::MakeRootSig(device, ranges, 6, samplers, 1, &ContextInternal::computeShader_GatherDOF_Recombine_rootSig, (c_debugNames ? L"GatherDOF_Recombine" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "dof_GatherDOF/RecombineCS.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "GatherDOF_Recombine" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_GatherDOF_Recombine_rootSig, &ContextInternal::computeShader_GatherDOF_Recombine_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: GaussBlur_DoBlur
        {
            D3D12_STATIC_SAMPLER_DESC* samplers = nullptr;

            D3D12_DESCRIPTOR_RANGE ranges[3];

            // Input
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // Output
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 0;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            // _GaussBlur_GaussBlurCSCB
            ranges[2].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
            ranges[2].NumDescriptors = 1;
            ranges[2].BaseShaderRegister = 0;
            ranges[2].RegisterSpace = 0;
            ranges[2].OffsetInDescriptorsFromTableStart = 2;

            if(!DX12Utils::MakeRootSig(device, ranges, 3, samplers, 0, &ContextInternal::computeShader_GaussBlur_DoBlur_rootSig, (c_debugNames ? L"GaussBlur_DoBlur" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "GaussBlur_GaussBlur/GaussBlurCS.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "GaussBlur_DoBlur" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_GaussBlur_DoBlur_rootSig, &ContextInternal::computeShader_GaussBlur_DoBlur_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: TemporalAccumulation_DoAccum
        {
            D3D12_STATIC_SAMPLER_DESC* samplers = nullptr;

            D3D12_DESCRIPTOR_RANGE ranges[3];

            // Input
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // Accum
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 0;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            // _TemporalAccumulation_AccumulateCB
            ranges[2].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
            ranges[2].NumDescriptors = 1;
            ranges[2].BaseShaderRegister = 0;
            ranges[2].RegisterSpace = 0;
            ranges[2].OffsetInDescriptorsFromTableStart = 2;

            if(!DX12Utils::MakeRootSig(device, ranges, 3, samplers, 0, &ContextInternal::computeShader_TemporalAccumulation_DoAccum_rootSig, (c_debugNames ? L"TemporalAccumulation_DoAccum" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "TemporalAccumulation_TemporalAccumulation/Accumulate.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "TemporalAccumulation_DoAccum" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_TemporalAccumulation_DoAccum_rootSig, &ContextInternal::computeShader_TemporalAccumulation_DoAccum_pso, Context::LogFn))
                return false;
        }

        // Compute Shader: ToneMap_Tonemap
        {
            D3D12_STATIC_SAMPLER_DESC* samplers = nullptr;

            D3D12_DESCRIPTOR_RANGE ranges[3];

            // HDR
            ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
            ranges[0].NumDescriptors = 1;
            ranges[0].BaseShaderRegister = 0;
            ranges[0].RegisterSpace = 0;
            ranges[0].OffsetInDescriptorsFromTableStart = 0;

            // SDR
            ranges[1].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
            ranges[1].NumDescriptors = 1;
            ranges[1].BaseShaderRegister = 0;
            ranges[1].RegisterSpace = 0;
            ranges[1].OffsetInDescriptorsFromTableStart = 1;

            // _ToneMap_TonemapCB
            ranges[2].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
            ranges[2].NumDescriptors = 1;
            ranges[2].BaseShaderRegister = 0;
            ranges[2].RegisterSpace = 0;
            ranges[2].OffsetInDescriptorsFromTableStart = 2;

            if(!DX12Utils::MakeRootSig(device, ranges, 3, samplers, 0, &ContextInternal::computeShader_ToneMap_Tonemap_rootSig, (c_debugNames ? L"ToneMap_Tonemap" : nullptr), Context::LogFn))
                return false;

            ShaderCompilationInfo shaderCompilationInfo;
            shaderCompilationInfo.fileName = std::filesystem::path(Context::s_techniqueLocation) / "shaders" / "Tonemap_ToneMap/Tonemap.hlsl";
            shaderCompilationInfo.entryPoint = "csmain";
            shaderCompilationInfo.shaderModel = "cs_6_1";
            shaderCompilationInfo.debugName = (c_debugNames ? "ToneMap_Tonemap" : "");
            if (c_debugShaders) shaderCompilationInfo.flags |= ShaderCompilationFlags::Debug;
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchMultiply","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchDivide","uint3(1,1,1)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPreAdd","uint3(0,0,0)");
            shaderCompilationInfo.defines.emplace_back("__GigiDispatchPostAdd","uint3(0,0,0)");

            if(!DX12Utils::MakeComputePSO_DXC(device, shaderCompilationInfo,
               ContextInternal::computeShader_ToneMap_Tonemap_rootSig, &ContextInternal::computeShader_ToneMap_Tonemap_pso, Context::LogFn))
                return false;
        }

        dxrDevice->Release();

        // Create heaps
        if (c_numSRVDescriptors > 0 && !CreateHeap(s_srvHeap, device, c_numSRVDescriptors, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE, Context::LogFn))
            return false;

        if (c_numRTVDescriptors > 0 && !CreateHeap(s_rtvHeap, device, c_numRTVDescriptors, D3D12_DESCRIPTOR_HEAP_TYPE_RTV, D3D12_DESCRIPTOR_HEAP_FLAG_NONE, Context::LogFn))
            return false;

        if (c_numDSVDescriptors > 0 && !CreateHeap(s_dsvHeap, device, c_numDSVDescriptors, D3D12_DESCRIPTOR_HEAP_TYPE_DSV, D3D12_DESCRIPTOR_HEAP_FLAG_NONE, Context::LogFn))
            return false;

        s_heapAllocationTrackerRTV.Init(s_rtvHeap.m_heap, c_numRTVDescriptors, (int)device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV));
        s_heapAllocationTrackerDSV.Init(s_dsvHeap.m_heap, c_numDSVDescriptors, (int)device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_DSV));

        // create indirect dispatch command
        {
            D3D12_INDIRECT_ARGUMENT_DESC dispatchArg = {};
            dispatchArg.Type						 = D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH;

            D3D12_COMMAND_SIGNATURE_DESC dispatchDesc = {};
            dispatchDesc.ByteStride					  = sizeof(uint32_t) * 3;
            dispatchDesc.NumArgumentDescs			  = 1;
            dispatchDesc.pArgumentDescs				  = &dispatchArg;
            dispatchDesc.NodeMask					  = 0x0;

            device->CreateCommandSignature(
                &dispatchDesc,
                nullptr,
                IID_PPV_ARGS(&ContextInternal::s_commandSignatureDispatch));
        }

        return true;
    }

    void DestroyShared()
    {

        if(ContextInternal::rayShader_Raytrace_rtso)
        {
            s_delayedRelease.Add(ContextInternal::rayShader_Raytrace_rtso);
            ContextInternal::rayShader_Raytrace_rtso = nullptr;
        }

        if(ContextInternal::rayShader_Raytrace_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::rayShader_Raytrace_rootSig);
            ContextInternal::rayShader_Raytrace_rootSig = nullptr;
        }

        if(ContextInternal::rayShader_Raytrace_shaderTableRayGen)
        {
            s_delayedRelease.Add(ContextInternal::rayShader_Raytrace_shaderTableRayGen);
            ContextInternal::rayShader_Raytrace_shaderTableRayGen = nullptr;
        }

        if(ContextInternal::rayShader_Raytrace_shaderTableMiss)
        {
            s_delayedRelease.Add(ContextInternal::rayShader_Raytrace_shaderTableMiss);
            ContextInternal::rayShader_Raytrace_shaderTableMiss = nullptr;
        }

        if(ContextInternal::rayShader_Raytrace_shaderTableHitGroup)
        {
            s_delayedRelease.Add(ContextInternal::rayShader_Raytrace_shaderTableHitGroup);
            ContextInternal::rayShader_Raytrace_shaderTableHitGroup = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_Setup_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_Setup_pso);
            ContextInternal::computeShader_GatherDOF_Setup_pso = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_Setup_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_Setup_rootSig);
            ContextInternal::computeShader_GatherDOF_Setup_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_NearBorder_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_NearBorder_pso);
            ContextInternal::computeShader_GatherDOF_NearBorder_pso = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_NearBorder_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_NearBorder_rootSig);
            ContextInternal::computeShader_GatherDOF_NearBorder_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_BlurFar_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_BlurFar_pso);
            ContextInternal::computeShader_GatherDOF_BlurFar_pso = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_BlurFar_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_BlurFar_rootSig);
            ContextInternal::computeShader_GatherDOF_BlurFar_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_FloodFillFar_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_FloodFillFar_pso);
            ContextInternal::computeShader_GatherDOF_FloodFillFar_pso = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_FloodFillFar_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_FloodFillFar_rootSig);
            ContextInternal::computeShader_GatherDOF_FloodFillFar_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_pso);
            ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_pso = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_rootSig);
            ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_pso);
            ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_pso = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_rootSig);
            ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_NearHalo_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_NearHalo_pso);
            ContextInternal::computeShader_GatherDOF_NearHalo_pso = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_NearHalo_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_NearHalo_rootSig);
            ContextInternal::computeShader_GatherDOF_NearHalo_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_NearBlur_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_NearBlur_pso);
            ContextInternal::computeShader_GatherDOF_NearBlur_pso = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_NearBlur_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_NearBlur_rootSig);
            ContextInternal::computeShader_GatherDOF_NearBlur_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_FloodFillNear_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_FloodFillNear_pso);
            ContextInternal::computeShader_GatherDOF_FloodFillNear_pso = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_FloodFillNear_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_FloodFillNear_rootSig);
            ContextInternal::computeShader_GatherDOF_FloodFillNear_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_Recombine_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_Recombine_pso);
            ContextInternal::computeShader_GatherDOF_Recombine_pso = nullptr;
        }

        if(ContextInternal::computeShader_GatherDOF_Recombine_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GatherDOF_Recombine_rootSig);
            ContextInternal::computeShader_GatherDOF_Recombine_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_GaussBlur_DoBlur_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GaussBlur_DoBlur_pso);
            ContextInternal::computeShader_GaussBlur_DoBlur_pso = nullptr;
        }

        if(ContextInternal::computeShader_GaussBlur_DoBlur_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_GaussBlur_DoBlur_rootSig);
            ContextInternal::computeShader_GaussBlur_DoBlur_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_TemporalAccumulation_DoAccum_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_TemporalAccumulation_DoAccum_pso);
            ContextInternal::computeShader_TemporalAccumulation_DoAccum_pso = nullptr;
        }

        if(ContextInternal::computeShader_TemporalAccumulation_DoAccum_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_TemporalAccumulation_DoAccum_rootSig);
            ContextInternal::computeShader_TemporalAccumulation_DoAccum_rootSig = nullptr;
        }

        if(ContextInternal::computeShader_ToneMap_Tonemap_pso)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_ToneMap_Tonemap_pso);
            ContextInternal::computeShader_ToneMap_Tonemap_pso = nullptr;
        }

        if(ContextInternal::computeShader_ToneMap_Tonemap_rootSig)
        {
            s_delayedRelease.Add(ContextInternal::computeShader_ToneMap_Tonemap_rootSig);
            ContextInternal::computeShader_ToneMap_Tonemap_rootSig = nullptr;
        }

        // Clear out heap trackers
        s_heapAllocationTrackerRTV.Release();
        s_heapAllocationTrackerDSV.Release();

        // Destroy Heaps
        DestroyHeap(s_srvHeap);
        DestroyHeap(s_rtvHeap);
        DestroyHeap(s_dsvHeap);

        // Destroy any upload buffers
        s_ubTracker.Release();

        // Finish any delayed release
        s_delayedRelease.Release();

        // Destroy indirect dispatch command
        if (ContextInternal::s_commandSignatureDispatch)
        {
            ContextInternal::s_commandSignatureDispatch->Release();
            ContextInternal::s_commandSignatureDispatch = nullptr;
        }
    }

    Context* CreateContext(ID3D12Device* device)
    {
        if (s_allContexts.size() == 0)
        {
            if (!CreateShared(device))
                return nullptr;
        }

        Context* ret = new Context;
        s_allContexts.push_back(ret);
        return ret;
    }

    void DestroyContext(Context* context)
    {
        s_allContexts.erase(std::remove(s_allContexts.begin(), s_allContexts.end(), context), s_allContexts.end());
        delete context;
        if (s_allContexts.size() == 0)
            DestroyShared();
    }

    ID3D12Resource* Context::GetPrimaryOutputTexture()
    {
        return nullptr;
    }

    D3D12_RESOURCE_STATES Context::GetPrimaryOutputTextureState()
    {
        return D3D12_RESOURCE_STATE_COMMON;
    }

    void OnNewFrame(int framesInFlight)
    {
        s_delayedRelease.OnNewFrame(framesInFlight);
        s_ubTracker.OnNewFrame(framesInFlight);
        s_heapAllocationTrackerRTV.OnNewFrame(framesInFlight);
        s_heapAllocationTrackerDSV.OnNewFrame(framesInFlight);
    }

    int Context::GetContextCount()
    {
        return (int)s_allContexts.size();
    }

    Context* Context::GetContext(int index)
    {
        if (index >= 0 && index < GetContextCount())
            return s_allContexts[index];
        else
            return nullptr;
    }

    ID3D12Resource* Context::CreateManagedBuffer(ID3D12Device* device, ID3D12GraphicsCommandList* commandList, D3D12_RESOURCE_FLAGS flags, const void* data, size_t size, const wchar_t* debugName, D3D12_RESOURCE_STATES desiredState)
    {
        // Make a buffer and have the context manage it
        ID3D12Resource* ret = DX12Utils::CreateBuffer(
            device,
            (unsigned int)size,
            flags,
            D3D12_RESOURCE_STATE_COPY_DEST,
            D3D12_HEAP_TYPE_DEFAULT,
            debugName,
            Context::LogFn
        );
        AddManagedResource(ret);

        // Copy the data to the buffer if we should
        if (data != nullptr && size > 0)
            UploadBufferData(device, commandList, ret, D3D12_RESOURCE_STATE_COPY_DEST, data, (unsigned int)size);

        // Do a resource transition if we should
        if (desiredState != D3D12_RESOURCE_STATE_COPY_DEST)
        {
            D3D12_RESOURCE_BARRIER barrier;

            barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barrier.Transition.pResource = ret;
            barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
            barrier.Transition.StateAfter = desiredState;
            barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(1, &barrier);
        }

        // return the resource
        return ret;
    }

    ID3D12Resource* Context::CreateManagedTexture(ID3D12Device* device, ID3D12GraphicsCommandList* commandList, D3D12_RESOURCE_FLAGS flags, DXGI_FORMAT format, const unsigned int size[3], unsigned int numMips, DX12Utils::ResourceType resourceType, const void* initialData, const wchar_t* debugName, D3D12_RESOURCE_STATES desiredState)
    {
        // Create a texture
        ID3D12Resource* ret = DX12Utils::CreateTexture(device, size, numMips, format, flags, D3D12_RESOURCE_STATE_COPY_DEST, resourceType, debugName, Context::LogFn);
        AddManagedResource(ret);

        // copy initial data in, if we should
        if (initialData != nullptr)
        {
            DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(format, Context::LogFn);
            UploadTextureData(device, commandList, ret, D3D12_RESOURCE_STATE_COPY_DEST, initialData, size[0] * formatInfo.bytesPerPixel);
        }

        // Put the resource into the desired state
        if (desiredState != D3D12_RESOURCE_STATE_COPY_DEST)
        {
            D3D12_RESOURCE_BARRIER barrier;

            barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barrier.Transition.pResource = ret;
            barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
            barrier.Transition.StateAfter = desiredState;
            barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(1, &barrier);
        }

        return ret;
    }

    ID3D12Resource* Context::CreateManagedTextureAndClear(ID3D12Device* device, ID3D12GraphicsCommandList* commandList, D3D12_RESOURCE_FLAGS flags, DXGI_FORMAT format, const unsigned int size[3], unsigned int numMips, DX12Utils::ResourceType resourceType, void* clearValue, size_t clearValueSize, const wchar_t* debugName, D3D12_RESOURCE_STATES desiredState)
    {
        // Make sure the clear value is the correct size
        DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(format, Context::LogFn);
        if (clearValue != nullptr && clearValueSize > 0 && clearValueSize != formatInfo.bytesPerPixel)
            return nullptr;

        // Copy data into the resource
        std::vector<unsigned char> expandedClearValue;
        void* initialData = nullptr;
        if (clearValue != nullptr && clearValueSize > 0)
        {
            expandedClearValue.resize(size[0] * size[1] * size[2] * formatInfo.bytesPerPixel);
            unsigned char* dest = expandedClearValue.data();
            for (size_t i = 0; i < size[0] * size[1] * size[2]; ++i)
            {
                memcpy(dest, clearValue, formatInfo.bytesPerPixel);
                dest += formatInfo.bytesPerPixel;
            }
            initialData = expandedClearValue.data();
        }

        // make and return the texture
        return CreateManagedTexture(device, commandList, flags, format, size, numMips, resourceType, initialData, debugName, desiredState);
    }

    ID3D12Resource* Context::CreateManagedTextureFromFile(ID3D12Device* device, ID3D12GraphicsCommandList* commandList, D3D12_RESOURCE_FLAGS flags, DXGI_FORMAT format, DX12Utils::ResourceType resourceType, const char* fileName, bool sourceIsSRGB, unsigned int size[3], const wchar_t* debugName, D3D12_RESOURCE_STATES desiredState)
    {
        // Get the desired channel type
        DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(format, Context::LogFn);
        DX12Utils::TextureCache::Type desiredChannelType = DX12Utils::TextureCache::Type::U8;
        if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
            desiredChannelType = DX12Utils::TextureCache::Type::U8;
        else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
            desiredChannelType = DX12Utils::TextureCache::Type::F32;
        else
            return nullptr;

        if (resourceType == DX12Utils::ResourceType::Texture2D)
        {
            // Load the texture and convert as necessary
            DX12Utils::TextureCache::Texture texture = DX12Utils::TextureCache::GetAs(fileName, sourceIsSRGB, desiredChannelType, formatInfo.sRGB, formatInfo.channelCount);
            if (!texture.Valid())
                return nullptr;

            // store off image properties
            size[0] = texture.width;
            size[1] = texture.height;
            size[2] = 1;

            // make and return the texture
            return CreateManagedTexture(device, commandList, flags, format, size, 1, resourceType, texture.pixels.data(), debugName, desiredState);
        }
        else if (resourceType == DX12Utils::ResourceType::Texture2DArray ||
                 resourceType == DX12Utils::ResourceType::Texture3D ||
                 resourceType == DX12Utils::ResourceType::TextureCube)
        {
            static const char* c_cubeMapNames[] =
            {
                "Right",
                "Left",
                "Up",
                "Down",
                "Front",
                "Back"
            };

            bool useCubeMapNames = (resourceType == DX12Utils::ResourceType::TextureCube && strstr(fileName, "%s") != nullptr);
            bool hasPercentI = strstr(fileName, "%i") != nullptr;
            if (!useCubeMapNames && !hasPercentI)
                return nullptr;

            std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;

            // Load multiple textures
            int textureIndex = -1;
            while (1)
            {
                textureIndex++;
                char indexedFileName[1024];

                if (useCubeMapNames)
                    sprintf_s(indexedFileName, fileName, c_cubeMapNames[textureIndex]);
                else
                    sprintf_s(indexedFileName, fileName, textureIndex);

                // Load the texture and convert as necessary
                DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, sourceIsSRGB, desiredChannelType, formatInfo.sRGB, formatInfo.channelCount);
                if (!loadedTextureSlice.Valid())
                {
                    if (textureIndex == 0)
                        return nullptr;
                    break;
                }

                // make sure the textures are the same size
                if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                    return nullptr;

                loadedTextureSlices.push_back(loadedTextureSlice);
            }

            // store the texture size
            size[0] = loadedTextureSlices[0].width;
            size[1] = loadedTextureSlices[0].height;
            size[2] = (unsigned int)loadedTextureSlices.size();

            // gather up all pixels into a contiguous chunk of memory
            std::vector<unsigned char> allPixels;
            for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                allPixels.insert(allPixels.end(), texture.pixels.begin(), texture.pixels.end());

            // make and return the texture
            return CreateManagedTexture(device, commandList, flags, format, size, 1, resourceType, allPixels.data(), debugName, desiredState);
        }
        else
            return nullptr;
    }

    void Context::UploadTextureData(ID3D12Device* device, ID3D12GraphicsCommandList* commandList, ID3D12Resource* texture, D3D12_RESOURCE_STATES textureState, const void* data, unsigned int unalignedPitch)
    {
        // Get information about the texture
        int alignedPitch = ALIGN(D3D12_TEXTURE_DATA_PITCH_ALIGNMENT, unalignedPitch);
        D3D12_RESOURCE_DESC textureDesc = texture->GetDesc();

        // transition the resource to copy dest if it isn't already
        if (textureState != D3D12_RESOURCE_STATE_COPY_DEST)
        {
            D3D12_RESOURCE_BARRIER barrier;

            barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barrier.Transition.pResource = texture;
            barrier.Transition.StateBefore = textureState;
            barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_COPY_DEST;
            barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(1, &barrier);
        }

        // 3d textures do a single copy because it's a single sub resource.
        if (textureDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE3D)
        {
            // Get the upload buffer
            DX12Utils::UploadBufferTracker::UploadBufferTracker::Buffer* uploadBuffer = s_ubTracker.GetBuffer(device, alignedPitch * textureDesc.Height * textureDesc.DepthOrArraySize, Context::LogFn, false);

            // Map, copy, unmap
            {
                unsigned char* dest = nullptr;
                D3D12_RANGE readRange = { 0, 0 };
                HRESULT hr = uploadBuffer->buffer->Map(0, &readRange, (void**)&dest);
                if (FAILED(hr))
                {
                    Context::LogFn(LogLevel::Error, "Could not map upload buffer.");
                }
                else
                {
                    const unsigned char* src = (const unsigned char*)data;
                    for (int iz = 0; iz < textureDesc.DepthOrArraySize; ++iz)
                    {
                        for (int iy = 0; iy < (int)textureDesc.Height; ++iy)
                        {
                            memcpy(dest, src, unalignedPitch);
                            src += unalignedPitch;
                            dest += alignedPitch;
                        }
                    }

                    uploadBuffer->buffer->Unmap(0, nullptr);
                }
            }

            // copy the upload buffer into the texture
            {
                unsigned char layoutMem[sizeof(D3D12_PLACED_SUBRESOURCE_FOOTPRINT) + sizeof(UINT) + sizeof(UINT64)];
                D3D12_PLACED_SUBRESOURCE_FOOTPRINT* layout = (D3D12_PLACED_SUBRESOURCE_FOOTPRINT*)layoutMem;
                device->GetCopyableFootprints(&textureDesc, 0, 1, 0, layout, nullptr, nullptr, nullptr);

                D3D12_TEXTURE_COPY_LOCATION src = {};
                src.pResource = uploadBuffer->buffer;
                src.Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;
                src.PlacedFootprint = *layout;

                D3D12_TEXTURE_COPY_LOCATION dest = {};
                dest.pResource = texture;
                dest.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
                dest.SubresourceIndex = 0;

                commandList->CopyTextureRegion(&dest, 0, 0, 0, &src, nullptr);
            }
        }
        // 2d array textures do a copy for each slice
        else if (textureDesc.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE2D)
        {
            for (int iz = 0; iz < textureDesc.DepthOrArraySize; ++iz)
            {
                // Get the upload buffer
                DX12Utils::UploadBufferTracker::Buffer* uploadBuffer = s_ubTracker.GetBuffer(device, alignedPitch * textureDesc.Height, Context::LogFn, false);

                // Map, copy, unmap
                {
                    unsigned char* dest = nullptr;
                    D3D12_RANGE readRange = { 0, 0 };
                    HRESULT hr = uploadBuffer->buffer->Map(0, &readRange, (void**)&dest);
                    if (FAILED(hr))
                    {
                        Context::LogFn(LogLevel::Error, "Could not map upload buffer.");
                    }
                    else
                    {
                        const unsigned char* src = &((const unsigned char*)data)[unalignedPitch * textureDesc.Height * iz];
                        for (int iy = 0; iy < (int)textureDesc.Height; ++iy)
                        {
                            memcpy(dest, src, unalignedPitch);
                            src += unalignedPitch;
                            dest += alignedPitch;
                        }

                        uploadBuffer->buffer->Unmap(0, nullptr);
                    }
                }

                 // copy the upload buffer into the texture
                 {
                     unsigned char layoutMem[sizeof(D3D12_PLACED_SUBRESOURCE_FOOTPRINT) + sizeof(UINT) + sizeof(UINT64)];
                     D3D12_PLACED_SUBRESOURCE_FOOTPRINT* layout = (D3D12_PLACED_SUBRESOURCE_FOOTPRINT*)layoutMem;
                     device->GetCopyableFootprints(&textureDesc, 0, 1, 0, layout, nullptr, nullptr, nullptr);

                     D3D12_TEXTURE_COPY_LOCATION src = {};
                     src.pResource = uploadBuffer->buffer;
                     src.Type = D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT;
                     src.PlacedFootprint = *layout;

                     D3D12_TEXTURE_COPY_LOCATION dest = {};
                     dest.pResource = texture;
                     dest.Type = D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX;
                     dest.SubresourceIndex = iz;

                     commandList->CopyTextureRegion(&dest, 0, 0, 0, &src, nullptr);
                 }
            }
        }
        else
        {
            Context::LogFn(LogLevel::Error, "Unhandled texture dimension.");
        }

        // transition the resource back to what it was
        if (textureState != D3D12_RESOURCE_STATE_COPY_DEST)
        {
            D3D12_RESOURCE_BARRIER barrier;

            barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barrier.Transition.pResource = texture;
            barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
            barrier.Transition.StateAfter = textureState;
            barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(1, &barrier);
        }
    }

    void Context::UploadBufferData(ID3D12Device* device, ID3D12GraphicsCommandList* commandList, ID3D12Resource* buffer, D3D12_RESOURCE_STATES bufferState, const void* data, unsigned int dataSize)
    {
        // Get the upload buffer
        DX12Utils::UploadBufferTracker::UploadBufferTracker::Buffer* uploadBuffer = s_ubTracker.GetBuffer(device, dataSize, Context::LogFn, false);

        // copy cpu data to the upload buffer
        {
            void* start = nullptr;
            HRESULT hr = uploadBuffer->buffer->Map(0, nullptr, reinterpret_cast<void**>(&start));
            if(hr)
            {
                Context::LogFn(LogLevel::Error, "Could not map upload buffer");
                return;
            }

            memcpy(start, data, dataSize);

            uploadBuffer->buffer->Unmap(0, nullptr);
        }

        // transition the resource to copy dest if it isn't already
        if (bufferState != D3D12_RESOURCE_STATE_COPY_DEST)
        {
            D3D12_RESOURCE_BARRIER barrier;

            barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barrier.Transition.pResource = buffer;
            barrier.Transition.StateBefore = bufferState;
            barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_COPY_DEST;
            barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(1, &barrier);
        }

        // copy the resource
        commandList->CopyResource(buffer, uploadBuffer->buffer);

        // transition the resource back to what it was
        if (bufferState != D3D12_RESOURCE_STATE_COPY_DEST)
        {
            D3D12_RESOURCE_BARRIER barrier;

            barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barrier.Transition.pResource = buffer;
            barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
            barrier.Transition.StateAfter = bufferState;
            barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(1, &barrier);
        }
    }

    int Context::GetRTV(ID3D12Device* device, ID3D12Resource* resource, DXGI_FORMAT format, D3D12_RTV_DIMENSION dimension, int arrayIndex, int mipIndex, const char* debugName)
    {
        // Make the key
        DX12Utils::SubResourceHeapAllocationInfo key;
        key.resource = resource;
        key.arrayIndex = arrayIndex;
        key.mipIndex = mipIndex;

        // If it already exists, use it
        auto it = m_internal.m_RTVCache.find(key);
        if (it != m_internal.m_RTVCache.end())
            return it->second;

        // Allocate an RTV index
        int rtvIndex = -1;
        if (!s_heapAllocationTrackerRTV.Allocate(rtvIndex, debugName))
            return -1;

        // Create the RTV
        if (!DX12Utils::CreateRTV(device, resource, s_heapAllocationTrackerRTV.GetCPUHandle(rtvIndex), format, dimension, arrayIndex, mipIndex))
        {
            s_heapAllocationTrackerRTV.Free(rtvIndex);
            return -1;
        }

        // store the result
        m_internal.m_RTVCache[key] = rtvIndex;
        return rtvIndex;
    }

    int Context::GetDSV(ID3D12Device* device, ID3D12Resource* resource, DXGI_FORMAT format, D3D12_DSV_DIMENSION dimension, int arrayIndex, int mipIndex, const char* debugName)
    {
	    // Make the key
        DX12Utils::SubResourceHeapAllocationInfo key;
        key.resource = resource;
        key.arrayIndex = arrayIndex;
        key.mipIndex = mipIndex;

	    // If it already exists, use it
	    auto it = m_internal.m_DSVCache.find(key);
	    if (it != m_internal.m_DSVCache.end())
            return it->second;

        // Allocate a DSV index
        int dsvIndex = -1;
        if (!s_heapAllocationTrackerDSV.Allocate(dsvIndex, debugName))
            return -1;

        // Create the DSV
        if (!DX12Utils::CreateDSV(device, resource, s_heapAllocationTrackerDSV.GetCPUHandle(dsvIndex), format, dimension, arrayIndex, mipIndex))
        {
            s_heapAllocationTrackerDSV.Free(dsvIndex);
            return -1;
        }

        // store the result
        m_internal.m_DSVCache[key] = dsvIndex;
        return dsvIndex;
    }

    const ProfileEntry* Context::ReadbackProfileData(ID3D12CommandQueue* commandQueue, int& numItems)
    {
        numItems = 0;

        if (!m_profile || !m_internal.m_TimestampReadbackBuffer)
            return nullptr;

        uint64_t GPUFrequency;
        commandQueue->GetTimestampFrequency(&GPUFrequency);
        double GPUTickDelta = 1.0 / static_cast<double>(GPUFrequency);

        D3D12_RANGE range;
        range.Begin = 0;
        range.End = ((16 + 1) * 2) * sizeof(uint64_t);

        uint64_t* timeStampBuffer = nullptr;
        m_internal.m_TimestampReadbackBuffer->Map(0, &range, (void**)&timeStampBuffer);

        m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // ray shader: Raytrace
        m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: GatherDOF_Setup
        if(m_input.variable_GatherDOF_DoNearField)
        {
            m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: GatherDOF_NearBorder
        }
        if(m_input.variable_GatherDOF_DoFarField)
        {
            m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: GatherDOF_BlurFar
        }
        if(m_input.variable_GatherDOF_DoFarField)
        {
            m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: GatherDOF_FloodFillFar
        }
        if(m_input.variable_GatherDOF_DoNearField)
        {
            m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: GatherDOF_DownscaleTileMap_1_4
        }
        if(m_input.variable_GatherDOF_DoNearField)
        {
            m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: GatherDOF_DownscaleTileMap_1_8
        }
        if(m_input.variable_GatherDOF_DoNearField)
        {
            m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: GatherDOF_NearHalo
        }
        if(m_input.variable_GatherDOF_DoNearField)
        {
            m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: GatherDOF_NearBlur
        }
        if(m_input.variable_GatherDOF_DoNearField)
        {
            m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: GatherDOF_FloodFillNear
        }
        m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: GatherDOF_Recombine
        if(m_input.variable_DOF != DOFMode::PostProcessing)
        {
            m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // copy resource: CopyHDR
        }
        if(!m_input.variable_GaussBlur_Disable)
        {
            m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: GaussBlur_DoBlur
        }
        if(m_input.variable_GaussBlur_Disable)
        {
            m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // copy resource: GaussBlur_DontBlur
        }
        m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: TemporalAccumulation_DoAccum
        m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+2] - timeStampBuffer[numItems*2+1])); numItems++; // compute shader: ToneMap_Tonemap
        m_profileData[numItems].m_gpu = float(GPUTickDelta * double(timeStampBuffer[numItems*2+1] - timeStampBuffer[0])); numItems++; // GPU total

        D3D12_RANGE emptyRange = {};
        m_internal.m_TimestampReadbackBuffer->Unmap(0, &emptyRange);

        return m_profileData;
    }

    Context::~Context()
    {
        for (const auto& pair : m_internal.m_RTVCache)
            s_heapAllocationTrackerRTV.Free(pair.second);
        m_internal.m_RTVCache.clear();

        for (const auto& pair : m_internal.m_DSVCache)
            s_heapAllocationTrackerDSV.Free(pair.second);
        m_internal.m_DSVCache.clear();

        for (ID3D12Resource* resource : m_internal.m_managedResources)
            resource->Release();
        m_internal.m_managedResources.clear();

        if(m_internal.m_TimestampQueryHeap)
        {
            m_internal.m_TimestampQueryHeap->Release();
            m_internal.m_TimestampQueryHeap = nullptr;
        }

        if(m_internal.m_TimestampReadbackBuffer)
        {
            m_internal.m_TimestampReadbackBuffer->Release();
            m_internal.m_TimestampReadbackBuffer = nullptr;
        }

        if(m_internal.texture_ColorHDR)
        {
            s_delayedRelease.Add(m_internal.texture_ColorHDR);
            m_internal.texture_ColorHDR = nullptr;
        }

        if(m_internal.buffer_PixelDebug)
        {
            s_delayedRelease.Add(m_internal.buffer_PixelDebug);
            m_internal.buffer_PixelDebug = nullptr;
        }

        if(m_internal.texture_LinearDepth)
        {
            s_delayedRelease.Add(m_internal.texture_LinearDepth);
            m_internal.texture_LinearDepth = nullptr;
        }

        if(m_internal.texture_DebugTex)
        {
            s_delayedRelease.Add(m_internal.texture_DebugTex);
            m_internal.texture_DebugTex = nullptr;
        }

        if(m_output.texture_GatherDOF_Output)
        {
            s_delayedRelease.Add(m_output.texture_GatherDOF_Output);
            m_output.texture_GatherDOF_Output = nullptr;
        }

        if(m_internal.texture_GatherDOF_FarFieldColorCoC)
        {
            s_delayedRelease.Add(m_internal.texture_GatherDOF_FarFieldColorCoC);
            m_internal.texture_GatherDOF_FarFieldColorCoC = nullptr;
        }

        if(m_internal.texture_GatherDOF_NearFieldColorCoC)
        {
            s_delayedRelease.Add(m_internal.texture_GatherDOF_NearFieldColorCoC);
            m_internal.texture_GatherDOF_NearFieldColorCoC = nullptr;
        }

        if(m_internal.texture_GatherDOF_NearMaxCocTilemap)
        {
            s_delayedRelease.Add(m_internal.texture_GatherDOF_NearMaxCocTilemap);
            m_internal.texture_GatherDOF_NearMaxCocTilemap = nullptr;
        }

        if(m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha)
        {
            s_delayedRelease.Add(m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha);
            m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha = nullptr;
        }

        if(m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha)
        {
            s_delayedRelease.Add(m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha);
            m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha = nullptr;
        }

        if(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4)
        {
            s_delayedRelease.Add(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4);
            m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4 = nullptr;
        }

        if(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8)
        {
            s_delayedRelease.Add(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8);
            m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8 = nullptr;
        }

        if(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo)
        {
            s_delayedRelease.Add(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo);
            m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo = nullptr;
        }

        if(m_internal.texture_GatherDOF_NearFieldColorCoCBorder)
        {
            s_delayedRelease.Add(m_internal.texture_GatherDOF_NearFieldColorCoCBorder);
            m_internal.texture_GatherDOF_NearFieldColorCoCBorder = nullptr;
        }

        if(m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred)
        {
            s_delayedRelease.Add(m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred);
            m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred = nullptr;
        }

        if(m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha)
        {
            s_delayedRelease.Add(m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha);
            m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha = nullptr;
        }

        if(m_output.texture_GaussBlur_Output)
        {
            s_delayedRelease.Add(m_output.texture_GaussBlur_Output);
            m_output.texture_GaussBlur_Output = nullptr;
        }

        if(m_output.texture_TemporalAccumulation_Accum)
        {
            s_delayedRelease.Add(m_output.texture_TemporalAccumulation_Accum);
            m_output.texture_TemporalAccumulation_Accum = nullptr;
        }

        if(m_output.texture_ToneMap_Color_SDR)
        {
            s_delayedRelease.Add(m_output.texture_ToneMap_Color_SDR);
            m_output.texture_ToneMap_Color_SDR = nullptr;
        }

        if(m_internal.texture__loadedTexture_0)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_0);
            m_internal.texture__loadedTexture_0 = nullptr;
        }

        if(m_internal.texture__loadedTexture_1)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_1);
            m_internal.texture__loadedTexture_1 = nullptr;
        }

        if(m_internal.texture__loadedTexture_2)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_2);
            m_internal.texture__loadedTexture_2 = nullptr;
        }

        if(m_internal.texture__loadedTexture_3)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_3);
            m_internal.texture__loadedTexture_3 = nullptr;
        }

        if(m_internal.texture__loadedTexture_4)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_4);
            m_internal.texture__loadedTexture_4 = nullptr;
        }

        if(m_internal.texture__loadedTexture_5)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_5);
            m_internal.texture__loadedTexture_5 = nullptr;
        }

        if(m_internal.texture__loadedTexture_6)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_6);
            m_internal.texture__loadedTexture_6 = nullptr;
        }

        if(m_internal.texture__loadedTexture_7)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_7);
            m_internal.texture__loadedTexture_7 = nullptr;
        }

        if(m_internal.texture__loadedTexture_8)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_8);
            m_internal.texture__loadedTexture_8 = nullptr;
        }

        if(m_internal.texture__loadedTexture_9)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_9);
            m_internal.texture__loadedTexture_9 = nullptr;
        }

        if(m_internal.texture__loadedTexture_10)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_10);
            m_internal.texture__loadedTexture_10 = nullptr;
        }

        if(m_internal.texture__loadedTexture_11)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_11);
            m_internal.texture__loadedTexture_11 = nullptr;
        }

        if(m_internal.texture__loadedTexture_12)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_12);
            m_internal.texture__loadedTexture_12 = nullptr;
        }

        if(m_internal.texture__loadedTexture_13)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_13);
            m_internal.texture__loadedTexture_13 = nullptr;
        }

        if(m_internal.texture__loadedTexture_14)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_14);
            m_internal.texture__loadedTexture_14 = nullptr;
        }

        if(m_internal.texture__loadedTexture_15)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_15);
            m_internal.texture__loadedTexture_15 = nullptr;
        }

        if(m_internal.texture__loadedTexture_16)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_16);
            m_internal.texture__loadedTexture_16 = nullptr;
        }

        if(m_internal.texture__loadedTexture_17)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_17);
            m_internal.texture__loadedTexture_17 = nullptr;
        }

        if(m_internal.texture__loadedTexture_18)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_18);
            m_internal.texture__loadedTexture_18 = nullptr;
        }

        if(m_internal.texture__loadedTexture_19)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_19);
            m_internal.texture__loadedTexture_19 = nullptr;
        }

        if(m_internal.texture__loadedTexture_20)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_20);
            m_internal.texture__loadedTexture_20 = nullptr;
        }

        if(m_internal.texture__loadedTexture_21)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_21);
            m_internal.texture__loadedTexture_21 = nullptr;
        }

        if(m_internal.texture__loadedTexture_22)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_22);
            m_internal.texture__loadedTexture_22 = nullptr;
        }

        if(m_internal.texture__loadedTexture_23)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_23);
            m_internal.texture__loadedTexture_23 = nullptr;
        }

        if(m_internal.texture__loadedTexture_24)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_24);
            m_internal.texture__loadedTexture_24 = nullptr;
        }

        if(m_internal.texture__loadedTexture_25)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_25);
            m_internal.texture__loadedTexture_25 = nullptr;
        }

        if(m_internal.texture__loadedTexture_26)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_26);
            m_internal.texture__loadedTexture_26 = nullptr;
        }

        if(m_internal.texture__loadedTexture_27)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_27);
            m_internal.texture__loadedTexture_27 = nullptr;
        }

        if(m_internal.texture__loadedTexture_28)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_28);
            m_internal.texture__loadedTexture_28 = nullptr;
        }

        if(m_internal.texture__loadedTexture_29)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_29);
            m_internal.texture__loadedTexture_29 = nullptr;
        }

        if(m_internal.texture__loadedTexture_30)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_30);
            m_internal.texture__loadedTexture_30 = nullptr;
        }

        if(m_internal.texture__loadedTexture_31)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_31);
            m_internal.texture__loadedTexture_31 = nullptr;
        }

        if(m_internal.texture__loadedTexture_32)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_32);
            m_internal.texture__loadedTexture_32 = nullptr;
        }

        if(m_internal.texture__loadedTexture_33)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_33);
            m_internal.texture__loadedTexture_33 = nullptr;
        }

        if(m_internal.texture__loadedTexture_34)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_34);
            m_internal.texture__loadedTexture_34 = nullptr;
        }

        if(m_internal.texture__loadedTexture_35)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_35);
            m_internal.texture__loadedTexture_35 = nullptr;
        }

        if(m_internal.texture__loadedTexture_36)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_36);
            m_internal.texture__loadedTexture_36 = nullptr;
        }

        if(m_internal.texture__loadedTexture_37)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_37);
            m_internal.texture__loadedTexture_37 = nullptr;
        }

        if(m_internal.texture__loadedTexture_38)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_38);
            m_internal.texture__loadedTexture_38 = nullptr;
        }

        if(m_internal.texture__loadedTexture_39)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_39);
            m_internal.texture__loadedTexture_39 = nullptr;
        }

        if(m_internal.texture__loadedTexture_40)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_40);
            m_internal.texture__loadedTexture_40 = nullptr;
        }

        if(m_internal.texture__loadedTexture_41)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_41);
            m_internal.texture__loadedTexture_41 = nullptr;
        }

        if(m_internal.texture__loadedTexture_42)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_42);
            m_internal.texture__loadedTexture_42 = nullptr;
        }

        if(m_internal.texture__loadedTexture_43)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_43);
            m_internal.texture__loadedTexture_43 = nullptr;
        }

        if(m_internal.texture__loadedTexture_44)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_44);
            m_internal.texture__loadedTexture_44 = nullptr;
        }

        if(m_internal.texture__loadedTexture_45)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_45);
            m_internal.texture__loadedTexture_45 = nullptr;
        }

        if(m_internal.texture__loadedTexture_46)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_46);
            m_internal.texture__loadedTexture_46 = nullptr;
        }

        if(m_internal.texture__loadedTexture_47)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_47);
            m_internal.texture__loadedTexture_47 = nullptr;
        }

        if(m_internal.texture__loadedTexture_48)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_48);
            m_internal.texture__loadedTexture_48 = nullptr;
        }

        if(m_internal.texture__loadedTexture_49)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_49);
            m_internal.texture__loadedTexture_49 = nullptr;
        }

        if(m_internal.texture__loadedTexture_50)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_50);
            m_internal.texture__loadedTexture_50 = nullptr;
        }

        if(m_internal.texture__loadedTexture_51)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_51);
            m_internal.texture__loadedTexture_51 = nullptr;
        }

        if(m_internal.texture__loadedTexture_52)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_52);
            m_internal.texture__loadedTexture_52 = nullptr;
        }

        if(m_internal.texture__loadedTexture_53)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_53);
            m_internal.texture__loadedTexture_53 = nullptr;
        }

        if(m_internal.texture__loadedTexture_54)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_54);
            m_internal.texture__loadedTexture_54 = nullptr;
        }

        if(m_internal.texture__loadedTexture_55)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_55);
            m_internal.texture__loadedTexture_55 = nullptr;
        }

        if(m_internal.texture__loadedTexture_56)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_56);
            m_internal.texture__loadedTexture_56 = nullptr;
        }

        if(m_internal.texture__loadedTexture_57)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_57);
            m_internal.texture__loadedTexture_57 = nullptr;
        }

        if(m_internal.texture__loadedTexture_58)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_58);
            m_internal.texture__loadedTexture_58 = nullptr;
        }

        if(m_internal.texture__loadedTexture_59)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_59);
            m_internal.texture__loadedTexture_59 = nullptr;
        }

        if(m_internal.texture__loadedTexture_60)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_60);
            m_internal.texture__loadedTexture_60 = nullptr;
        }

        if(m_internal.texture__loadedTexture_61)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_61);
            m_internal.texture__loadedTexture_61 = nullptr;
        }

        if(m_internal.texture__loadedTexture_62)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_62);
            m_internal.texture__loadedTexture_62 = nullptr;
        }

        if(m_internal.texture__loadedTexture_63)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_63);
            m_internal.texture__loadedTexture_63 = nullptr;
        }

        if(m_internal.texture__loadedTexture_64)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_64);
            m_internal.texture__loadedTexture_64 = nullptr;
        }

        if(m_internal.texture__loadedTexture_65)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_65);
            m_internal.texture__loadedTexture_65 = nullptr;
        }

        if(m_internal.texture__loadedTexture_66)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_66);
            m_internal.texture__loadedTexture_66 = nullptr;
        }

        if(m_internal.texture__loadedTexture_67)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_67);
            m_internal.texture__loadedTexture_67 = nullptr;
        }

        if(m_internal.texture__loadedTexture_68)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_68);
            m_internal.texture__loadedTexture_68 = nullptr;
        }

        if(m_internal.texture__loadedTexture_69)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_69);
            m_internal.texture__loadedTexture_69 = nullptr;
        }

        if(m_internal.texture__loadedTexture_70)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_70);
            m_internal.texture__loadedTexture_70 = nullptr;
        }

        if(m_internal.texture__loadedTexture_71)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_71);
            m_internal.texture__loadedTexture_71 = nullptr;
        }

        if(m_internal.texture__loadedTexture_72)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_72);
            m_internal.texture__loadedTexture_72 = nullptr;
        }

        if(m_internal.texture__loadedTexture_73)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_73);
            m_internal.texture__loadedTexture_73 = nullptr;
        }

        if(m_internal.texture__loadedTexture_74)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_74);
            m_internal.texture__loadedTexture_74 = nullptr;
        }

        if(m_internal.texture__loadedTexture_75)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_75);
            m_internal.texture__loadedTexture_75 = nullptr;
        }

        if(m_internal.texture__loadedTexture_76)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_76);
            m_internal.texture__loadedTexture_76 = nullptr;
        }

        if(m_internal.texture__loadedTexture_77)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_77);
            m_internal.texture__loadedTexture_77 = nullptr;
        }

        if(m_internal.texture__loadedTexture_78)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_78);
            m_internal.texture__loadedTexture_78 = nullptr;
        }

        if(m_internal.texture__loadedTexture_79)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_79);
            m_internal.texture__loadedTexture_79 = nullptr;
        }

        if(m_internal.texture__loadedTexture_80)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_80);
            m_internal.texture__loadedTexture_80 = nullptr;
        }

        if(m_internal.texture__loadedTexture_81)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_81);
            m_internal.texture__loadedTexture_81 = nullptr;
        }

        if(m_internal.texture__loadedTexture_82)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_82);
            m_internal.texture__loadedTexture_82 = nullptr;
        }

        if(m_internal.texture__loadedTexture_83)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_83);
            m_internal.texture__loadedTexture_83 = nullptr;
        }

        if(m_internal.texture__loadedTexture_84)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_84);
            m_internal.texture__loadedTexture_84 = nullptr;
        }

        if(m_internal.texture__loadedTexture_85)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_85);
            m_internal.texture__loadedTexture_85 = nullptr;
        }

        if(m_internal.texture__loadedTexture_86)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_86);
            m_internal.texture__loadedTexture_86 = nullptr;
        }

        if(m_internal.texture__loadedTexture_87)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_87);
            m_internal.texture__loadedTexture_87 = nullptr;
        }

        if(m_internal.texture__loadedTexture_88)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_88);
            m_internal.texture__loadedTexture_88 = nullptr;
        }

        if(m_internal.texture__loadedTexture_89)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_89);
            m_internal.texture__loadedTexture_89 = nullptr;
        }

        if(m_internal.texture__loadedTexture_90)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_90);
            m_internal.texture__loadedTexture_90 = nullptr;
        }

        if(m_internal.texture__loadedTexture_91)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_91);
            m_internal.texture__loadedTexture_91 = nullptr;
        }

        if(m_internal.texture__loadedTexture_92)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_92);
            m_internal.texture__loadedTexture_92 = nullptr;
        }

        if(m_internal.texture__loadedTexture_93)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_93);
            m_internal.texture__loadedTexture_93 = nullptr;
        }

        if(m_internal.texture__loadedTexture_94)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_94);
            m_internal.texture__loadedTexture_94 = nullptr;
        }

        if(m_internal.texture__loadedTexture_95)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_95);
            m_internal.texture__loadedTexture_95 = nullptr;
        }

        if(m_internal.texture__loadedTexture_96)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_96);
            m_internal.texture__loadedTexture_96 = nullptr;
        }

        if(m_internal.texture__loadedTexture_97)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_97);
            m_internal.texture__loadedTexture_97 = nullptr;
        }

        if(m_internal.texture__loadedTexture_98)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_98);
            m_internal.texture__loadedTexture_98 = nullptr;
        }

        if(m_internal.texture__loadedTexture_99)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_99);
            m_internal.texture__loadedTexture_99 = nullptr;
        }

        if(m_internal.texture__loadedTexture_100)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_100);
            m_internal.texture__loadedTexture_100 = nullptr;
        }

        if(m_internal.texture__loadedTexture_101)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_101);
            m_internal.texture__loadedTexture_101 = nullptr;
        }

        if(m_internal.texture__loadedTexture_102)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_102);
            m_internal.texture__loadedTexture_102 = nullptr;
        }

        if(m_internal.texture__loadedTexture_103)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_103);
            m_internal.texture__loadedTexture_103 = nullptr;
        }

        if(m_internal.texture__loadedTexture_104)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_104);
            m_internal.texture__loadedTexture_104 = nullptr;
        }

        if(m_internal.texture__loadedTexture_105)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_105);
            m_internal.texture__loadedTexture_105 = nullptr;
        }

        if(m_internal.texture__loadedTexture_106)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_106);
            m_internal.texture__loadedTexture_106 = nullptr;
        }

        if(m_internal.texture__loadedTexture_107)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_107);
            m_internal.texture__loadedTexture_107 = nullptr;
        }

        if(m_internal.texture__loadedTexture_108)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_108);
            m_internal.texture__loadedTexture_108 = nullptr;
        }

        if(m_internal.texture__loadedTexture_109)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_109);
            m_internal.texture__loadedTexture_109 = nullptr;
        }

        if(m_internal.texture__loadedTexture_110)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_110);
            m_internal.texture__loadedTexture_110 = nullptr;
        }

        if(m_internal.texture__loadedTexture_111)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_111);
            m_internal.texture__loadedTexture_111 = nullptr;
        }

        if(m_internal.texture__loadedTexture_112)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_112);
            m_internal.texture__loadedTexture_112 = nullptr;
        }

        if(m_internal.texture__loadedTexture_113)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_113);
            m_internal.texture__loadedTexture_113 = nullptr;
        }

        if(m_internal.texture__loadedTexture_114)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_114);
            m_internal.texture__loadedTexture_114 = nullptr;
        }

        if(m_internal.texture__loadedTexture_115)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_115);
            m_internal.texture__loadedTexture_115 = nullptr;
        }

        if(m_internal.texture__loadedTexture_116)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_116);
            m_internal.texture__loadedTexture_116 = nullptr;
        }

        if(m_internal.texture__loadedTexture_117)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_117);
            m_internal.texture__loadedTexture_117 = nullptr;
        }

        if(m_internal.texture__loadedTexture_118)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_118);
            m_internal.texture__loadedTexture_118 = nullptr;
        }

        if(m_internal.texture__loadedTexture_119)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_119);
            m_internal.texture__loadedTexture_119 = nullptr;
        }

        if(m_internal.texture__loadedTexture_120)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_120);
            m_internal.texture__loadedTexture_120 = nullptr;
        }

        if(m_internal.texture__loadedTexture_121)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_121);
            m_internal.texture__loadedTexture_121 = nullptr;
        }

        if(m_internal.texture__loadedTexture_122)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_122);
            m_internal.texture__loadedTexture_122 = nullptr;
        }

        if(m_internal.texture__loadedTexture_123)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_123);
            m_internal.texture__loadedTexture_123 = nullptr;
        }

        if(m_internal.texture__loadedTexture_124)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_124);
            m_internal.texture__loadedTexture_124 = nullptr;
        }

        if(m_internal.texture__loadedTexture_125)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_125);
            m_internal.texture__loadedTexture_125 = nullptr;
        }

        if(m_internal.texture__loadedTexture_126)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_126);
            m_internal.texture__loadedTexture_126 = nullptr;
        }

        if(m_internal.texture__loadedTexture_127)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_127);
            m_internal.texture__loadedTexture_127 = nullptr;
        }

        if(m_internal.texture__loadedTexture_128)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_128);
            m_internal.texture__loadedTexture_128 = nullptr;
        }

        if(m_internal.texture__loadedTexture_129)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_129);
            m_internal.texture__loadedTexture_129 = nullptr;
        }

        if(m_internal.texture__loadedTexture_130)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_130);
            m_internal.texture__loadedTexture_130 = nullptr;
        }

        if(m_internal.texture__loadedTexture_131)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_131);
            m_internal.texture__loadedTexture_131 = nullptr;
        }

        if(m_internal.texture__loadedTexture_132)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_132);
            m_internal.texture__loadedTexture_132 = nullptr;
        }

        if(m_internal.texture__loadedTexture_133)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_133);
            m_internal.texture__loadedTexture_133 = nullptr;
        }

        if(m_internal.texture__loadedTexture_134)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_134);
            m_internal.texture__loadedTexture_134 = nullptr;
        }

        if(m_internal.texture__loadedTexture_135)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_135);
            m_internal.texture__loadedTexture_135 = nullptr;
        }

        if(m_internal.texture__loadedTexture_136)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_136);
            m_internal.texture__loadedTexture_136 = nullptr;
        }

        if(m_internal.texture__loadedTexture_137)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_137);
            m_internal.texture__loadedTexture_137 = nullptr;
        }

        if(m_internal.texture__loadedTexture_138)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_138);
            m_internal.texture__loadedTexture_138 = nullptr;
        }

        if(m_internal.texture__loadedTexture_139)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_139);
            m_internal.texture__loadedTexture_139 = nullptr;
        }

        if(m_internal.texture__loadedTexture_140)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_140);
            m_internal.texture__loadedTexture_140 = nullptr;
        }

        if(m_internal.texture__loadedTexture_141)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_141);
            m_internal.texture__loadedTexture_141 = nullptr;
        }

        if(m_internal.texture__loadedTexture_142)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_142);
            m_internal.texture__loadedTexture_142 = nullptr;
        }

        if(m_internal.texture__loadedTexture_143)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_143);
            m_internal.texture__loadedTexture_143 = nullptr;
        }

        if(m_internal.texture__loadedTexture_144)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_144);
            m_internal.texture__loadedTexture_144 = nullptr;
        }

        if(m_internal.texture__loadedTexture_145)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_145);
            m_internal.texture__loadedTexture_145 = nullptr;
        }

        if(m_internal.texture__loadedTexture_146)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_146);
            m_internal.texture__loadedTexture_146 = nullptr;
        }

        if(m_internal.texture__loadedTexture_147)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_147);
            m_internal.texture__loadedTexture_147 = nullptr;
        }

        if(m_internal.texture__loadedTexture_148)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_148);
            m_internal.texture__loadedTexture_148 = nullptr;
        }

        if(m_internal.texture__loadedTexture_149)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_149);
            m_internal.texture__loadedTexture_149 = nullptr;
        }

        if(m_internal.texture__loadedTexture_150)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_150);
            m_internal.texture__loadedTexture_150 = nullptr;
        }

        if(m_internal.texture__loadedTexture_151)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_151);
            m_internal.texture__loadedTexture_151 = nullptr;
        }

        if(m_internal.texture__loadedTexture_152)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_152);
            m_internal.texture__loadedTexture_152 = nullptr;
        }

        if(m_internal.texture__loadedTexture_153)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_153);
            m_internal.texture__loadedTexture_153 = nullptr;
        }

        if(m_internal.texture__loadedTexture_154)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_154);
            m_internal.texture__loadedTexture_154 = nullptr;
        }

        if(m_internal.texture__loadedTexture_155)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_155);
            m_internal.texture__loadedTexture_155 = nullptr;
        }

        if(m_internal.texture__loadedTexture_156)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_156);
            m_internal.texture__loadedTexture_156 = nullptr;
        }

        if(m_internal.texture__loadedTexture_157)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_157);
            m_internal.texture__loadedTexture_157 = nullptr;
        }

        if(m_internal.texture__loadedTexture_158)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_158);
            m_internal.texture__loadedTexture_158 = nullptr;
        }

        if(m_internal.texture__loadedTexture_159)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_159);
            m_internal.texture__loadedTexture_159 = nullptr;
        }

        if(m_internal.texture__loadedTexture_160)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_160);
            m_internal.texture__loadedTexture_160 = nullptr;
        }

        if(m_internal.texture__loadedTexture_161)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_161);
            m_internal.texture__loadedTexture_161 = nullptr;
        }

        if(m_internal.texture__loadedTexture_162)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_162);
            m_internal.texture__loadedTexture_162 = nullptr;
        }

        if(m_internal.texture__loadedTexture_163)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_163);
            m_internal.texture__loadedTexture_163 = nullptr;
        }

        if(m_internal.texture__loadedTexture_164)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_164);
            m_internal.texture__loadedTexture_164 = nullptr;
        }

        if(m_internal.texture__loadedTexture_165)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_165);
            m_internal.texture__loadedTexture_165 = nullptr;
        }

        if(m_internal.texture__loadedTexture_166)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_166);
            m_internal.texture__loadedTexture_166 = nullptr;
        }

        if(m_internal.texture__loadedTexture_167)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_167);
            m_internal.texture__loadedTexture_167 = nullptr;
        }

        if(m_internal.texture__loadedTexture_168)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_168);
            m_internal.texture__loadedTexture_168 = nullptr;
        }

        if(m_internal.texture__loadedTexture_169)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_169);
            m_internal.texture__loadedTexture_169 = nullptr;
        }

        if(m_internal.texture__loadedTexture_170)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_170);
            m_internal.texture__loadedTexture_170 = nullptr;
        }

        if(m_internal.texture__loadedTexture_171)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_171);
            m_internal.texture__loadedTexture_171 = nullptr;
        }

        if(m_internal.texture__loadedTexture_172)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_172);
            m_internal.texture__loadedTexture_172 = nullptr;
        }

        if(m_internal.texture__loadedTexture_173)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_173);
            m_internal.texture__loadedTexture_173 = nullptr;
        }

        if(m_internal.texture__loadedTexture_174)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_174);
            m_internal.texture__loadedTexture_174 = nullptr;
        }

        if(m_internal.texture__loadedTexture_175)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_175);
            m_internal.texture__loadedTexture_175 = nullptr;
        }

        if(m_internal.texture__loadedTexture_176)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_176);
            m_internal.texture__loadedTexture_176 = nullptr;
        }

        if(m_internal.texture__loadedTexture_177)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_177);
            m_internal.texture__loadedTexture_177 = nullptr;
        }

        if(m_internal.texture__loadedTexture_178)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_178);
            m_internal.texture__loadedTexture_178 = nullptr;
        }

        if(m_internal.texture__loadedTexture_179)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_179);
            m_internal.texture__loadedTexture_179 = nullptr;
        }

        if(m_internal.texture__loadedTexture_180)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_180);
            m_internal.texture__loadedTexture_180 = nullptr;
        }

        if(m_internal.texture__loadedTexture_181)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_181);
            m_internal.texture__loadedTexture_181 = nullptr;
        }

        if(m_internal.texture__loadedTexture_182)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_182);
            m_internal.texture__loadedTexture_182 = nullptr;
        }

        if(m_internal.texture__loadedTexture_183)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_183);
            m_internal.texture__loadedTexture_183 = nullptr;
        }

        if(m_internal.texture__loadedTexture_184)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_184);
            m_internal.texture__loadedTexture_184 = nullptr;
        }

        if(m_internal.texture__loadedTexture_185)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_185);
            m_internal.texture__loadedTexture_185 = nullptr;
        }

        if(m_internal.texture__loadedTexture_186)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_186);
            m_internal.texture__loadedTexture_186 = nullptr;
        }

        if(m_internal.texture__loadedTexture_187)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_187);
            m_internal.texture__loadedTexture_187 = nullptr;
        }

        if(m_internal.texture__loadedTexture_188)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_188);
            m_internal.texture__loadedTexture_188 = nullptr;
        }

        if(m_internal.texture__loadedTexture_189)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_189);
            m_internal.texture__loadedTexture_189 = nullptr;
        }

        if(m_internal.texture__loadedTexture_190)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_190);
            m_internal.texture__loadedTexture_190 = nullptr;
        }

        if(m_internal.texture__loadedTexture_191)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_191);
            m_internal.texture__loadedTexture_191 = nullptr;
        }

        if(m_internal.texture__loadedTexture_192)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_192);
            m_internal.texture__loadedTexture_192 = nullptr;
        }

        if(m_internal.texture__loadedTexture_193)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_193);
            m_internal.texture__loadedTexture_193 = nullptr;
        }

        if(m_internal.texture__loadedTexture_194)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_194);
            m_internal.texture__loadedTexture_194 = nullptr;
        }

        if(m_internal.texture__loadedTexture_195)
        {
            s_delayedRelease.Add(m_internal.texture__loadedTexture_195);
            m_internal.texture__loadedTexture_195 = nullptr;
        }

        // _RayGenCB
        if (m_internal.constantBuffer__RayGenCB)
        {
            s_delayedRelease.Add(m_internal.constantBuffer__RayGenCB);
            m_internal.constantBuffer__RayGenCB = nullptr;
        }

        // _GatherDOF_SetupCSCB
        if (m_internal.constantBuffer__GatherDOF_SetupCSCB)
        {
            s_delayedRelease.Add(m_internal.constantBuffer__GatherDOF_SetupCSCB);
            m_internal.constantBuffer__GatherDOF_SetupCSCB = nullptr;
        }

        // _GatherDOF_BlurFarCSCB
        if (m_internal.constantBuffer__GatherDOF_BlurFarCSCB)
        {
            s_delayedRelease.Add(m_internal.constantBuffer__GatherDOF_BlurFarCSCB);
            m_internal.constantBuffer__GatherDOF_BlurFarCSCB = nullptr;
        }

        // _GatherDOF_NearBlurCB
        if (m_internal.constantBuffer__GatherDOF_NearBlurCB)
        {
            s_delayedRelease.Add(m_internal.constantBuffer__GatherDOF_NearBlurCB);
            m_internal.constantBuffer__GatherDOF_NearBlurCB = nullptr;
        }

        // _GatherDOF_RecombineCSCB
        if (m_internal.constantBuffer__GatherDOF_RecombineCSCB)
        {
            s_delayedRelease.Add(m_internal.constantBuffer__GatherDOF_RecombineCSCB);
            m_internal.constantBuffer__GatherDOF_RecombineCSCB = nullptr;
        }

        // _GaussBlur_GaussBlurCSCB
        if (m_internal.constantBuffer__GaussBlur_GaussBlurCSCB)
        {
            s_delayedRelease.Add(m_internal.constantBuffer__GaussBlur_GaussBlurCSCB);
            m_internal.constantBuffer__GaussBlur_GaussBlurCSCB = nullptr;
        }

        // _TemporalAccumulation_AccumulateCB
        if (m_internal.constantBuffer__TemporalAccumulation_AccumulateCB)
        {
            s_delayedRelease.Add(m_internal.constantBuffer__TemporalAccumulation_AccumulateCB);
            m_internal.constantBuffer__TemporalAccumulation_AccumulateCB = nullptr;
        }

        // _ToneMap_TonemapCB
        if (m_internal.constantBuffer__ToneMap_TonemapCB)
        {
            s_delayedRelease.Add(m_internal.constantBuffer__ToneMap_TonemapCB);
            m_internal.constantBuffer__ToneMap_TonemapCB = nullptr;
        }

        // _GatherDOF_FloodFillFarCS_0CB
        if (m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB)
        {
            s_delayedRelease.Add(m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB);
            m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB = nullptr;
        }

        // _GatherDOF_FloodFillFarCS_1CB
        if (m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB)
        {
            s_delayedRelease.Add(m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB);
            m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB = nullptr;
        }
    }

    void Execute(Context* context, ID3D12Device* device, ID3D12GraphicsCommandList* commandList)
    {
        // reset the timer index
        s_timerIndex = 0;

        ScopedPerfEvent scopedPerf("FastBokeh", commandList, 243);

        std::chrono::high_resolution_clock::time_point startPointCPUTechnique;
        if(context->m_profile)
        {
            startPointCPUTechnique = std::chrono::high_resolution_clock::now();
            if(context->m_internal.m_TimestampQueryHeap == nullptr)
            {
                D3D12_QUERY_HEAP_DESC QueryHeapDesc;
                QueryHeapDesc.Count = (16+1) * 2;
                QueryHeapDesc.NodeMask = 1;
                QueryHeapDesc.Type = D3D12_QUERY_HEAP_TYPE_TIMESTAMP;
                device->CreateQueryHeap(&QueryHeapDesc, IID_PPV_ARGS(&context->m_internal.m_TimestampQueryHeap));
                if (c_debugNames)
                    context->m_internal.m_TimestampQueryHeap->SetName(L"FastBokeh Time Stamp Query Heap");

                context->m_internal.m_TimestampReadbackBuffer = DX12Utils::CreateBuffer(device, sizeof(uint64_t) * (16+1) * 2, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_HEAP_TYPE_READBACK, (c_debugNames ? L"FastBokeh Time Stamp Query Heap" : nullptr), nullptr);
            }
            commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
        }

        ID3D12Device5* dxrDevice = nullptr;
        ID3D12GraphicsCommandList4* dxrCommandList = nullptr;
        if (FAILED(device->QueryInterface(IID_PPV_ARGS(&dxrDevice))) || FAILED(commandList->QueryInterface(IID_PPV_ARGS(&dxrCommandList))))
        {
            Context::LogFn(LogLevel::Error, "Could not get dxr command list. Ray tracing not supported, but is required.");
            return;
        }

        // Set variables
        if(context->m_input.variable_CameraChanged)
            context->m_internal.variable_FrameIndex = 0;
        if(context->m_input.variable_Reset)
            context->m_internal.variable_FrameIndex = 0;
        if(!context->m_input.variable_Animate)
            context->m_internal.variable_FrameIndex = 0;
        context->m_internal.variable_FrameIndex = context->m_internal.variable_FrameIndex + 1;
        context->m_input.variable_NumBounces = max(context->m_input.variable_NumBounces, 2);

        if (!context->m_input.buffer_Scene_blas)
        {
            Context::LogFn(LogLevel::Error, "FastBokeh: Imported buffer \"Scene\" needs a BLAS/TLAS. Use CreateManagedTLAS to create them.\n");
            return;
        }

        if (!context->m_input.buffer_Scene)
        {
            Context::LogFn(LogLevel::Error, "FastBokeh: Imported buffer \"Scene\" is null.\n");
            return;
        }

        if (!context->m_input.buffer_VertexBuffer)
        {
            Context::LogFn(LogLevel::Error, "FastBokeh: Imported buffer \"VertexBuffer\" is null.\n");
            return;
        }

        // Make sure internally owned resources are created and are the right size and format
        context->EnsureResourcesCreated(device, commandList);

        // set the heaps
        ID3D12DescriptorHeap* heaps[] =
        {
            s_srvHeap.m_heap,
        };
        commandList->SetDescriptorHeaps(_countof(heaps), heaps);

        // Make sure imported resources are in the correct state
        {
            int barrierCount = 0;
            D3D12_RESOURCE_BARRIER barriers[2];

            if(context->m_input.buffer_Scene_state != D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE)
            {
                barriers[barrierCount].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
                barriers[barrierCount].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
                barriers[barrierCount].Transition.pResource = context->m_input.buffer_Scene;
                barriers[barrierCount].Transition.StateBefore = context->m_input.buffer_Scene_state;
                barriers[barrierCount].Transition.StateAfter = D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE;
                barriers[barrierCount].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
                barrierCount++;
            }

            if(context->m_input.buffer_VertexBuffer_state != D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
            {
                barriers[barrierCount].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
                barriers[barrierCount].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
                barriers[barrierCount].Transition.pResource = context->m_input.buffer_VertexBuffer;
                barriers[barrierCount].Transition.StateBefore = context->m_input.buffer_VertexBuffer_state;
                barriers[barrierCount].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
                barriers[barrierCount].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
                barrierCount++;
            }

            if(barrierCount > 0)
                commandList->ResourceBarrier(barrierCount, barriers);
        }

        // Shader Constants: _RayGenCB
        {
            context->m_internal.constantBuffer__RayGenCB_cpu.Accumulate = context->m_input.variable_Accumulate;
            context->m_internal.constantBuffer__RayGenCB_cpu.AlbedoMode = context->m_input.variable_AlbedoMode;
            context->m_internal.constantBuffer__RayGenCB_cpu.AlbedoModeAlbedoMultiplier = context->m_input.variable_AlbedoModeAlbedoMultiplier;
            context->m_internal.constantBuffer__RayGenCB_cpu.AnamorphicScaling = context->m_input.variable_AnamorphicScaling;
            context->m_internal.constantBuffer__RayGenCB_cpu.Animate = context->m_input.variable_Animate;
            context->m_internal.constantBuffer__RayGenCB_cpu.ApertureRadius = context->m_input.variable_ApertureRadius;
            context->m_internal.constantBuffer__RayGenCB_cpu.CameraPos = context->m_input.variable_CameraPos;
            context->m_internal.constantBuffer__RayGenCB_cpu.DOF = (int)context->m_input.variable_DOF;
            context->m_internal.constantBuffer__RayGenCB_cpu.DepthNearPlane = context->m_input.variable_DepthNearPlane;
            context->m_internal.constantBuffer__RayGenCB_cpu.FocalLength = context->m_input.variable_FocalLength;
            context->m_internal.constantBuffer__RayGenCB_cpu.FrameIndex = context->m_internal.variable_FrameIndex;
            context->m_internal.constantBuffer__RayGenCB_cpu.InvViewMtx = context->m_input.variable_InvViewMtx;
            context->m_internal.constantBuffer__RayGenCB_cpu.InvViewProjMtx = context->m_input.variable_InvViewProjMtx;
            context->m_internal.constantBuffer__RayGenCB_cpu.JitterNoiseTextures = context->m_input.variable_JitterNoiseTextures;
            context->m_internal.constantBuffer__RayGenCB_cpu.JitterPixels = (int)context->m_input.variable_JitterPixels;
            context->m_internal.constantBuffer__RayGenCB_cpu.LensRNGExtend = (int)context->m_input.variable_LensRNGExtend;
            context->m_internal.constantBuffer__RayGenCB_cpu.LensRNGSource = (int)context->m_input.variable_LensRNGSource;
            context->m_internal.constantBuffer__RayGenCB_cpu.MaterialEmissiveMultiplier = context->m_input.variable_MaterialEmissiveMultiplier;
            context->m_internal.constantBuffer__RayGenCB_cpu.MaterialSet = (int)context->m_input.variable_MaterialSet;
            context->m_internal.constantBuffer__RayGenCB_cpu.MouseState = context->m_input.variable_MouseState;
            context->m_internal.constantBuffer__RayGenCB_cpu.NoImportanceSampling = context->m_input.variable_NoImportanceSampling;
            context->m_internal.constantBuffer__RayGenCB_cpu.NumBounces = context->m_input.variable_NumBounces;
            context->m_internal.constantBuffer__RayGenCB_cpu.OcclusionSettings = context->m_input.variable_OcclusionSettings;
            context->m_internal.constantBuffer__RayGenCB_cpu.PetzvalScaling = context->m_input.variable_PetzvalScaling;
            context->m_internal.constantBuffer__RayGenCB_cpu.RayPosNormalNudge = context->m_input.variable_RayPosNormalNudge;
            context->m_internal.constantBuffer__RayGenCB_cpu.SamplesPerPixelPerFrame = context->m_input.variable_SamplesPerPixelPerFrame;
            context->m_internal.constantBuffer__RayGenCB_cpu.SkyBrightness = context->m_input.variable_SkyBrightness;
            context->m_internal.constantBuffer__RayGenCB_cpu.SkyColor = context->m_input.variable_SkyColor;
            context->m_internal.constantBuffer__RayGenCB_cpu.SmallLightBrightness = context->m_input.variable_SmallLightBrightness;
            context->m_internal.constantBuffer__RayGenCB_cpu.SmallLightRadius = context->m_input.variable_SmallLightRadius;
            context->m_internal.constantBuffer__RayGenCB_cpu.SmallLightsColor = context->m_input.variable_SmallLightsColor;
            context->m_internal.constantBuffer__RayGenCB_cpu.SmallLightsColorful = context->m_input.variable_SmallLightsColorful;
            DX12Utils::CopyConstantsCPUToGPU(s_ubTracker, device, commandList, context->m_internal.constantBuffer__RayGenCB, context->m_internal.constantBuffer__RayGenCB_cpu, Context::LogFn);
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[4];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_internal.texture_ColorHDR;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_SOURCE;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_UAV;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].UAV.pResource = context->m_internal.buffer_PixelDebug;

            barriers[2].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[2].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[2].Transition.pResource = context->m_internal.texture_LinearDepth;
            barriers[2].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[2].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[2].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[3].Type = D3D12_RESOURCE_BARRIER_TYPE_UAV;
            barriers[3].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[3].UAV.pResource = context->m_internal.texture_DebugTex;

            commandList->ResourceBarrier(4, barriers);
        }

        // Ray Shader: Raytrace
        {
            ScopedPerfEvent scopedPerf("Ray Shader: Raytrace", commandList, 0);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::rayShader_Raytrace_rootSig);
            dxrCommandList->SetPipelineState1(ContextInternal::rayShader_Raytrace_rtso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_internal.texture_ColorHDR, context->m_internal.texture_ColorHDR_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_LinearDepth, context->m_internal.texture_LinearDepth_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_input.buffer_Scene, DXGI_FORMAT_UNKNOWN, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::RTScene, false, context->m_input.buffer_Scene_tlasSize, 1, 0, 0, 0, false },
                { context->m_input.buffer_VertexBuffer, context->m_input.buffer_VertexBuffer_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Buffer, false, context->m_input.buffer_VertexBuffer_stride, context->m_input.buffer_VertexBuffer_count, 0, 0, 0, false },
                { context->m_internal.buffer_PixelDebug, context->m_internal.buffer_PixelDebug_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Buffer, false, context->m_internal.buffer_PixelDebug_stride, context->m_internal.buffer_PixelDebug_count, 0, 0, 0, false },
                { context->m_internal.texture_DebugTex, context->m_internal.texture_DebugTex_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_0, context->m_internal.texture__loadedTexture_0_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_1, context->m_internal.texture__loadedTexture_1_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_2, context->m_internal.texture__loadedTexture_2_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_3, context->m_internal.texture__loadedTexture_3_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_4, context->m_internal.texture__loadedTexture_4_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_5, context->m_internal.texture__loadedTexture_5_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_6, context->m_internal.texture__loadedTexture_6_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_7, context->m_internal.texture__loadedTexture_7_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_8, context->m_internal.texture__loadedTexture_8_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_9, context->m_internal.texture__loadedTexture_9_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_10, context->m_internal.texture__loadedTexture_10_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_11, context->m_internal.texture__loadedTexture_11_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_12, context->m_internal.texture__loadedTexture_12_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_13, context->m_internal.texture__loadedTexture_13_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_14, context->m_internal.texture__loadedTexture_14_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_15, context->m_internal.texture__loadedTexture_15_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_16, context->m_internal.texture__loadedTexture_16_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_17, context->m_internal.texture__loadedTexture_17_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_18, context->m_internal.texture__loadedTexture_18_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_19, context->m_internal.texture__loadedTexture_19_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_20, context->m_internal.texture__loadedTexture_20_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_21, context->m_internal.texture__loadedTexture_21_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_22, context->m_internal.texture__loadedTexture_22_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_23, context->m_internal.texture__loadedTexture_23_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_24, context->m_internal.texture__loadedTexture_24_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_25, context->m_internal.texture__loadedTexture_25_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_26, context->m_internal.texture__loadedTexture_26_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_27, context->m_internal.texture__loadedTexture_27_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_28, context->m_internal.texture__loadedTexture_28_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_29, context->m_internal.texture__loadedTexture_29_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_30, context->m_internal.texture__loadedTexture_30_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_31, context->m_internal.texture__loadedTexture_31_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_32, context->m_internal.texture__loadedTexture_32_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_33, context->m_internal.texture__loadedTexture_33_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_34, context->m_internal.texture__loadedTexture_34_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_35, context->m_internal.texture__loadedTexture_35_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_36, context->m_internal.texture__loadedTexture_36_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_37, context->m_internal.texture__loadedTexture_37_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_38, context->m_internal.texture__loadedTexture_38_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_39, context->m_internal.texture__loadedTexture_39_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_40, context->m_internal.texture__loadedTexture_40_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_41, context->m_internal.texture__loadedTexture_41_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_42, context->m_internal.texture__loadedTexture_42_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_43, context->m_internal.texture__loadedTexture_43_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_44, context->m_internal.texture__loadedTexture_44_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_45, context->m_internal.texture__loadedTexture_45_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_46, context->m_internal.texture__loadedTexture_46_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_47, context->m_internal.texture__loadedTexture_47_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_48, context->m_internal.texture__loadedTexture_48_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_49, context->m_internal.texture__loadedTexture_49_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_50, context->m_internal.texture__loadedTexture_50_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_51, context->m_internal.texture__loadedTexture_51_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_52, context->m_internal.texture__loadedTexture_52_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_53, context->m_internal.texture__loadedTexture_53_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_54, context->m_internal.texture__loadedTexture_54_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_55, context->m_internal.texture__loadedTexture_55_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_56, context->m_internal.texture__loadedTexture_56_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_57, context->m_internal.texture__loadedTexture_57_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_58, context->m_internal.texture__loadedTexture_58_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_59, context->m_internal.texture__loadedTexture_59_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_60, context->m_internal.texture__loadedTexture_60_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_61, context->m_internal.texture__loadedTexture_61_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_62, context->m_internal.texture__loadedTexture_62_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_63, context->m_internal.texture__loadedTexture_63_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_64, context->m_internal.texture__loadedTexture_64_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_65, context->m_internal.texture__loadedTexture_65_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_66, context->m_internal.texture__loadedTexture_66_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_67, context->m_internal.texture__loadedTexture_67_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_68, context->m_internal.texture__loadedTexture_68_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_69, context->m_internal.texture__loadedTexture_69_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_70, context->m_internal.texture__loadedTexture_70_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_71, context->m_internal.texture__loadedTexture_71_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_72, context->m_internal.texture__loadedTexture_72_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_73, context->m_internal.texture__loadedTexture_73_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_74, context->m_internal.texture__loadedTexture_74_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_75, context->m_internal.texture__loadedTexture_75_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_76, context->m_internal.texture__loadedTexture_76_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_77, context->m_internal.texture__loadedTexture_77_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_78, context->m_internal.texture__loadedTexture_78_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_79, context->m_internal.texture__loadedTexture_79_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_80, context->m_internal.texture__loadedTexture_80_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_81, context->m_internal.texture__loadedTexture_81_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_82, context->m_internal.texture__loadedTexture_82_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_83, context->m_internal.texture__loadedTexture_83_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_84, context->m_internal.texture__loadedTexture_84_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_85, context->m_internal.texture__loadedTexture_85_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_86, context->m_internal.texture__loadedTexture_86_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_87, context->m_internal.texture__loadedTexture_87_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_88, context->m_internal.texture__loadedTexture_88_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_89, context->m_internal.texture__loadedTexture_89_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_90, context->m_internal.texture__loadedTexture_90_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_91, context->m_internal.texture__loadedTexture_91_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_92, context->m_internal.texture__loadedTexture_92_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_93, context->m_internal.texture__loadedTexture_93_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_94, context->m_internal.texture__loadedTexture_94_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_95, context->m_internal.texture__loadedTexture_95_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_96, context->m_internal.texture__loadedTexture_96_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_97, context->m_internal.texture__loadedTexture_97_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_98, context->m_internal.texture__loadedTexture_98_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_99, context->m_internal.texture__loadedTexture_99_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_100, context->m_internal.texture__loadedTexture_100_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_101, context->m_internal.texture__loadedTexture_101_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_102, context->m_internal.texture__loadedTexture_102_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_103, context->m_internal.texture__loadedTexture_103_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_104, context->m_internal.texture__loadedTexture_104_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_105, context->m_internal.texture__loadedTexture_105_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_106, context->m_internal.texture__loadedTexture_106_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_107, context->m_internal.texture__loadedTexture_107_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_108, context->m_internal.texture__loadedTexture_108_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_109, context->m_internal.texture__loadedTexture_109_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_110, context->m_internal.texture__loadedTexture_110_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_111, context->m_internal.texture__loadedTexture_111_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_112, context->m_internal.texture__loadedTexture_112_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_113, context->m_internal.texture__loadedTexture_113_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_114, context->m_internal.texture__loadedTexture_114_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_115, context->m_internal.texture__loadedTexture_115_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_116, context->m_internal.texture__loadedTexture_116_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_117, context->m_internal.texture__loadedTexture_117_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_118, context->m_internal.texture__loadedTexture_118_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_119, context->m_internal.texture__loadedTexture_119_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_120, context->m_internal.texture__loadedTexture_120_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_121, context->m_internal.texture__loadedTexture_121_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_122, context->m_internal.texture__loadedTexture_122_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_123, context->m_internal.texture__loadedTexture_123_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_124, context->m_internal.texture__loadedTexture_124_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_125, context->m_internal.texture__loadedTexture_125_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_126, context->m_internal.texture__loadedTexture_126_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_127, context->m_internal.texture__loadedTexture_127_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_128, context->m_internal.texture__loadedTexture_128_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_129, context->m_internal.texture__loadedTexture_129_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_130, context->m_internal.texture__loadedTexture_130_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_131, context->m_internal.texture__loadedTexture_131_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_132, context->m_internal.texture__loadedTexture_132_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_133, context->m_internal.texture__loadedTexture_133_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_134, context->m_internal.texture__loadedTexture_134_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_135, context->m_internal.texture__loadedTexture_135_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_136, context->m_internal.texture__loadedTexture_136_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_137, context->m_internal.texture__loadedTexture_137_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_138, context->m_internal.texture__loadedTexture_138_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_139, context->m_internal.texture__loadedTexture_139_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_140, context->m_internal.texture__loadedTexture_140_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_141, context->m_internal.texture__loadedTexture_141_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_142, context->m_internal.texture__loadedTexture_142_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_143, context->m_internal.texture__loadedTexture_143_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_144, context->m_internal.texture__loadedTexture_144_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_145, context->m_internal.texture__loadedTexture_145_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_146, context->m_internal.texture__loadedTexture_146_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_147, context->m_internal.texture__loadedTexture_147_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_148, context->m_internal.texture__loadedTexture_148_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_149, context->m_internal.texture__loadedTexture_149_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_150, context->m_internal.texture__loadedTexture_150_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_151, context->m_internal.texture__loadedTexture_151_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_152, context->m_internal.texture__loadedTexture_152_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_153, context->m_internal.texture__loadedTexture_153_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_154, context->m_internal.texture__loadedTexture_154_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_155, context->m_internal.texture__loadedTexture_155_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_156, context->m_internal.texture__loadedTexture_156_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_157, context->m_internal.texture__loadedTexture_157_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_158, context->m_internal.texture__loadedTexture_158_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_159, context->m_internal.texture__loadedTexture_159_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_160, context->m_internal.texture__loadedTexture_160_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_161, context->m_internal.texture__loadedTexture_161_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_162, context->m_internal.texture__loadedTexture_162_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_163, context->m_internal.texture__loadedTexture_163_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_164, context->m_internal.texture__loadedTexture_164_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_165, context->m_internal.texture__loadedTexture_165_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_166, context->m_internal.texture__loadedTexture_166_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_167, context->m_internal.texture__loadedTexture_167_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_168, context->m_internal.texture__loadedTexture_168_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_169, context->m_internal.texture__loadedTexture_169_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_170, context->m_internal.texture__loadedTexture_170_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_171, context->m_internal.texture__loadedTexture_171_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_171_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_172, context->m_internal.texture__loadedTexture_172_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_173, context->m_internal.texture__loadedTexture_173_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_174, context->m_internal.texture__loadedTexture_174_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_175, context->m_internal.texture__loadedTexture_175_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_176, context->m_internal.texture__loadedTexture_176_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_177, context->m_internal.texture__loadedTexture_177_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_178, context->m_internal.texture__loadedTexture_178_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_179, context->m_internal.texture__loadedTexture_179_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_179_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_180, context->m_internal.texture__loadedTexture_180_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_180_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_181, context->m_internal.texture__loadedTexture_181_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_181_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_182, context->m_internal.texture__loadedTexture_182_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_182_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_183, context->m_internal.texture__loadedTexture_183_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_184, context->m_internal.texture__loadedTexture_184_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_184_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_185, context->m_internal.texture__loadedTexture_185_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_185_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_186, context->m_internal.texture__loadedTexture_186_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_187, context->m_internal.texture__loadedTexture_187_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_187_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_188, context->m_internal.texture__loadedTexture_188_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_188_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_189, context->m_internal.texture__loadedTexture_189_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_189_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_190, context->m_internal.texture__loadedTexture_190_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_190_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_191, context->m_internal.texture__loadedTexture_191_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_191_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_192, context->m_internal.texture__loadedTexture_192_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_192_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_193, context->m_internal.texture__loadedTexture_193_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_193_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_194, context->m_internal.texture__loadedTexture_194_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_194_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_195, context->m_internal.texture__loadedTexture_195_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.constantBuffer__RayGenCB, DXGI_FORMAT_UNKNOWN, DX12Utils::AccessType::CBV, DX12Utils::ResourceType::Buffer, false, 512, 1, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 203, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_internal.texture_ColorHDR_size[0],
                context->m_internal.texture_ColorHDR_size[1],
                context->m_internal.texture_ColorHDR_size[2]
            };

            D3D12_DISPATCH_RAYS_DESC dispatchDesc = {};
            dispatchDesc.Width = ((baseDispatchSize[0] + 0) * 1) / 1 + 0;
            dispatchDesc.Height = ((baseDispatchSize[1] + 0) * 1) / 1 + 0;
            dispatchDesc.Depth = ((baseDispatchSize[2] + 0) * 1) / 1 + 0;
            dispatchDesc.RayGenerationShaderRecord.StartAddress = ContextInternal::rayShader_Raytrace_shaderTableRayGen->GetGPUVirtualAddress();
            dispatchDesc.RayGenerationShaderRecord.SizeInBytes = ContextInternal::rayShader_Raytrace_shaderTableRayGenSize;
            if (ContextInternal::rayShader_Raytrace_shaderTableMiss)
                dispatchDesc.MissShaderTable.StartAddress = ContextInternal::rayShader_Raytrace_shaderTableMiss->GetGPUVirtualAddress();
            dispatchDesc.MissShaderTable.SizeInBytes = ContextInternal::rayShader_Raytrace_shaderTableMissSize;
            dispatchDesc.MissShaderTable.StrideInBytes = D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES;
            if (ContextInternal::rayShader_Raytrace_shaderTableHitGroup)
                dispatchDesc.HitGroupTable.StartAddress = ContextInternal::rayShader_Raytrace_shaderTableHitGroup->GetGPUVirtualAddress();
            dispatchDesc.HitGroupTable.SizeInBytes = ContextInternal::rayShader_Raytrace_shaderTableHitGroupSize;
            dispatchDesc.HitGroupTable.StrideInBytes = D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES;

            dxrCommandList->DispatchRays(&dispatchDesc);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "Raytrace";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Shader Constants: _GatherDOF_SetupCSCB
        {
            context->m_internal.constantBuffer__GatherDOF_SetupCSCB_cpu.GatherDOF_FarTransitionRegion = context->m_input.variable_GatherDOF_FarTransitionRegion;
            context->m_internal.constantBuffer__GatherDOF_SetupCSCB_cpu.GatherDOF_FocalDistance = context->m_input.variable_GatherDOF_FocalDistance;
            context->m_internal.constantBuffer__GatherDOF_SetupCSCB_cpu.GatherDOF_FocalLength = context->m_input.variable_GatherDOF_FocalLength;
            context->m_internal.constantBuffer__GatherDOF_SetupCSCB_cpu.GatherDOF_FocalRegion = context->m_input.variable_GatherDOF_FocalRegion;
            context->m_internal.constantBuffer__GatherDOF_SetupCSCB_cpu.GatherDOF_NearTransitionRegion = context->m_input.variable_GatherDOF_NearTransitionRegion;
            context->m_internal.constantBuffer__GatherDOF_SetupCSCB_cpu.GatherDOF_Scale = context->m_input.variable_GatherDOF_Scale;
            context->m_internal.constantBuffer__GatherDOF_SetupCSCB_cpu.GatherDOF_SuppressBokeh = context->m_input.variable_GatherDOF_SuppressBokeh;
            DX12Utils::CopyConstantsCPUToGPU(s_ubTracker, device, commandList, context->m_internal.constantBuffer__GatherDOF_SetupCSCB, context->m_internal.constantBuffer__GatherDOF_SetupCSCB_cpu, Context::LogFn);
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[5];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_internal.texture_ColorHDR;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_internal.texture_LinearDepth;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[2].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[2].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[2].Transition.pResource = context->m_internal.texture_GatherDOF_FarFieldColorCoC;
            barriers[2].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[2].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[2].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[3].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[3].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[3].Transition.pResource = context->m_internal.texture_GatherDOF_NearFieldColorCoC;
            barriers[3].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[3].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[3].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[4].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[4].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[4].Transition.pResource = context->m_internal.texture_GatherDOF_NearMaxCocTilemap;
            barriers[4].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[4].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[4].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(5, barriers);
        }

        // Compute Shader: GatherDOF_Setup
        {
            ScopedPerfEvent scopedPerf("Compute Shader: GatherDOF_Setup", commandList, 9);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_GatherDOF_Setup_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_GatherDOF_Setup_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_internal.texture_ColorHDR, context->m_internal.texture_ColorHDR_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_LinearDepth, context->m_internal.texture_LinearDepth_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_FarFieldColorCoC, context->m_internal.texture_GatherDOF_FarFieldColorCoC_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_NearFieldColorCoC, context->m_internal.texture_GatherDOF_NearFieldColorCoC_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_NearMaxCocTilemap, context->m_internal.texture_GatherDOF_NearMaxCocTilemap_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.constantBuffer__GatherDOF_SetupCSCB, DXGI_FORMAT_UNKNOWN, DX12Utils::AccessType::CBV, DX12Utils::ResourceType::Buffer, false, 256, 1, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 6, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_internal.texture_ColorHDR_size[0],
                context->m_internal.texture_ColorHDR_size[1],
                context->m_internal.texture_ColorHDR_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GatherDOF_Setup";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[2];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_internal.texture_GatherDOF_NearFieldColorCoC;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_internal.texture_GatherDOF_NearFieldColorCoCBorder;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(2, barriers);
        }

        // Compute Shader: GatherDOF_NearBorder
        if(context->m_input.variable_GatherDOF_DoNearField)
        {
            ScopedPerfEvent scopedPerf("Compute Shader: GatherDOF_NearBorder", commandList, 23);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_GatherDOF_NearBorder_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_GatherDOF_NearBorder_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_internal.texture_GatherDOF_NearFieldColorCoC, context->m_internal.texture_GatherDOF_NearFieldColorCoC_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_NearFieldColorCoCBorder, context->m_internal.texture_GatherDOF_NearFieldColorCoCBorder_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 2, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_internal.texture_GatherDOF_NearFieldColorCoC_size[0],
                context->m_internal.texture_GatherDOF_NearFieldColorCoC_size[1],
                context->m_internal.texture_GatherDOF_NearFieldColorCoC_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GatherDOF_NearBorder";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Shader Constants: _GatherDOF_BlurFarCSCB
        {
            context->m_internal.constantBuffer__GatherDOF_BlurFarCSCB_cpu.GatherDOF_AnimateNoiseTextures = context->m_input.variable_GatherDOF_AnimateNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_BlurFarCSCB_cpu.GatherDOF_BlurTapCount = context->m_input.variable_GatherDOF_BlurTapCount;
            context->m_internal.constantBuffer__GatherDOF_BlurFarCSCB_cpu.GatherDOF_FrameIndex = context->m_internal.variable_GatherDOF_FrameIndex;
            context->m_internal.constantBuffer__GatherDOF_BlurFarCSCB_cpu.GatherDOF_KernelSize = context->m_input.variable_GatherDOF_KernelSize;
            context->m_internal.constantBuffer__GatherDOF_BlurFarCSCB_cpu.GatherDOF_UseNoiseTextures = context->m_input.variable_GatherDOF_UseNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_BlurFarCSCB_cpu.JitterNoiseTextures = context->m_input.variable_JitterNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_BlurFarCSCB_cpu.LensRNGExtend = (int)context->m_input.variable_LensRNGExtend;
            context->m_internal.constantBuffer__GatherDOF_BlurFarCSCB_cpu.LensRNGSource = (int)context->m_input.variable_LensRNGSource;
            DX12Utils::CopyConstantsCPUToGPU(s_ubTracker, device, commandList, context->m_internal.constantBuffer__GatherDOF_BlurFarCSCB, context->m_internal.constantBuffer__GatherDOF_BlurFarCSCB_cpu, Context::LogFn);
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[2];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_internal.texture_GatherDOF_FarFieldColorCoC;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(2, barriers);
        }

        // Compute Shader: GatherDOF_BlurFar
        if(context->m_input.variable_GatherDOF_DoFarField)
        {
            ScopedPerfEvent scopedPerf("Compute Shader: GatherDOF_BlurFar", commandList, 13);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_GatherDOF_BlurFar_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_GatherDOF_BlurFar_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_internal.texture_GatherDOF_FarFieldColorCoC, context->m_internal.texture_GatherDOF_FarFieldColorCoC_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha, context->m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_179, context->m_internal.texture__loadedTexture_179_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_179_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_180, context->m_internal.texture__loadedTexture_180_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_180_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_181, context->m_internal.texture__loadedTexture_181_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_181_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_182, context->m_internal.texture__loadedTexture_182_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_182_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_183, context->m_internal.texture__loadedTexture_183_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_171, context->m_internal.texture__loadedTexture_171_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_171_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_184, context->m_internal.texture__loadedTexture_184_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_184_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_185, context->m_internal.texture__loadedTexture_185_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_185_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_187, context->m_internal.texture__loadedTexture_187_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_187_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_188, context->m_internal.texture__loadedTexture_188_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_188_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_186, context->m_internal.texture__loadedTexture_186_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_189, context->m_internal.texture__loadedTexture_189_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_189_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_190, context->m_internal.texture__loadedTexture_190_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_190_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_191, context->m_internal.texture__loadedTexture_191_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_191_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_192, context->m_internal.texture__loadedTexture_192_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_192_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_193, context->m_internal.texture__loadedTexture_193_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_193_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_194, context->m_internal.texture__loadedTexture_194_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_194_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_195, context->m_internal.texture__loadedTexture_195_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.constantBuffer__GatherDOF_BlurFarCSCB, DXGI_FORMAT_UNKNOWN, DX12Utils::AccessType::CBV, DX12Utils::ResourceType::Buffer, false, 256, 1, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 21, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_internal.texture_GatherDOF_FarFieldColorCoC_size[0],
                context->m_internal.texture_GatherDOF_FarFieldColorCoC_size[1],
                context->m_internal.texture_GatherDOF_FarFieldColorCoC_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GatherDOF_BlurFar";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Shader Constants: _GatherDOF_NearBlurCB
        {
            context->m_internal.constantBuffer__GatherDOF_NearBlurCB_cpu.GatherDOF_AnimateNoiseTextures = context->m_input.variable_GatherDOF_AnimateNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_NearBlurCB_cpu.GatherDOF_BlurTapCount = context->m_input.variable_GatherDOF_BlurTapCount;
            context->m_internal.constantBuffer__GatherDOF_NearBlurCB_cpu.GatherDOF_FrameIndex = context->m_internal.variable_GatherDOF_FrameIndex;
            context->m_internal.constantBuffer__GatherDOF_NearBlurCB_cpu.GatherDOF_KernelSize = context->m_input.variable_GatherDOF_KernelSize;
            context->m_internal.constantBuffer__GatherDOF_NearBlurCB_cpu.GatherDOF_UseNoiseTextures = context->m_input.variable_GatherDOF_UseNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_NearBlurCB_cpu.JitterNoiseTextures = context->m_input.variable_JitterNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_NearBlurCB_cpu.LensRNGExtend = (int)context->m_input.variable_LensRNGExtend;
            context->m_internal.constantBuffer__GatherDOF_NearBlurCB_cpu.LensRNGSource = (int)context->m_input.variable_LensRNGSource;
            DX12Utils::CopyConstantsCPUToGPU(s_ubTracker, device, commandList, context->m_internal.constantBuffer__GatherDOF_NearBlurCB, context->m_internal.constantBuffer__GatherDOF_NearBlurCB_cpu, Context::LogFn);
        }

        // Shader Constants: _GatherDOF_RecombineCSCB
        {
            context->m_internal.constantBuffer__GatherDOF_RecombineCSCB_cpu.GatherDOF_DoFarField = context->m_input.variable_GatherDOF_DoFarField;
            context->m_internal.constantBuffer__GatherDOF_RecombineCSCB_cpu.GatherDOF_DoNearField = context->m_input.variable_GatherDOF_DoNearField;
            context->m_internal.constantBuffer__GatherDOF_RecombineCSCB_cpu.GatherDOF_FarTransitionRegion = context->m_input.variable_GatherDOF_FarTransitionRegion;
            context->m_internal.constantBuffer__GatherDOF_RecombineCSCB_cpu.GatherDOF_FocalDistance = context->m_input.variable_GatherDOF_FocalDistance;
            context->m_internal.constantBuffer__GatherDOF_RecombineCSCB_cpu.GatherDOF_FocalLength = context->m_input.variable_GatherDOF_FocalLength;
            context->m_internal.constantBuffer__GatherDOF_RecombineCSCB_cpu.GatherDOF_FocalRegion = context->m_input.variable_GatherDOF_FocalRegion;
            context->m_internal.constantBuffer__GatherDOF_RecombineCSCB_cpu.GatherDOF_NearTransitionRegion = context->m_input.variable_GatherDOF_NearTransitionRegion;
            context->m_internal.constantBuffer__GatherDOF_RecombineCSCB_cpu.GatherDOF_Scale = context->m_input.variable_GatherDOF_Scale;
            DX12Utils::CopyConstantsCPUToGPU(s_ubTracker, device, commandList, context->m_internal.constantBuffer__GatherDOF_RecombineCSCB, context->m_internal.constantBuffer__GatherDOF_RecombineCSCB_cpu, Context::LogFn);
        }

        // Shader Constants: _GaussBlur_GaussBlurCSCB
        {
            context->m_internal.constantBuffer__GaussBlur_GaussBlurCSCB_cpu.GaussBlur_Sigma = context->m_input.variable_GaussBlur_Sigma;
            DX12Utils::CopyConstantsCPUToGPU(s_ubTracker, device, commandList, context->m_internal.constantBuffer__GaussBlur_GaussBlurCSCB, context->m_internal.constantBuffer__GaussBlur_GaussBlurCSCB_cpu, Context::LogFn);
        }

        // Shader Constants: _TemporalAccumulation_AccumulateCB
        {
            context->m_internal.constantBuffer__TemporalAccumulation_AccumulateCB_cpu.CameraChanged = context->m_input.variable_CameraChanged;
            context->m_internal.constantBuffer__TemporalAccumulation_AccumulateCB_cpu.TemporalAccumulation_Alpha = context->m_input.variable_TemporalAccumulation_Alpha;
            context->m_internal.constantBuffer__TemporalAccumulation_AccumulateCB_cpu.TemporalAccumulation_Enabled = context->m_input.variable_TemporalAccumulation_Enabled;
            DX12Utils::CopyConstantsCPUToGPU(s_ubTracker, device, commandList, context->m_internal.constantBuffer__TemporalAccumulation_AccumulateCB, context->m_internal.constantBuffer__TemporalAccumulation_AccumulateCB_cpu, Context::LogFn);
        }

        // Shader Constants: _ToneMap_TonemapCB
        {
            context->m_internal.constantBuffer__ToneMap_TonemapCB_cpu.ToneMap_ExposureFStops = context->m_input.variable_ToneMap_ExposureFStops;
            context->m_internal.constantBuffer__ToneMap_TonemapCB_cpu.ToneMap_ToneMapper = (int)context->m_input.variable_ToneMap_ToneMapper;
            DX12Utils::CopyConstantsCPUToGPU(s_ubTracker, device, commandList, context->m_internal.constantBuffer__ToneMap_TonemapCB, context->m_internal.constantBuffer__ToneMap_TonemapCB_cpu, Context::LogFn);
        }

        // Shader Constants: _GatherDOF_FloodFillFarCS_0CB
        {
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB_cpu.GatherDOF_AnimateNoiseTextures = context->m_input.variable_GatherDOF_AnimateNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB_cpu.GatherDOF_DoFarFieldFloodFill = context->m_input.variable_GatherDOF_DoFarFieldFloodFill;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB_cpu.GatherDOF_DoNearFieldFloodFill = context->m_input.variable_GatherDOF_DoNearFieldFloodFill;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB_cpu.GatherDOF_FloodFillTapCount = context->m_input.variable_GatherDOF_FloodFillTapCount;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB_cpu.GatherDOF_FrameIndex = context->m_internal.variable_GatherDOF_FrameIndex;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB_cpu.GatherDOF_KernelSize = context->m_input.variable_GatherDOF_KernelSize;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB_cpu.GatherDOF_UseNoiseTextures = context->m_input.variable_GatherDOF_UseNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB_cpu.JitterNoiseTextures = context->m_input.variable_JitterNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB_cpu.LensRNGExtend = (int)context->m_input.variable_LensRNGExtend;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB_cpu.LensRNGSource = (int)context->m_input.variable_LensRNGSource;
            DX12Utils::CopyConstantsCPUToGPU(s_ubTracker, device, commandList, context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB, context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB_cpu, Context::LogFn);
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[3];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_internal.texture_GatherDOF_NearMaxCocTilemap;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[2].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[2].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[2].Transition.pResource = context->m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha;
            barriers[2].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[2].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[2].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(3, barriers);
        }

        // Compute Shader: GatherDOF_FloodFillFar
        if(context->m_input.variable_GatherDOF_DoFarField)
        {
            ScopedPerfEvent scopedPerf("Compute Shader: GatherDOF_FloodFillFar", commandList, 15);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_GatherDOF_FloodFillFar_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_GatherDOF_FloodFillFar_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_internal.texture_GatherDOF_NearMaxCocTilemap, context->m_internal.texture_GatherDOF_NearMaxCocTilemap_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha, context->m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha, context->m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_179, context->m_internal.texture__loadedTexture_179_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_179_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_180, context->m_internal.texture__loadedTexture_180_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_180_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_181, context->m_internal.texture__loadedTexture_181_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_181_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_182, context->m_internal.texture__loadedTexture_182_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_182_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_183, context->m_internal.texture__loadedTexture_183_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_171, context->m_internal.texture__loadedTexture_171_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_171_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_184, context->m_internal.texture__loadedTexture_184_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_184_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_185, context->m_internal.texture__loadedTexture_185_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_185_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_186, context->m_internal.texture__loadedTexture_186_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_187, context->m_internal.texture__loadedTexture_187_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_187_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_188, context->m_internal.texture__loadedTexture_188_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_188_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_189, context->m_internal.texture__loadedTexture_189_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_189_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_190, context->m_internal.texture__loadedTexture_190_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_190_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_191, context->m_internal.texture__loadedTexture_191_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_191_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_192, context->m_internal.texture__loadedTexture_192_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_192_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_193, context->m_internal.texture__loadedTexture_193_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_193_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_194, context->m_internal.texture__loadedTexture_194_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_194_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_195, context->m_internal.texture__loadedTexture_195_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB, DXGI_FORMAT_UNKNOWN, DX12Utils::AccessType::CBV, DX12Utils::ResourceType::Buffer, false, 256, 1, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 22, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_internal.texture_GatherDOF_FarFieldColorCoC_size[0],
                context->m_internal.texture_GatherDOF_FarFieldColorCoC_size[1],
                context->m_internal.texture_GatherDOF_FarFieldColorCoC_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GatherDOF_FloodFillFar";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[1];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(1, barriers);
        }

        // Compute Shader: GatherDOF_DownscaleTileMap_1_4
        if(context->m_input.variable_GatherDOF_DoNearField)
        {
            ScopedPerfEvent scopedPerf("Compute Shader: GatherDOF_DownscaleTileMap_1_4", commandList, 17);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_4_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_internal.texture_GatherDOF_NearMaxCocTilemap, context->m_internal.texture_GatherDOF_NearMaxCocTilemap_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4, context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 2, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[0],
                context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[1],
                context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GatherDOF_DownscaleTileMap_1_4";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[2];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(2, barriers);
        }

        // Compute Shader: GatherDOF_DownscaleTileMap_1_8
        if(context->m_input.variable_GatherDOF_DoNearField)
        {
            ScopedPerfEvent scopedPerf("Compute Shader: GatherDOF_DownscaleTileMap_1_8", commandList, 20);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_GatherDOF_DownscaleTileMap_1_8_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4, context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8, context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 2, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[0],
                context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[1],
                context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GatherDOF_DownscaleTileMap_1_8";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[2];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(2, barriers);
        }

        // Compute Shader: GatherDOF_NearHalo
        if(context->m_input.variable_GatherDOF_DoNearField)
        {
            ScopedPerfEvent scopedPerf("Compute Shader: GatherDOF_NearHalo", commandList, 21);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_GatherDOF_NearHalo_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_GatherDOF_NearHalo_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8, context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo, context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 2, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[0],
                context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[1],
                context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GatherDOF_NearHalo";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[3];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_internal.texture_GatherDOF_NearFieldColorCoCBorder;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[2].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[2].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[2].Transition.pResource = context->m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred;
            barriers[2].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[2].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[2].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(3, barriers);
        }

        // Compute Shader: GatherDOF_NearBlur
        if(context->m_input.variable_GatherDOF_DoNearField)
        {
            ScopedPerfEvent scopedPerf("Compute Shader: GatherDOF_NearBlur", commandList, 25);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_GatherDOF_NearBlur_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_GatherDOF_NearBlur_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_internal.texture_GatherDOF_NearFieldColorCoCBorder, context->m_internal.texture_GatherDOF_NearFieldColorCoCBorder_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo, context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred, context->m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_179, context->m_internal.texture__loadedTexture_179_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_179_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_180, context->m_internal.texture__loadedTexture_180_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_180_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_181, context->m_internal.texture__loadedTexture_181_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_181_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_182, context->m_internal.texture__loadedTexture_182_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_182_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_183, context->m_internal.texture__loadedTexture_183_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_171, context->m_internal.texture__loadedTexture_171_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_171_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_184, context->m_internal.texture__loadedTexture_184_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_184_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_185, context->m_internal.texture__loadedTexture_185_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_185_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_186, context->m_internal.texture__loadedTexture_186_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_187, context->m_internal.texture__loadedTexture_187_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_187_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_188, context->m_internal.texture__loadedTexture_188_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_188_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_189, context->m_internal.texture__loadedTexture_189_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_189_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_190, context->m_internal.texture__loadedTexture_190_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_190_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_191, context->m_internal.texture__loadedTexture_191_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_191_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_192, context->m_internal.texture__loadedTexture_192_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_192_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_193, context->m_internal.texture__loadedTexture_193_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_193_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_194, context->m_internal.texture__loadedTexture_194_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_194_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_195, context->m_internal.texture__loadedTexture_195_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.constantBuffer__GatherDOF_NearBlurCB, DXGI_FORMAT_UNKNOWN, DX12Utils::AccessType::CBV, DX12Utils::ResourceType::Buffer, false, 256, 1, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 22, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_internal.texture_GatherDOF_NearFieldColorCoCBorder_size[0],
                context->m_internal.texture_GatherDOF_NearFieldColorCoCBorder_size[1],
                context->m_internal.texture_GatherDOF_NearFieldColorCoCBorder_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GatherDOF_NearBlur";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Shader Constants: _GatherDOF_FloodFillFarCS_1CB
        {
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB_cpu.GatherDOF_AnimateNoiseTextures = context->m_input.variable_GatherDOF_AnimateNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB_cpu.GatherDOF_DoFarFieldFloodFill = context->m_input.variable_GatherDOF_DoFarFieldFloodFill;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB_cpu.GatherDOF_DoNearFieldFloodFill = context->m_input.variable_GatherDOF_DoNearFieldFloodFill;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB_cpu.GatherDOF_FloodFillTapCount = context->m_input.variable_GatherDOF_FloodFillTapCount;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB_cpu.GatherDOF_FrameIndex = context->m_internal.variable_GatherDOF_FrameIndex;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB_cpu.GatherDOF_KernelSize = context->m_input.variable_GatherDOF_KernelSize;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB_cpu.GatherDOF_UseNoiseTextures = context->m_input.variable_GatherDOF_UseNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB_cpu.JitterNoiseTextures = context->m_input.variable_JitterNoiseTextures;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB_cpu.LensRNGExtend = (int)context->m_input.variable_LensRNGExtend;
            context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB_cpu.LensRNGSource = (int)context->m_input.variable_LensRNGSource;
            DX12Utils::CopyConstantsCPUToGPU(s_ubTracker, device, commandList, context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB, context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB_cpu, Context::LogFn);
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[2];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(2, barriers);
        }

        // Compute Shader: GatherDOF_FloodFillNear
        if(context->m_input.variable_GatherDOF_DoNearField)
        {
            ScopedPerfEvent scopedPerf("Compute Shader: GatherDOF_FloodFillNear", commandList, 27);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_GatherDOF_FloodFillNear_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_GatherDOF_FloodFillNear_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo, context->m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred, context->m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha, context->m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_179, context->m_internal.texture__loadedTexture_179_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_179_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_180, context->m_internal.texture__loadedTexture_180_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_180_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_181, context->m_internal.texture__loadedTexture_181_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_181_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_182, context->m_internal.texture__loadedTexture_182_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_182_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_183, context->m_internal.texture__loadedTexture_183_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_171, context->m_internal.texture__loadedTexture_171_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_171_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_184, context->m_internal.texture__loadedTexture_184_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_184_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_185, context->m_internal.texture__loadedTexture_185_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_185_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_186, context->m_internal.texture__loadedTexture_186_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_187, context->m_internal.texture__loadedTexture_187_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_187_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_188, context->m_internal.texture__loadedTexture_188_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_188_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_189, context->m_internal.texture__loadedTexture_189_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_189_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_190, context->m_internal.texture__loadedTexture_190_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_190_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_191, context->m_internal.texture__loadedTexture_191_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_191_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_192, context->m_internal.texture__loadedTexture_192_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_192_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_193, context->m_internal.texture__loadedTexture_193_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_193_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_194, context->m_internal.texture__loadedTexture_194_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2DArray, false, 0, context->m_internal.texture__loadedTexture_194_size[2], 0, 0, 0, false },
                { context->m_internal.texture__loadedTexture_195, context->m_internal.texture__loadedTexture_195_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB, DXGI_FORMAT_UNKNOWN, DX12Utils::AccessType::CBV, DX12Utils::ResourceType::Buffer, false, 256, 1, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 22, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_internal.texture_GatherDOF_FarFieldColorCoC_size[0],
                context->m_internal.texture_GatherDOF_FarFieldColorCoC_size[1],
                context->m_internal.texture_GatherDOF_FarFieldColorCoC_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GatherDOF_FloodFillNear";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[3];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_output.texture_GatherDOF_Output;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_SOURCE;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[2].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[2].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[2].Transition.pResource = context->m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha;
            barriers[2].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[2].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[2].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(3, barriers);
        }

        // Compute Shader: GatherDOF_Recombine
        {
            ScopedPerfEvent scopedPerf("Compute Shader: GatherDOF_Recombine", commandList, 29);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_GatherDOF_Recombine_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_GatherDOF_Recombine_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha, context->m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_ColorHDR, context->m_internal.texture_ColorHDR_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_LinearDepth, context->m_internal.texture_LinearDepth_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha, context->m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_output.texture_GatherDOF_Output, context->m_output.texture_GatherDOF_Output_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.constantBuffer__GatherDOF_RecombineCSCB, DXGI_FORMAT_UNKNOWN, DX12Utils::AccessType::CBV, DX12Utils::ResourceType::Buffer, false, 256, 1, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 6, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_output.texture_GatherDOF_Output_size[0],
                context->m_output.texture_GatherDOF_Output_size[1],
                context->m_output.texture_GatherDOF_Output_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GatherDOF_Recombine";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[2];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_internal.texture_ColorHDR;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_COPY_SOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_output.texture_GatherDOF_Output;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_COPY_DEST;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(2, barriers);
        }

        // Copy Resource: CopyHDR
        if(context->m_input.variable_DOF != DOFMode::PostProcessing)
        {
            ScopedPerfEvent scopedPerf("Copy Resource: CopyHDR", commandList, 4);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            // Copy the texture.
            commandList->CopyResource(context->m_output.texture_GatherDOF_Output, context->m_internal.texture_ColorHDR);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "CopyHDR";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[2];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_output.texture_GatherDOF_Output;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_output.texture_GaussBlur_Output;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(2, barriers);
        }

        // Compute Shader: GaussBlur_DoBlur
        if(!context->m_input.variable_GaussBlur_Disable)
        {
            ScopedPerfEvent scopedPerf("Compute Shader: GaussBlur_DoBlur", commandList, 30);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_GaussBlur_DoBlur_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_GaussBlur_DoBlur_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_output.texture_GatherDOF_Output, context->m_output.texture_GatherDOF_Output_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_output.texture_GaussBlur_Output, context->m_output.texture_GaussBlur_Output_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.constantBuffer__GaussBlur_GaussBlurCSCB, DXGI_FORMAT_UNKNOWN, DX12Utils::AccessType::CBV, DX12Utils::ResourceType::Buffer, false, 256, 1, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 3, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_output.texture_GatherDOF_Output_size[0],
                context->m_output.texture_GatherDOF_Output_size[1],
                context->m_output.texture_GatherDOF_Output_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GaussBlur_DoBlur";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[2];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_output.texture_GatherDOF_Output;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_COPY_SOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_output.texture_GaussBlur_Output;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_COPY_DEST;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(2, barriers);
        }

        // Copy Resource: GaussBlur_DontBlur
        if(context->m_input.variable_GaussBlur_Disable)
        {
            ScopedPerfEvent scopedPerf("Copy Resource: GaussBlur_DontBlur", commandList, 32);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            // Copy the texture.
            commandList->CopyResource(context->m_output.texture_GaussBlur_Output, context->m_output.texture_GatherDOF_Output);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "GaussBlur_DontBlur";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[2];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_output.texture_GaussBlur_Output;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].Transition.pResource = context->m_output.texture_TemporalAccumulation_Accum;
            barriers[1].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[1].Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[1].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            commandList->ResourceBarrier(2, barriers);
        }

        // Compute Shader: TemporalAccumulation_DoAccum
        {
            ScopedPerfEvent scopedPerf("Compute Shader: TemporalAccumulation_DoAccum", commandList, 33);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_TemporalAccumulation_DoAccum_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_TemporalAccumulation_DoAccum_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_output.texture_GaussBlur_Output, context->m_output.texture_GaussBlur_Output_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_output.texture_TemporalAccumulation_Accum, context->m_output.texture_TemporalAccumulation_Accum_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.constantBuffer__TemporalAccumulation_AccumulateCB, DXGI_FORMAT_UNKNOWN, DX12Utils::AccessType::CBV, DX12Utils::ResourceType::Buffer, false, 256, 1, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 3, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_output.texture_GaussBlur_Output_size[0],
                context->m_output.texture_GaussBlur_Output_size[1],
                context->m_output.texture_GaussBlur_Output_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "TemporalAccumulation_DoAccum";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Transition resources for the next action
        {
            D3D12_RESOURCE_BARRIER barriers[2];

            barriers[0].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
            barriers[0].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[0].Transition.pResource = context->m_output.texture_TemporalAccumulation_Accum;
            barriers[0].Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
            barriers[0].Transition.StateAfter = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
            barriers[0].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

            barriers[1].Type = D3D12_RESOURCE_BARRIER_TYPE_UAV;
            barriers[1].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
            barriers[1].UAV.pResource = context->m_output.texture_ToneMap_Color_SDR;

            commandList->ResourceBarrier(2, barriers);
        }

        // Compute Shader: ToneMap_Tonemap
        {
            ScopedPerfEvent scopedPerf("Compute Shader: ToneMap_Tonemap", commandList, 36);
            std::chrono::high_resolution_clock::time_point startPointCPU;
            if(context->m_profile)
            {
                startPointCPU = std::chrono::high_resolution_clock::now();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }

            commandList->SetComputeRootSignature(ContextInternal::computeShader_ToneMap_Tonemap_rootSig);
            commandList->SetPipelineState(ContextInternal::computeShader_ToneMap_Tonemap_pso);

            DX12Utils::ResourceDescriptor descriptors[] = {
                { context->m_output.texture_TemporalAccumulation_Accum, context->m_output.texture_TemporalAccumulation_Accum_format, DX12Utils::AccessType::SRV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_output.texture_ToneMap_Color_SDR, context->m_output.texture_ToneMap_Color_SDR_format, DX12Utils::AccessType::UAV, DX12Utils::ResourceType::Texture2D, false, 0, 0, 0, 0, 0, false },
                { context->m_internal.constantBuffer__ToneMap_TonemapCB, DXGI_FORMAT_UNKNOWN, DX12Utils::AccessType::CBV, DX12Utils::ResourceType::Buffer, false, 256, 1, 0, 0, 0, false }
            };

            D3D12_GPU_DESCRIPTOR_HANDLE descriptorTable = GetDescriptorTable(device, s_srvHeap, descriptors, 3, Context::LogFn);
            commandList->SetComputeRootDescriptorTable(0, descriptorTable);

            unsigned int baseDispatchSize[3] = {
                context->m_output.texture_TemporalAccumulation_Accum_size[0],
                context->m_output.texture_TemporalAccumulation_Accum_size[1],
                context->m_output.texture_TemporalAccumulation_Accum_size[2]
            };

            unsigned int dispatchSize[3] = {
                (((baseDispatchSize[0] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[1] + 0) * 1) / 1 + 0 + 8 - 1) / 8,
                (((baseDispatchSize[2] + 0) * 1) / 1 + 0 + 1 - 1) / 1
            };

            commandList->Dispatch(dispatchSize[0], dispatchSize[1], dispatchSize[2]);

            if(context->m_profile)
            {
                context->m_profileData[(s_timerIndex-1)/2].m_label = "ToneMap_Tonemap";
                context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPU).count();
                commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            }
        }

        // Make sure imported resources are put back in the state they were given to us in
        {
            int barrierCount = 0;
            D3D12_RESOURCE_BARRIER barriers[2];

            if(context->m_input.buffer_Scene_state != D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE)
            {
                barriers[barrierCount].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
                barriers[barrierCount].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
                barriers[barrierCount].Transition.pResource = context->m_input.buffer_Scene;
                barriers[barrierCount].Transition.StateBefore = D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE;
                barriers[barrierCount].Transition.StateAfter = context->m_input.buffer_Scene_state;
                barriers[barrierCount].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
                barrierCount++;
            }

            if(context->m_input.buffer_VertexBuffer_state != D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE)
            {
                barriers[barrierCount].Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
                barriers[barrierCount].Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
                barriers[barrierCount].Transition.pResource = context->m_input.buffer_VertexBuffer;
                barriers[barrierCount].Transition.StateBefore = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE;
                barriers[barrierCount].Transition.StateAfter = context->m_input.buffer_VertexBuffer_state;
                barriers[barrierCount].Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
                barrierCount++;
            }

            if(barrierCount > 0)
                commandList->ResourceBarrier(barrierCount, barriers);
        }

        if(context->m_profile)
        {
            context->m_profileData[(s_timerIndex-1)/2].m_label = "Total";
            context->m_profileData[(s_timerIndex-1)/2].m_cpu = (float)std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::high_resolution_clock::now() - startPointCPUTechnique).count();
            commandList->EndQuery(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, s_timerIndex++);
            commandList->ResolveQueryData(context->m_internal.m_TimestampQueryHeap, D3D12_QUERY_TYPE_TIMESTAMP, 0, s_timerIndex, context->m_internal.m_TimestampReadbackBuffer, 0);
        }

        dxrDevice->Release();
        dxrCommandList->Release();

        // Set variables
        context->m_internal.variable_GatherDOF_FrameIndex = context->m_internal.variable_GatherDOF_FrameIndex + 1;
        context->m_internal.variable_GatherDOF_FrameIndex = context->m_internal.variable_GatherDOF_FrameIndex % 65536;
    }

    void Context::EnsureResourcesCreated(ID3D12Device* device, ID3D12GraphicsCommandList* commandList)
    {
        bool dirty = false;

        // ColorHDR
        {

            unsigned int baseSize[3] = { (unsigned int)m_input.variable_RenderSize[0], (unsigned int)m_input.variable_RenderSize[1], 1 };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 1 + 0,
                ((baseSize[1] + 0) * 1) / 1 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R32G32B32A32_FLOAT;

            if(!m_internal.texture_ColorHDR ||
               m_internal.texture_ColorHDR_size[0] != desiredSize[0] ||
               m_internal.texture_ColorHDR_size[1] != desiredSize[1] ||
               m_internal.texture_ColorHDR_size[2] != desiredSize[2] ||
               m_internal.texture_ColorHDR_numMips != desiredNumMips ||
               m_internal.texture_ColorHDR_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_ColorHDR)
                    s_delayedRelease.Add(m_internal.texture_ColorHDR);

                m_internal.texture_ColorHDR = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_ColorHDR_flags, D3D12_RESOURCE_STATE_COPY_SOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"ColorHDR" : nullptr), Context::LogFn);
                m_internal.texture_ColorHDR_size[0] = desiredSize[0];
                m_internal.texture_ColorHDR_size[1] = desiredSize[1];
                m_internal.texture_ColorHDR_size[2] = desiredSize[2];
                m_internal.texture_ColorHDR_numMips = desiredNumMips;
                m_internal.texture_ColorHDR_format = desiredFormat;
            }
        }

        // PixelDebug
        {
            unsigned int baseCount = 1;
            unsigned int desiredCount = ((baseCount + 0 ) * 1) / 1 + 0;
            DXGI_FORMAT desiredFormat = DXGI_FORMAT_UNKNOWN;
            unsigned int desiredStride = 40;

            if(!m_internal.buffer_PixelDebug ||
               m_internal.buffer_PixelDebug_count != desiredCount ||
               m_internal.buffer_PixelDebug_format != desiredFormat ||
               m_internal.buffer_PixelDebug_stride != desiredStride)
            {
                dirty = true;
                if(m_internal.buffer_PixelDebug)
                    s_delayedRelease.Add(m_internal.buffer_PixelDebug);

                unsigned int desiredSize = desiredCount * ((desiredStride > 0) ? desiredStride : DX12Utils::Get_DXGI_FORMAT_Info(desiredFormat, Context::LogFn).bytesPerPixel);

                m_internal.buffer_PixelDebug = DX12Utils::CreateBuffer(device, desiredSize, m_internal.c_buffer_PixelDebug_flags, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_DEFAULT, (c_debugNames ? L"PixelDebug" : nullptr), Context::LogFn);
                m_internal.buffer_PixelDebug_count = desiredCount;
                m_internal.buffer_PixelDebug_format = desiredFormat;
                m_internal.buffer_PixelDebug_stride = desiredStride;
            }
        }

        // LinearDepth
        {

            unsigned int baseSize[3] = { (unsigned int)m_input.variable_RenderSize[0], (unsigned int)m_input.variable_RenderSize[1], 1 };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 1 + 0,
                ((baseSize[1] + 0) * 1) / 1 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R32_FLOAT;

            if(!m_internal.texture_LinearDepth ||
               m_internal.texture_LinearDepth_size[0] != desiredSize[0] ||
               m_internal.texture_LinearDepth_size[1] != desiredSize[1] ||
               m_internal.texture_LinearDepth_size[2] != desiredSize[2] ||
               m_internal.texture_LinearDepth_numMips != desiredNumMips ||
               m_internal.texture_LinearDepth_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_LinearDepth)
                    s_delayedRelease.Add(m_internal.texture_LinearDepth);

                m_internal.texture_LinearDepth = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_LinearDepth_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"LinearDepth" : nullptr), Context::LogFn);
                m_internal.texture_LinearDepth_size[0] = desiredSize[0];
                m_internal.texture_LinearDepth_size[1] = desiredSize[1];
                m_internal.texture_LinearDepth_size[2] = desiredSize[2];
                m_internal.texture_LinearDepth_numMips = desiredNumMips;
                m_internal.texture_LinearDepth_format = desiredFormat;
            }
        }

        // DebugTex
        {
            unsigned int baseSize[3] = {
                m_internal.texture_ColorHDR_size[0],
                m_internal.texture_ColorHDR_size[1],
                m_internal.texture_ColorHDR_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 1 + 0,
                ((baseSize[1] + 0) * 1) / 1 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R32_FLOAT;

            if(!m_internal.texture_DebugTex ||
               m_internal.texture_DebugTex_size[0] != desiredSize[0] ||
               m_internal.texture_DebugTex_size[1] != desiredSize[1] ||
               m_internal.texture_DebugTex_size[2] != desiredSize[2] ||
               m_internal.texture_DebugTex_numMips != desiredNumMips ||
               m_internal.texture_DebugTex_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_DebugTex)
                    s_delayedRelease.Add(m_internal.texture_DebugTex);

                m_internal.texture_DebugTex = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_DebugTex_flags, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"DebugTex" : nullptr), Context::LogFn);
                m_internal.texture_DebugTex_size[0] = desiredSize[0];
                m_internal.texture_DebugTex_size[1] = desiredSize[1];
                m_internal.texture_DebugTex_size[2] = desiredSize[2];
                m_internal.texture_DebugTex_numMips = desiredNumMips;
                m_internal.texture_DebugTex_format = desiredFormat;
            }
        }

        // GatherDOF_Output
        {
            unsigned int baseSize[3] = {
                m_internal.texture_ColorHDR_size[0],
                m_internal.texture_ColorHDR_size[1],
                m_internal.texture_ColorHDR_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 1 + 0,
                ((baseSize[1] + 0) * 1) / 1 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = m_internal.texture_ColorHDR_format;

            if(!m_output.texture_GatherDOF_Output ||
               m_output.texture_GatherDOF_Output_size[0] != desiredSize[0] ||
               m_output.texture_GatherDOF_Output_size[1] != desiredSize[1] ||
               m_output.texture_GatherDOF_Output_size[2] != desiredSize[2] ||
               m_output.texture_GatherDOF_Output_numMips != desiredNumMips ||
               m_output.texture_GatherDOF_Output_format != desiredFormat)
            {
                dirty = true;
                if(m_output.texture_GatherDOF_Output)
                    s_delayedRelease.Add(m_output.texture_GatherDOF_Output);

                m_output.texture_GatherDOF_Output = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_output.texture_GatherDOF_Output_flags, D3D12_RESOURCE_STATE_COPY_SOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_Output" : nullptr), Context::LogFn);
                m_output.texture_GatherDOF_Output_size[0] = desiredSize[0];
                m_output.texture_GatherDOF_Output_size[1] = desiredSize[1];
                m_output.texture_GatherDOF_Output_size[2] = desiredSize[2];
                m_output.texture_GatherDOF_Output_numMips = desiredNumMips;
                m_output.texture_GatherDOF_Output_format = desiredFormat;
            }
        }

        // GatherDOF_FarFieldColorCoC
        {
            unsigned int baseSize[3] = {
                m_internal.texture_ColorHDR_size[0],
                m_internal.texture_ColorHDR_size[1],
                m_internal.texture_ColorHDR_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 2 + 0,
                ((baseSize[1] + 0) * 1) / 2 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R32G32B32A32_FLOAT;

            if(!m_internal.texture_GatherDOF_FarFieldColorCoC ||
               m_internal.texture_GatherDOF_FarFieldColorCoC_size[0] != desiredSize[0] ||
               m_internal.texture_GatherDOF_FarFieldColorCoC_size[1] != desiredSize[1] ||
               m_internal.texture_GatherDOF_FarFieldColorCoC_size[2] != desiredSize[2] ||
               m_internal.texture_GatherDOF_FarFieldColorCoC_numMips != desiredNumMips ||
               m_internal.texture_GatherDOF_FarFieldColorCoC_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_GatherDOF_FarFieldColorCoC)
                    s_delayedRelease.Add(m_internal.texture_GatherDOF_FarFieldColorCoC);

                m_internal.texture_GatherDOF_FarFieldColorCoC = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_GatherDOF_FarFieldColorCoC_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_FarFieldColorCoC" : nullptr), Context::LogFn);
                m_internal.texture_GatherDOF_FarFieldColorCoC_size[0] = desiredSize[0];
                m_internal.texture_GatherDOF_FarFieldColorCoC_size[1] = desiredSize[1];
                m_internal.texture_GatherDOF_FarFieldColorCoC_size[2] = desiredSize[2];
                m_internal.texture_GatherDOF_FarFieldColorCoC_numMips = desiredNumMips;
                m_internal.texture_GatherDOF_FarFieldColorCoC_format = desiredFormat;
            }
        }

        // GatherDOF_NearFieldColorCoC
        {
            unsigned int baseSize[3] = {
                m_internal.texture_ColorHDR_size[0],
                m_internal.texture_ColorHDR_size[1],
                m_internal.texture_ColorHDR_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 2 + 0,
                ((baseSize[1] + 0) * 1) / 2 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R32G32B32A32_FLOAT;

            if(!m_internal.texture_GatherDOF_NearFieldColorCoC ||
               m_internal.texture_GatherDOF_NearFieldColorCoC_size[0] != desiredSize[0] ||
               m_internal.texture_GatherDOF_NearFieldColorCoC_size[1] != desiredSize[1] ||
               m_internal.texture_GatherDOF_NearFieldColorCoC_size[2] != desiredSize[2] ||
               m_internal.texture_GatherDOF_NearFieldColorCoC_numMips != desiredNumMips ||
               m_internal.texture_GatherDOF_NearFieldColorCoC_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_GatherDOF_NearFieldColorCoC)
                    s_delayedRelease.Add(m_internal.texture_GatherDOF_NearFieldColorCoC);

                m_internal.texture_GatherDOF_NearFieldColorCoC = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_GatherDOF_NearFieldColorCoC_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_NearFieldColorCoC" : nullptr), Context::LogFn);
                m_internal.texture_GatherDOF_NearFieldColorCoC_size[0] = desiredSize[0];
                m_internal.texture_GatherDOF_NearFieldColorCoC_size[1] = desiredSize[1];
                m_internal.texture_GatherDOF_NearFieldColorCoC_size[2] = desiredSize[2];
                m_internal.texture_GatherDOF_NearFieldColorCoC_numMips = desiredNumMips;
                m_internal.texture_GatherDOF_NearFieldColorCoC_format = desiredFormat;
            }
        }

        // GatherDOF_NearMaxCocTilemap
        {
            unsigned int baseSize[3] = {
                m_internal.texture_ColorHDR_size[0],
                m_internal.texture_ColorHDR_size[1],
                m_internal.texture_ColorHDR_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 2 + 0,
                ((baseSize[1] + 0) * 1) / 2 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R8_UNORM;

            if(!m_internal.texture_GatherDOF_NearMaxCocTilemap ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_size[0] != desiredSize[0] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_size[1] != desiredSize[1] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_size[2] != desiredSize[2] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_numMips != desiredNumMips ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_GatherDOF_NearMaxCocTilemap)
                    s_delayedRelease.Add(m_internal.texture_GatherDOF_NearMaxCocTilemap);

                m_internal.texture_GatherDOF_NearMaxCocTilemap = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_GatherDOF_NearMaxCocTilemap_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_NearMaxCocTilemap" : nullptr), Context::LogFn);
                m_internal.texture_GatherDOF_NearMaxCocTilemap_size[0] = desiredSize[0];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_size[1] = desiredSize[1];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_size[2] = desiredSize[2];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_numMips = desiredNumMips;
                m_internal.texture_GatherDOF_NearMaxCocTilemap_format = desiredFormat;
            }
        }

        // GatherDOF_BlurredFarFieldColorAlpha
        {
            unsigned int baseSize[3] = {
                m_internal.texture_ColorHDR_size[0],
                m_internal.texture_ColorHDR_size[1],
                m_internal.texture_ColorHDR_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 2 + 0,
                ((baseSize[1] + 0) * 1) / 2 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R32G32B32A32_FLOAT;

            if(!m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha ||
               m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_size[0] != desiredSize[0] ||
               m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_size[1] != desiredSize[1] ||
               m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_size[2] != desiredSize[2] ||
               m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_numMips != desiredNumMips ||
               m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha)
                    s_delayedRelease.Add(m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha);

                m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_BlurredFarFieldColorAlpha" : nullptr), Context::LogFn);
                m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_size[0] = desiredSize[0];
                m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_size[1] = desiredSize[1];
                m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_size[2] = desiredSize[2];
                m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_numMips = desiredNumMips;
                m_internal.texture_GatherDOF_BlurredFarFieldColorAlpha_format = desiredFormat;
            }
        }

        // GatherDOF_FloodFilledBlurredFarFieldColorAlpha
        {
            unsigned int baseSize[3] = {
                m_internal.texture_ColorHDR_size[0],
                m_internal.texture_ColorHDR_size[1],
                m_internal.texture_ColorHDR_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 2 + 0,
                ((baseSize[1] + 0) * 1) / 2 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R32G32B32A32_FLOAT;

            if(!m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha ||
               m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_size[0] != desiredSize[0] ||
               m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_size[1] != desiredSize[1] ||
               m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_size[2] != desiredSize[2] ||
               m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_numMips != desiredNumMips ||
               m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha)
                    s_delayedRelease.Add(m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha);

                m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_FloodFilledBlurredFarFieldColorAlpha" : nullptr), Context::LogFn);
                m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_size[0] = desiredSize[0];
                m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_size[1] = desiredSize[1];
                m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_size[2] = desiredSize[2];
                m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_numMips = desiredNumMips;
                m_internal.texture_GatherDOF_FloodFilledBlurredFarFieldColorAlpha_format = desiredFormat;
            }
        }

        // GatherDOF_NearMaxCocTilemap_1_4
        {
            unsigned int baseSize[3] = {
                m_internal.texture_GatherDOF_NearMaxCocTilemap_size[0],
                m_internal.texture_GatherDOF_NearMaxCocTilemap_size[1],
                m_internal.texture_GatherDOF_NearMaxCocTilemap_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 2 + 0,
                ((baseSize[1] + 0) * 1) / 2 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R8_UNORM;

            if(!m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4 ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[0] != desiredSize[0] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[1] != desiredSize[1] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[2] != desiredSize[2] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_numMips != desiredNumMips ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4)
                    s_delayedRelease.Add(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4);

                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4 = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_NearMaxCocTilemap_1_4" : nullptr), Context::LogFn);
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[0] = desiredSize[0];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[1] = desiredSize[1];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[2] = desiredSize[2];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_numMips = desiredNumMips;
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_format = desiredFormat;
            }
        }

        // GatherDOF_NearMaxCocTilemap_1_8
        {
            unsigned int baseSize[3] = {
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[0],
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[1],
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_4_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 2 + 0,
                ((baseSize[1] + 0) * 1) / 2 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R8_UNORM;

            if(!m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8 ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[0] != desiredSize[0] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[1] != desiredSize[1] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[2] != desiredSize[2] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_numMips != desiredNumMips ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8)
                    s_delayedRelease.Add(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8);

                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8 = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_NearMaxCocTilemap_1_8" : nullptr), Context::LogFn);
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[0] = desiredSize[0];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[1] = desiredSize[1];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[2] = desiredSize[2];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_numMips = desiredNumMips;
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_format = desiredFormat;
            }
        }

        // GatherDOF_NearMaxCocTilemap_1_8_Halo
        {
            unsigned int baseSize[3] = {
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[0],
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[1],
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 1 + 0,
                ((baseSize[1] + 0) * 1) / 1 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_format;

            if(!m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_size[0] != desiredSize[0] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_size[1] != desiredSize[1] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_size[2] != desiredSize[2] ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_numMips != desiredNumMips ||
               m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo)
                    s_delayedRelease.Add(m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo);

                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_NearMaxCocTilemap_1_8_Halo" : nullptr), Context::LogFn);
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_size[0] = desiredSize[0];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_size[1] = desiredSize[1];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_size[2] = desiredSize[2];
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_numMips = desiredNumMips;
                m_internal.texture_GatherDOF_NearMaxCocTilemap_1_8_Halo_format = desiredFormat;
            }
        }

        // GatherDOF_NearFieldColorCoCBorder
        {
            unsigned int baseSize[3] = {
                m_internal.texture_ColorHDR_size[0],
                m_internal.texture_ColorHDR_size[1],
                m_internal.texture_ColorHDR_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 2 + 0,
                ((baseSize[1] + 0) * 1) / 2 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R32G32B32A32_FLOAT;

            if(!m_internal.texture_GatherDOF_NearFieldColorCoCBorder ||
               m_internal.texture_GatherDOF_NearFieldColorCoCBorder_size[0] != desiredSize[0] ||
               m_internal.texture_GatherDOF_NearFieldColorCoCBorder_size[1] != desiredSize[1] ||
               m_internal.texture_GatherDOF_NearFieldColorCoCBorder_size[2] != desiredSize[2] ||
               m_internal.texture_GatherDOF_NearFieldColorCoCBorder_numMips != desiredNumMips ||
               m_internal.texture_GatherDOF_NearFieldColorCoCBorder_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_GatherDOF_NearFieldColorCoCBorder)
                    s_delayedRelease.Add(m_internal.texture_GatherDOF_NearFieldColorCoCBorder);

                m_internal.texture_GatherDOF_NearFieldColorCoCBorder = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_GatherDOF_NearFieldColorCoCBorder_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_NearFieldColorCoCBorder" : nullptr), Context::LogFn);
                m_internal.texture_GatherDOF_NearFieldColorCoCBorder_size[0] = desiredSize[0];
                m_internal.texture_GatherDOF_NearFieldColorCoCBorder_size[1] = desiredSize[1];
                m_internal.texture_GatherDOF_NearFieldColorCoCBorder_size[2] = desiredSize[2];
                m_internal.texture_GatherDOF_NearFieldColorCoCBorder_numMips = desiredNumMips;
                m_internal.texture_GatherDOF_NearFieldColorCoCBorder_format = desiredFormat;
            }
        }

        // GatherDOF_NearFieldColorCoCBorderBlurred
        {
            unsigned int baseSize[3] = {
                m_internal.texture_ColorHDR_size[0],
                m_internal.texture_ColorHDR_size[1],
                m_internal.texture_ColorHDR_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 2 + 0,
                ((baseSize[1] + 0) * 1) / 2 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R32G32B32A32_FLOAT;

            if(!m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred ||
               m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_size[0] != desiredSize[0] ||
               m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_size[1] != desiredSize[1] ||
               m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_size[2] != desiredSize[2] ||
               m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_numMips != desiredNumMips ||
               m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred)
                    s_delayedRelease.Add(m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred);

                m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_NearFieldColorCoCBorderBlurred" : nullptr), Context::LogFn);
                m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_size[0] = desiredSize[0];
                m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_size[1] = desiredSize[1];
                m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_size[2] = desiredSize[2];
                m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_numMips = desiredNumMips;
                m_internal.texture_GatherDOF_NearFieldColorCoCBorderBlurred_format = desiredFormat;
            }
        }

        // GatherDOF_FloodFilledBlurredNearFieldColorAlpha
        {
            unsigned int baseSize[3] = {
                m_internal.texture_ColorHDR_size[0],
                m_internal.texture_ColorHDR_size[1],
                m_internal.texture_ColorHDR_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 2 + 0,
                ((baseSize[1] + 0) * 1) / 2 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R32G32B32A32_FLOAT;

            if(!m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha ||
               m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_size[0] != desiredSize[0] ||
               m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_size[1] != desiredSize[1] ||
               m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_size[2] != desiredSize[2] ||
               m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_numMips != desiredNumMips ||
               m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_format != desiredFormat)
            {
                dirty = true;
                if(m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha)
                    s_delayedRelease.Add(m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha);

                m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GatherDOF_FloodFilledBlurredNearFieldColorAlpha" : nullptr), Context::LogFn);
                m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_size[0] = desiredSize[0];
                m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_size[1] = desiredSize[1];
                m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_size[2] = desiredSize[2];
                m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_numMips = desiredNumMips;
                m_internal.texture_GatherDOF_FloodFilledBlurredNearFieldColorAlpha_format = desiredFormat;
            }
        }

        // GaussBlur_Output
        {
            unsigned int baseSize[3] = {
                m_output.texture_GatherDOF_Output_size[0],
                m_output.texture_GatherDOF_Output_size[1],
                m_output.texture_GatherDOF_Output_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 1 + 0,
                ((baseSize[1] + 0) * 1) / 1 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = m_output.texture_GatherDOF_Output_format;

            if(!m_output.texture_GaussBlur_Output ||
               m_output.texture_GaussBlur_Output_size[0] != desiredSize[0] ||
               m_output.texture_GaussBlur_Output_size[1] != desiredSize[1] ||
               m_output.texture_GaussBlur_Output_size[2] != desiredSize[2] ||
               m_output.texture_GaussBlur_Output_numMips != desiredNumMips ||
               m_output.texture_GaussBlur_Output_format != desiredFormat)
            {
                dirty = true;
                if(m_output.texture_GaussBlur_Output)
                    s_delayedRelease.Add(m_output.texture_GaussBlur_Output);

                m_output.texture_GaussBlur_Output = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_output.texture_GaussBlur_Output_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"GaussBlur_Output" : nullptr), Context::LogFn);
                m_output.texture_GaussBlur_Output_size[0] = desiredSize[0];
                m_output.texture_GaussBlur_Output_size[1] = desiredSize[1];
                m_output.texture_GaussBlur_Output_size[2] = desiredSize[2];
                m_output.texture_GaussBlur_Output_numMips = desiredNumMips;
                m_output.texture_GaussBlur_Output_format = desiredFormat;
            }
        }

        // TemporalAccumulation_Accum
        {
            unsigned int baseSize[3] = {
                m_output.texture_GaussBlur_Output_size[0],
                m_output.texture_GaussBlur_Output_size[1],
                m_output.texture_GaussBlur_Output_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 1 + 0,
                ((baseSize[1] + 0) * 1) / 1 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = m_output.texture_GaussBlur_Output_format;

            if(!m_output.texture_TemporalAccumulation_Accum ||
               m_output.texture_TemporalAccumulation_Accum_size[0] != desiredSize[0] ||
               m_output.texture_TemporalAccumulation_Accum_size[1] != desiredSize[1] ||
               m_output.texture_TemporalAccumulation_Accum_size[2] != desiredSize[2] ||
               m_output.texture_TemporalAccumulation_Accum_numMips != desiredNumMips ||
               m_output.texture_TemporalAccumulation_Accum_format != desiredFormat)
            {
                dirty = true;
                if(m_output.texture_TemporalAccumulation_Accum)
                    s_delayedRelease.Add(m_output.texture_TemporalAccumulation_Accum);

                m_output.texture_TemporalAccumulation_Accum = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_output.texture_TemporalAccumulation_Accum_flags, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"TemporalAccumulation_Accum" : nullptr), Context::LogFn);
                m_output.texture_TemporalAccumulation_Accum_size[0] = desiredSize[0];
                m_output.texture_TemporalAccumulation_Accum_size[1] = desiredSize[1];
                m_output.texture_TemporalAccumulation_Accum_size[2] = desiredSize[2];
                m_output.texture_TemporalAccumulation_Accum_numMips = desiredNumMips;
                m_output.texture_TemporalAccumulation_Accum_format = desiredFormat;
            }
        }

        // ToneMap_Color_SDR
        {
            unsigned int baseSize[3] = {
                m_output.texture_TemporalAccumulation_Accum_size[0],
                m_output.texture_TemporalAccumulation_Accum_size[1],
                m_output.texture_TemporalAccumulation_Accum_size[2]
            };

            unsigned int desiredSize[3] = {
                ((baseSize[0] + 0) * 1) / 1 + 0,
                ((baseSize[1] + 0) * 1) / 1 + 0,
                ((baseSize[2] + 0) * 1) / 1 + 0
            };

            static const unsigned int desiredNumMips = 1;

            DXGI_FORMAT desiredFormat = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;

            if(!m_output.texture_ToneMap_Color_SDR ||
               m_output.texture_ToneMap_Color_SDR_size[0] != desiredSize[0] ||
               m_output.texture_ToneMap_Color_SDR_size[1] != desiredSize[1] ||
               m_output.texture_ToneMap_Color_SDR_size[2] != desiredSize[2] ||
               m_output.texture_ToneMap_Color_SDR_numMips != desiredNumMips ||
               m_output.texture_ToneMap_Color_SDR_format != desiredFormat)
            {
                dirty = true;
                if(m_output.texture_ToneMap_Color_SDR)
                    s_delayedRelease.Add(m_output.texture_ToneMap_Color_SDR);

                m_output.texture_ToneMap_Color_SDR = DX12Utils::CreateTexture(device, desiredSize, desiredNumMips, desiredFormat, m_output.texture_ToneMap_Color_SDR_flags, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"ToneMap_Color_SDR" : nullptr), Context::LogFn);
                m_output.texture_ToneMap_Color_SDR_size[0] = desiredSize[0];
                m_output.texture_ToneMap_Color_SDR_size[1] = desiredSize[1];
                m_output.texture_ToneMap_Color_SDR_size[2] = desiredSize[2];
                m_output.texture_ToneMap_Color_SDR_numMips = desiredNumMips;
                m_output.texture_ToneMap_Color_SDR_format = desiredFormat;
            }
        }

        // _loadedTexture_0
        {
            if (!m_internal.texture__loadedTexture_0)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_Curbstones_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_Curbstones_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_Curbstones_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_0_size[0] = size[0];
                m_internal.texture__loadedTexture_0_size[1] = size[1];
                m_internal.texture__loadedTexture_0_size[2] = size[2];
                m_internal.texture__loadedTexture_0_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_0_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_0 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_0_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_0" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_0, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_1
        {
            if (!m_internal.texture__loadedTexture_1)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Pavement_Cobblestone_Small_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Pavement_Cobblestone_Small_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Pavement_Cobblestone_Small_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_1_size[0] = size[0];
                m_internal.texture__loadedTexture_1_size[1] = size[1];
                m_internal.texture__loadedTexture_1_size[2] = size[2];
                m_internal.texture__loadedTexture_1_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_1_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_1 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_1_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_1" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_1, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_2
        {
            if (!m_internal.texture__loadedTexture_2)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Pavement_Cobblestone_Big_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Pavement_Cobblestone_Big_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Pavement_Cobblestone_Big_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_2_size[0] = size[0];
                m_internal.texture__loadedTexture_2_size[1] = size[1];
                m_internal.texture__loadedTexture_2_size[2] = size[2];
                m_internal.texture__loadedTexture_2_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_2_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_2 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_2_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_2" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_2, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_3
        {
            if (!m_internal.texture__loadedTexture_3)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Pavement_Cobblestone_03_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Pavement_Cobblestone_03_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Pavement_Cobblestone_03_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_3_size[0] = size[0];
                m_internal.texture__loadedTexture_3_size[1] = size[1];
                m_internal.texture__loadedTexture_3_size[2] = size[2];
                m_internal.texture__loadedTexture_3_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_3_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_3 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_3_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_3" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_3, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_4
        {
            if (!m_internal.texture__loadedTexture_4)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Pavement_Brick_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Pavement_Brick_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Pavement_Brick_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_4_size[0] = size[0];
                m_internal.texture__loadedTexture_4_size[1] = size[1];
                m_internal.texture__loadedTexture_4_size[2] = size[2];
                m_internal.texture__loadedTexture_4_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_4_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_4 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_4_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_4" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_4, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_5
        {
            if (!m_internal.texture__loadedTexture_5)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Ground_Wet_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Ground_Wet_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Ground_Wet_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_5_size[0] = size[0];
                m_internal.texture__loadedTexture_5_size[1] = size[1];
                m_internal.texture__loadedTexture_5_size[2] = size[2];
                m_internal.texture__loadedTexture_5_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_5_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_5 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_5_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_5" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_5, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_6
        {
            if (!m_internal.texture__loadedTexture_6)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_manholecover_01b_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_manholecover_01b_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_manholecover_01b_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_6_size[0] = size[0];
                m_internal.texture__loadedTexture_6_size[1] = size[1];
                m_internal.texture__loadedTexture_6_size[2] = size[2];
                m_internal.texture__loadedTexture_6_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_6_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_6 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_6_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_6" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_6, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_7
        {
            if (!m_internal.texture__loadedTexture_7)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Cobble_02B_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Cobble_02B_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Cobble_02B_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_7_size[0] = size[0];
                m_internal.texture__loadedTexture_7_size[1] = size[1];
                m_internal.texture__loadedTexture_7_size[2] = size[2];
                m_internal.texture__loadedTexture_7_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_7_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_7 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_7_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_7" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_7, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_8
        {
            if (!m_internal.texture__loadedTexture_8)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Pavement_Cobblestone_01_b_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Pavement_Cobblestone_01_b_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Pavement_Cobblestone_01_b_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_8_size[0] = size[0];
                m_internal.texture__loadedTexture_8_size[1] = size[1];
                m_internal.texture__loadedTexture_8_size[2] = size[2];
                m_internal.texture__loadedTexture_8_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_8_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_8 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_8_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_8" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_8, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_9
        {
            if (!m_internal.texture__loadedTexture_9)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Brick_Small_03_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Brick_Small_03_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Brick_Small_03_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_9_size[0] = size[0];
                m_internal.texture__loadedTexture_9_size[1] = size[1];
                m_internal.texture__loadedTexture_9_size[2] = size[2];
                m_internal.texture__loadedTexture_9_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_9_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_9 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_9_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_9" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_9, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_10
        {
            if (!m_internal.texture__loadedTexture_10)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\concrete_smooth_02_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\concrete_smooth_02_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\concrete_smooth_02_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_10_size[0] = size[0];
                m_internal.texture__loadedTexture_10_size[1] = size[1];
                m_internal.texture__loadedTexture_10_size[2] = size[2];
                m_internal.texture__loadedTexture_10_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_10_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_10 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_10_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_10" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_10, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_11
        {
            if (!m_internal.texture__loadedTexture_11)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\paris_bistroexteriorspotlight_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\paris_bistroexteriorspotlight_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\paris_bistroexteriorspotlight_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_11_size[0] = size[0];
                m_internal.texture__loadedTexture_11_size[1] = size[1];
                m_internal.texture__loadedTexture_11_size[2] = size[2];
                m_internal.texture__loadedTexture_11_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_11_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_11 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_11_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_11" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_11, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_12
        {
            if (!m_internal.texture__loadedTexture_12)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Metal_Chrome_01_tint_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Metal_Chrome_01_tint_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Metal_Chrome_01_tint_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_12_size[0] = size[0];
                m_internal.texture__loadedTexture_12_size[1] = size[1];
                m_internal.texture__loadedTexture_12_size[2] = size[2];
                m_internal.texture__loadedTexture_12_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_12_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_12 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_12_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_12" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_12, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_13
        {
            if (!m_internal.texture__loadedTexture_13)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_BistroExteriorSpotLightGlass_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_BistroExteriorSpotLightGlass_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_BistroExteriorSpotLightGlass_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_13_size[0] = size[0];
                m_internal.texture__loadedTexture_13_size[1] = size[1];
                m_internal.texture__loadedTexture_13_size[2] = size[2];
                m_internal.texture__loadedTexture_13_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_13_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_13 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_13_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_13" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_13, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_14
        {
            if (!m_internal.texture__loadedTexture_14)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\bistro_woodpanelornament_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\bistro_woodpanelornament_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\bistro_woodpanelornament_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_14_size[0] = size[0];
                m_internal.texture__loadedTexture_14_size[1] = size[1];
                m_internal.texture__loadedTexture_14_size[2] = size[2];
                m_internal.texture__loadedTexture_14_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_14_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_14 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_14_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_14" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_14, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_15
        {
            if (!m_internal.texture__loadedTexture_15)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Bistro_main_door_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Bistro_main_door_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Bistro_main_door_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_15_size[0] = size[0];
                m_internal.texture__loadedTexture_15_size[1] = size[1];
                m_internal.texture__loadedTexture_15_size[2] = size[2];
                m_internal.texture__loadedTexture_15_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_15_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_15 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_15_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_15" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_15, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_16
        {
            if (!m_internal.texture__loadedTexture_16)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\concrete_grooved_02_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\concrete_grooved_02_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\concrete_grooved_02_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_16_size[0] = size[0];
                m_internal.texture__loadedTexture_16_size[1] = size[1];
                m_internal.texture__loadedTexture_16_size[2] = size[2];
                m_internal.texture__loadedTexture_16_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_16_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_16 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_16_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_16" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_16, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_17
        {
            if (!m_internal.texture__loadedTexture_17)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Glass_Dirty_01_spec.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Glass_Dirty_01_spec.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Glass_Dirty_01_spec.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_17_size[0] = size[0];
                m_internal.texture__loadedTexture_17_size[1] = size[1];
                m_internal.texture__loadedTexture_17_size[2] = size[2];
                m_internal.texture__loadedTexture_17_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_17_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_17 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_17_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_17" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_17, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_18
        {
            if (!m_internal.texture__loadedTexture_18)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Wood_Painted_02_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Wood_Painted_02_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Wood_Painted_02_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_18_size[0] = size[0];
                m_internal.texture__loadedTexture_18_size[1] = size[1];
                m_internal.texture__loadedTexture_18_size[2] = size[2];
                m_internal.texture__loadedTexture_18_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_18_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_18 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_18_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_18" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_18, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_19
        {
            if (!m_internal.texture__loadedTexture_19)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Bistro_Main_Door_Concrete_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Bistro_Main_Door_Concrete_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Bistro_Main_Door_Concrete_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_19_size[0] = size[0];
                m_internal.texture__loadedTexture_19_size[1] = size[1];
                m_internal.texture__loadedTexture_19_size[2] = size[2];
                m_internal.texture__loadedTexture_19_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_19_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_19 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_19_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_19" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_19, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_20
        {
            if (!m_internal.texture__loadedTexture_20)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_BistroSideBanner_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_BistroSideBanner_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_BistroSideBanner_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_20_size[0] = size[0];
                m_internal.texture__loadedTexture_20_size[1] = size[1];
                m_internal.texture__loadedTexture_20_size[2] = size[2];
                m_internal.texture__loadedTexture_20_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_20_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_20 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_20_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_20" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_20, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_21
        {
            if (!m_internal.texture__loadedTexture_21)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_BistroSideBanner_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_BistroSideBanner_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_BistroSideBanner_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_21_size[0] = size[0];
                m_internal.texture__loadedTexture_21_size[1] = size[1];
                m_internal.texture__loadedTexture_21_size[2] = size[2];
                m_internal.texture__loadedTexture_21_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_21_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_21 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_21_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_21" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_21, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_22
        {
            if (!m_internal.texture__loadedTexture_22)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_Doors_04A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_Doors_04A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_Doors_04A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_22_size[0] = size[0];
                m_internal.texture__loadedTexture_22_size[1] = size[1];
                m_internal.texture__loadedTexture_22_size[2] = size[2];
                m_internal.texture__loadedTexture_22_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_22_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_22 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_22_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_22" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_22, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_23
        {
            if (!m_internal.texture__loadedTexture_23)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_MainBalcony_02A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_MainBalcony_02A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_MainBalcony_02A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_23_size[0] = size[0];
                m_internal.texture__loadedTexture_23_size[1] = size[1];
                m_internal.texture__loadedTexture_23_size[2] = size[2];
                m_internal.texture__loadedTexture_23_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_23_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_23 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_23_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_23" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_23, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_24
        {
            if (!m_internal.texture__loadedTexture_24)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_MainBalcony_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_MainBalcony_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_MainBalcony_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_24_size[0] = size[0];
                m_internal.texture__loadedTexture_24_size[1] = size[1];
                m_internal.texture__loadedTexture_24_size[2] = size[2];
                m_internal.texture__loadedTexture_24_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_24_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_24 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_24_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_24" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_24, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_25
        {
            if (!m_internal.texture__loadedTexture_25)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_Doors_03A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_Doors_03A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_MainBalcony_01\\Paris_Doors_03A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_25_size[0] = size[0];
                m_internal.texture__loadedTexture_25_size[1] = size[1];
                m_internal.texture__loadedTexture_25_size[2] = size[2];
                m_internal.texture__loadedTexture_25_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_25_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_25 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_25_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_25" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_25, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_26
        {
            if (!m_internal.texture__loadedTexture_26)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Plastic_01_Planters_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Plastic_01_Planters_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Plastic_01_Planters_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_26_size[0] = size[0];
                m_internal.texture__loadedTexture_26_size[1] = size[1];
                m_internal.texture__loadedTexture_26_size[2] = size[2];
                m_internal.texture__loadedTexture_26_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_26_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_26 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_26_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_26" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_26, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_27
        {
            if (!m_internal.texture__loadedTexture_27)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\grain_metal_01_black_metal_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\grain_metal_01_black_metal_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\grain_metal_01_black_metal_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_27_size[0] = size[0];
                m_internal.texture__loadedTexture_27_size[1] = size[1];
                m_internal.texture__loadedTexture_27_size[2] = size[2];
                m_internal.texture__loadedTexture_27_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_27_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_27 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_27_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_27" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_27, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_28
        {
            if (!m_internal.texture__loadedTexture_28)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Plaster_01A_yellow_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Plaster_01A_yellow_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Plaster_01A_yellow_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_28_size[0] = size[0];
                m_internal.texture__loadedTexture_28_size[1] = size[1];
                m_internal.texture__loadedTexture_28_size[2] = size[2];
                m_internal.texture__loadedTexture_28_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_28_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_28 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_28_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_28" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_28, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_29
        {
            if (!m_internal.texture__loadedTexture_29)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Concrete_Smooth_03_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Concrete_Smooth_03_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Concrete_Smooth_03_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_29_size[0] = size[0];
                m_internal.texture__loadedTexture_29_size[1] = size[1];
                m_internal.texture__loadedTexture_29_size[2] = size[2];
                m_internal.texture__loadedTexture_29_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_29_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_29 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_29_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_29" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_29, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_30
        {
            if (!m_internal.texture__loadedTexture_30)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Roofing_Shingle_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Roofing_Shingle_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Roofing_Shingle_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_30_size[0] = size[0];
                m_internal.texture__loadedTexture_30_size[1] = size[1];
                m_internal.texture__loadedTexture_30_size[2] = size[2];
                m_internal.texture__loadedTexture_30_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_30_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_30 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_30_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_30" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_30, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_31
        {
            if (!m_internal.texture__loadedTexture_31)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Roofing_Shingle_03_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Roofing_Shingle_03_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Roofing_Shingle_03_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_31_size[0] = size[0];
                m_internal.texture__loadedTexture_31_size[1] = size[1];
                m_internal.texture__loadedTexture_31_size[2] = size[2];
                m_internal.texture__loadedTexture_31_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_31_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_31 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_31_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_31" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_31, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_32
        {
            if (!m_internal.texture__loadedTexture_32)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Trim_cornice_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Trim_cornice_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Trim_cornice_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_32_size[0] = size[0];
                m_internal.texture__loadedTexture_32_size[1] = size[1];
                m_internal.texture__loadedTexture_32_size[2] = size[2];
                m_internal.texture__loadedTexture_32_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_32_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_32 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_32_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_32" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_32, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_33
        {
            if (!m_internal.texture__loadedTexture_33)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_Building01_Window_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_Building01_Window_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_Building01_Window_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_33_size[0] = size[0];
                m_internal.texture__loadedTexture_33_size[1] = size[1];
                m_internal.texture__loadedTexture_33_size[2] = size[2];
                m_internal.texture__loadedTexture_33_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_33_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_33 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_33_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_33" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_33, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_34
        {
            if (!m_internal.texture__loadedTexture_34)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_Building01_Window_01_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_Building01_Window_01_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_Building01_Window_01_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_34_size[0] = size[0];
                m_internal.texture__loadedTexture_34_size[1] = size[1];
                m_internal.texture__loadedTexture_34_size[2] = size[2];
                m_internal.texture__loadedTexture_34_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_34_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_34 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_34_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_34" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_34, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_35
        {
            if (!m_internal.texture__loadedTexture_35)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Windows_curtains_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Windows_curtains_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Windows_curtains_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_35_size[0] = size[0];
                m_internal.texture__loadedTexture_35_size[1] = size[1];
                m_internal.texture__loadedTexture_35_size[2] = size[2];
                m_internal.texture__loadedTexture_35_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_35_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_35 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_35_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_35" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_35, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_36
        {
            if (!m_internal.texture__loadedTexture_36)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\wood_base_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\wood_base_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\wood_base_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_36_size[0] = size[0];
                m_internal.texture__loadedTexture_36_size[1] = size[1];
                m_internal.texture__loadedTexture_36_size[2] = size[2];
                m_internal.texture__loadedTexture_36_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_36_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_36 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_36_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_36" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_36, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_37
        {
            if (!m_internal.texture__loadedTexture_37)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_Doors_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_Doors_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_Doors_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_37_size[0] = size[0];
                m_internal.texture__loadedTexture_37_size[1] = size[1];
                m_internal.texture__loadedTexture_37_size[2] = size[2];
                m_internal.texture__loadedTexture_37_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_37_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_37 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_37_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_37" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_37, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_38
        {
            if (!m_internal.texture__loadedTexture_38)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\brick_large_03_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\brick_large_03_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\brick_large_03_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_38_size[0] = size[0];
                m_internal.texture__loadedTexture_38_size[1] = size[1];
                m_internal.texture__loadedTexture_38_size[2] = size[2];
                m_internal.texture__loadedTexture_38_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_38_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_38 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_38_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_38" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_38, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_39
        {
            if (!m_internal.texture__loadedTexture_39)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\wood_painted_flat_grey_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\wood_painted_flat_grey_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\wood_painted_flat_grey_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_39_size[0] = size[0];
                m_internal.texture__loadedTexture_39_size[1] = size[1];
                m_internal.texture__loadedTexture_39_size[2] = size[2];
                m_internal.texture__loadedTexture_39_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_39_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_39 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_39_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_39" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_39, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_40
        {
            if (!m_internal.texture__loadedTexture_40)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\brick_large_02_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\brick_large_02_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\brick_large_02_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_40_size[0] = size[0];
                m_internal.texture__loadedTexture_40_size[1] = size[1];
                m_internal.texture__loadedTexture_40_size[2] = size[2];
                m_internal.texture__loadedTexture_40_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_40_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_40 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_40_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_40" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_40, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_41
        {
            if (!m_internal.texture__loadedTexture_41)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_Building_09_Details_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_Building_09_Details_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_Building_09_Details_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_41_size[0] = size[0];
                m_internal.texture__loadedTexture_41_size[1] = size[1];
                m_internal.texture__loadedTexture_41_size[2] = size[2];
                m_internal.texture__loadedTexture_41_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_41_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_41 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_41_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_41" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_41, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_42
        {
            if (!m_internal.texture__loadedTexture_42)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\wood_painted_flat_cyan_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\wood_painted_flat_cyan_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\wood_painted_flat_cyan_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_42_size[0] = size[0];
                m_internal.texture__loadedTexture_42_size[1] = size[1];
                m_internal.texture__loadedTexture_42_size[2] = size[2];
                m_internal.texture__loadedTexture_42_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_42_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_42 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_42_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_42" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_42, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_43
        {
            if (!m_internal.texture__loadedTexture_43)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\brick_small_02_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\brick_small_02_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\brick_small_02_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_43_size[0] = size[0];
                m_internal.texture__loadedTexture_43_size[1] = size[1];
                m_internal.texture__loadedTexture_43_size[2] = size[2];
                m_internal.texture__loadedTexture_43_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_43_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_43 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_43_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_43" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_43, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_44
        {
            if (!m_internal.texture__loadedTexture_44)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\roofing_metal_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\roofing_metal_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\roofing_metal_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_44_size[0] = size[0];
                m_internal.texture__loadedTexture_44_size[1] = size[1];
                m_internal.texture__loadedTexture_44_size[2] = size[2];
                m_internal.texture__loadedTexture_44_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_44_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_44 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_44_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_44" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_44, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_45
        {
            if (!m_internal.texture__loadedTexture_45)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Room_Interior_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Room_Interior_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Room_Interior_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_45_size[0] = size[0];
                m_internal.texture__loadedTexture_45_size[1] = size[1];
                m_internal.texture__loadedTexture_45_size[2] = size[2];
                m_internal.texture__loadedTexture_45_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_45_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_45 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_45_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_45" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_45, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_46
        {
            if (!m_internal.texture__loadedTexture_46)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_BistroAwning_Beams_01B_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_BistroAwning_Beams_01B_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_BistroAwning_Beams_01B_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_46_size[0] = size[0];
                m_internal.texture__loadedTexture_46_size[1] = size[1];
                m_internal.texture__loadedTexture_46_size[2] = size[2];
                m_internal.texture__loadedTexture_46_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_46_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_46 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_46_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_46" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_46, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_47
        {
            if (!m_internal.texture__loadedTexture_47)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Boulangeria_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Boulangeria_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Boulangeria_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_47_size[0] = size[0];
                m_internal.texture__loadedTexture_47_size[1] = size[1];
                m_internal.texture__loadedTexture_47_size[2] = size[2];
                m_internal.texture__loadedTexture_47_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_47_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_47 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_47_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_47" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_47, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_48
        {
            if (!m_internal.texture__loadedTexture_48)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\frosted_glass_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\frosted_glass_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\frosted_glass_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_48_size[0] = size[0];
                m_internal.texture__loadedTexture_48_size[1] = size[1];
                m_internal.texture__loadedTexture_48_size[2] = size[2];
                m_internal.texture__loadedTexture_48_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_48_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_48 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_48_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_48" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_48, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_49
        {
            if (!m_internal.texture__loadedTexture_49)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_BistroAwning_Fabric_Cyan_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_BistroAwning_Fabric_Cyan_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_BistroAwning_Fabric_Cyan_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_49_size[0] = size[0];
                m_internal.texture__loadedTexture_49_size[1] = size[1];
                m_internal.texture__loadedTexture_49_size[2] = size[2];
                m_internal.texture__loadedTexture_49_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_49_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_49 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_49_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_49" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_49, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_50
        {
            if (!m_internal.texture__loadedTexture_50)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Metal_Clean_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Metal_Clean_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Metal_Clean_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_50_size[0] = size[0];
                m_internal.texture__loadedTexture_50_size[1] = size[1];
                m_internal.texture__loadedTexture_50_size[2] = size[2];
                m_internal.texture__loadedTexture_50_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_50_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_50 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_50_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_50" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_50, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_51
        {
            if (!m_internal.texture__loadedTexture_51)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Plaster_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Plaster_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Plaster_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_51_size[0] = size[0];
                m_internal.texture__loadedTexture_51_size[1] = size[1];
                m_internal.texture__loadedTexture_51_size[2] = size[2];
                m_internal.texture__loadedTexture_51_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_51_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_51 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_51_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_51" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_51, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_52
        {
            if (!m_internal.texture__loadedTexture_52)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\paris_bistroawning_fabric_01a_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\paris_bistroawning_fabric_01a_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\paris_bistroawning_fabric_01a_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_52_size[0] = size[0];
                m_internal.texture__loadedTexture_52_size[1] = size[1];
                m_internal.texture__loadedTexture_52_size[2] = size[2];
                m_internal.texture__loadedTexture_52_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_52_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_52 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_52_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_52" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_52, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_53
        {
            if (!m_internal.texture__loadedTexture_53)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Books_Covers_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Books_Covers_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Books_Covers_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_53_size[0] = size[0];
                m_internal.texture__loadedTexture_53_size[1] = size[1];
                m_internal.texture__loadedTexture_53_size[2] = size[2];
                m_internal.texture__loadedTexture_53_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_53_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_53 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_53_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_53" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_53, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_54
        {
            if (!m_internal.texture__loadedTexture_54)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\concrete_smooth_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\concrete_smooth_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\concrete_smooth_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_54_size[0] = size[0];
                m_internal.texture__loadedTexture_54_size[1] = size[1];
                m_internal.texture__loadedTexture_54_size[2] = size[2];
                m_internal.texture__loadedTexture_54_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_54_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_54 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_54_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_54" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_54, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_55
        {
            if (!m_internal.texture__loadedTexture_55)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Wood_Painted_04_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Wood_Painted_04_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Wood_Painted_04_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_55_size[0] = size[0];
                m_internal.texture__loadedTexture_55_size[1] = size[1];
                m_internal.texture__loadedTexture_55_size[2] = size[2];
                m_internal.texture__loadedTexture_55_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_55_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_55 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_55_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_55" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_55, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_56
        {
            if (!m_internal.texture__loadedTexture_56)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Metal_RollDoor_01\\Metal_RollDoor_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Metal_RollDoor_01\\Metal_RollDoor_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Metal_RollDoor_01\\Metal_RollDoor_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_56_size[0] = size[0];
                m_internal.texture__loadedTexture_56_size[1] = size[1];
                m_internal.texture__loadedTexture_56_size[2] = size[2];
                m_internal.texture__loadedTexture_56_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_56_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_56 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_56_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_56" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_56, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_57
        {
            if (!m_internal.texture__loadedTexture_57)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Buxus\\buxus_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Buxus\\buxus_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Buxus\\buxus_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_57_size[0] = size[0];
                m_internal.texture__loadedTexture_57_size[1] = size[1];
                m_internal.texture__loadedTexture_57_size[2] = size[2];
                m_internal.texture__loadedTexture_57_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_57_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_57 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_57_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_57" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_57, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_58
        {
            if (!m_internal.texture__loadedTexture_58)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Buxus\\buxus_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Buxus\\buxus_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Buxus\\buxus_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_58_size[0] = size[0];
                m_internal.texture__loadedTexture_58_size[1] = size[1];
                m_internal.texture__loadedTexture_58_size[2] = size[2];
                m_internal.texture__loadedTexture_58_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_58_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_58 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_58_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_58" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_58, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_59
        {
            if (!m_internal.texture__loadedTexture_59)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Italian_Cypress\\Italian_Cypress_Leaves_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Italian_Cypress\\Italian_Cypress_Leaves_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Italian_Cypress\\Italian_Cypress_Leaves_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_59_size[0] = size[0];
                m_internal.texture__loadedTexture_59_size[1] = size[1];
                m_internal.texture__loadedTexture_59_size[2] = size[2];
                m_internal.texture__loadedTexture_59_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_59_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_59 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_59_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_59" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_59, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_60
        {
            if (!m_internal.texture__loadedTexture_60)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Italian_Cypress\\Italian_Cypress_Leaves_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Italian_Cypress\\Italian_Cypress_Leaves_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Italian_Cypress\\Italian_Cypress_Leaves_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_60_size[0] = size[0];
                m_internal.texture__loadedTexture_60_size[1] = size[1];
                m_internal.texture__loadedTexture_60_size[2] = size[2];
                m_internal.texture__loadedTexture_60_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_60_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_60 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_60_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_60" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_60, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_61
        {
            if (!m_internal.texture__loadedTexture_61)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Italian_Cypress\\Italian_Cypress_Bark_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Italian_Cypress\\Italian_Cypress_Bark_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Italian_Cypress\\Italian_Cypress_Bark_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_61_size[0] = size[0];
                m_internal.texture__loadedTexture_61_size[1] = size[1];
                m_internal.texture__loadedTexture_61_size[2] = size[2];
                m_internal.texture__loadedTexture_61_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_61_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_61 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_61_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_61" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_61, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_62
        {
            if (!m_internal.texture__loadedTexture_62)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_Foliage_01a_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_Foliage_01a_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_Foliage_01a_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_62_size[0] = size[0];
                m_internal.texture__loadedTexture_62_size[1] = size[1];
                m_internal.texture__loadedTexture_62_size[2] = size[2];
                m_internal.texture__loadedTexture_62_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_62_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_62 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_62_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_62" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_62, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_63
        {
            if (!m_internal.texture__loadedTexture_63)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_Foliage_01a_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_Foliage_01a_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_Foliage_01a_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_63_size[0] = size[0];
                m_internal.texture__loadedTexture_63_size[1] = size[1];
                m_internal.texture__loadedTexture_63_size[2] = size[2];
                m_internal.texture__loadedTexture_63_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_63_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_63 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_63_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_63" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_63, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_64
        {
            if (!m_internal.texture__loadedTexture_64)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_flowers_01a_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_flowers_01a_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_flowers_01a_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_64_size[0] = size[0];
                m_internal.texture__loadedTexture_64_size[1] = size[1];
                m_internal.texture__loadedTexture_64_size[2] = size[2];
                m_internal.texture__loadedTexture_64_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_64_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_64 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_64_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_64" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_64, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_65
        {
            if (!m_internal.texture__loadedTexture_65)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_flowers_01a_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_flowers_01a_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Paris_flowers_01a\\Paris_flowers_01a_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_65_size[0] = size[0];
                m_internal.texture__loadedTexture_65_size[1] = size[1];
                m_internal.texture__loadedTexture_65_size[2] = size[2];
                m_internal.texture__loadedTexture_65_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_65_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_65 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_65_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_65" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_65, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_66
        {
            if (!m_internal.texture__loadedTexture_66)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\linden\\Linden_Bark_A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\linden\\Linden_Bark_A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\linden\\Linden_Bark_A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_66_size[0] = size[0];
                m_internal.texture__loadedTexture_66_size[1] = size[1];
                m_internal.texture__loadedTexture_66_size[2] = size[2];
                m_internal.texture__loadedTexture_66_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_66_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_66 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_66_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_66" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_66, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_67
        {
            if (!m_internal.texture__loadedTexture_67)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\linden\\Leaves_B_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\linden\\Leaves_B_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\linden\\Leaves_B_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_67_size[0] = size[0];
                m_internal.texture__loadedTexture_67_size[1] = size[1];
                m_internal.texture__loadedTexture_67_size[2] = size[2];
                m_internal.texture__loadedTexture_67_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_67_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_67 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_67_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_67" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_67, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_68
        {
            if (!m_internal.texture__loadedTexture_68)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\linden\\Leaves_B_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\linden\\Leaves_B_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\linden\\Leaves_B_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_68_size[0] = size[0];
                m_internal.texture__loadedTexture_68_size[1] = size[1];
                m_internal.texture__loadedTexture_68_size[2] = size[2];
                m_internal.texture__loadedTexture_68_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_68_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_68 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_68_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_68" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_68, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_69
        {
            if (!m_internal.texture__loadedTexture_69)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\linden\\Leaves_A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\linden\\Leaves_A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\linden\\Leaves_A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_69_size[0] = size[0];
                m_internal.texture__loadedTexture_69_size[1] = size[1];
                m_internal.texture__loadedTexture_69_size[2] = size[2];
                m_internal.texture__loadedTexture_69_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_69_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_69 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_69_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_69" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_69, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_70
        {
            if (!m_internal.texture__loadedTexture_70)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\linden\\Leaves_A_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\linden\\Leaves_A_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\linden\\Leaves_A_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_70_size[0] = size[0];
                m_internal.texture__loadedTexture_70_size[1] = size[1];
                m_internal.texture__loadedTexture_70_size[2] = size[2];
                m_internal.texture__loadedTexture_70_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_70_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_70 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_70_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_70" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_70, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_71
        {
            if (!m_internal.texture__loadedTexture_71)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Paris_ivy_01a\\Paris_ivy_leaf_a_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Paris_ivy_01a\\Paris_ivy_leaf_a_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Paris_ivy_01a\\Paris_ivy_leaf_a_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_71_size[0] = size[0];
                m_internal.texture__loadedTexture_71_size[1] = size[1];
                m_internal.texture__loadedTexture_71_size[2] = size[2];
                m_internal.texture__loadedTexture_71_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_71_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_71 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_71_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_71" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_71, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_72
        {
            if (!m_internal.texture__loadedTexture_72)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Paris_ivy_01a\\Paris_ivy_leaf_a_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Paris_ivy_01a\\Paris_ivy_leaf_a_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Paris_ivy_01a\\Paris_ivy_leaf_a_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_72_size[0] = size[0];
                m_internal.texture__loadedTexture_72_size[1] = size[1];
                m_internal.texture__loadedTexture_72_size[2] = size[2];
                m_internal.texture__loadedTexture_72_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_72_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_72 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_72_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_72" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_72, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_73
        {
            if (!m_internal.texture__loadedTexture_73)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Natural\\Paris_ivy_01a\\Paris_ivy_branch_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Natural\\Paris_ivy_01a\\Paris_ivy_branch_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Natural\\Paris_ivy_01a\\Paris_ivy_branch_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_73_size[0] = size[0];
                m_internal.texture__loadedTexture_73_size[1] = size[1];
                m_internal.texture__loadedTexture_73_size[2] = size[2];
                m_internal.texture__loadedTexture_73_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_73_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_73 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_73_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_73" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_73, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_74
        {
            if (!m_internal.texture__loadedTexture_74)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Paris_StreetLight_Glass_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Paris_StreetLight_Glass_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Paris_StreetLight_Glass_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_74_size[0] = size[0];
                m_internal.texture__loadedTexture_74_size[1] = size[1];
                m_internal.texture__loadedTexture_74_size[2] = size[2];
                m_internal.texture__loadedTexture_74_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_74_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_74 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_74_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_74" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_74, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_75
        {
            if (!m_internal.texture__loadedTexture_75)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Colors\\White.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Colors\\White.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Colors\\White.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_75_size[0] = size[0];
                m_internal.texture__loadedTexture_75_size[1] = size[1];
                m_internal.texture__loadedTexture_75_size[2] = size[2];
                m_internal.texture__loadedTexture_75_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_75_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_75 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_75_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_75" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_75, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_76
        {
            if (!m_internal.texture__loadedTexture_76)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Paris_StreetLight_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Paris_StreetLight_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Paris_StreetLight_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_76_size[0] = size[0];
                m_internal.texture__loadedTexture_76_size[1] = size[1];
                m_internal.texture__loadedTexture_76_size[2] = size[2];
                m_internal.texture__loadedTexture_76_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_76_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_76 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_76_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_76" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_76, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_77
        {
            if (!m_internal.texture__loadedTexture_77)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Street_decals_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Street_decals_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Street_decals_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_77_size[0] = size[0];
                m_internal.texture__loadedTexture_77_size[1] = size[1];
                m_internal.texture__loadedTexture_77_size[2] = size[2];
                m_internal.texture__loadedTexture_77_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_77_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_77 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_77_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_77" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_77, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_78
        {
            if (!m_internal.texture__loadedTexture_78)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Street_decals_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Street_decals_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_StreetLight_01\\Street_decals_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_78_size[0] = size[0];
                m_internal.texture__loadedTexture_78_size[1] = size[1];
                m_internal.texture__loadedTexture_78_size[2] = size[2];
                m_internal.texture__loadedTexture_78_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_78_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_78 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_78_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_78" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_78, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_79
        {
            if (!m_internal.texture__loadedTexture_79)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_StreetPivot\\Paris_StreetPivot_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_StreetPivot\\Paris_StreetPivot_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_StreetPivot\\Paris_StreetPivot_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_79_size[0] = size[0];
                m_internal.texture__loadedTexture_79_size[1] = size[1];
                m_internal.texture__loadedTexture_79_size[2] = size[2];
                m_internal.texture__loadedTexture_79_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_79_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_79 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_79_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_79" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_79, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_80
        {
            if (!m_internal.texture__loadedTexture_80)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_ElectricBox_01\\Paris_ElectricBox_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_ElectricBox_01\\Paris_ElectricBox_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_ElectricBox_01\\Paris_ElectricBox_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_80_size[0] = size[0];
                m_internal.texture__loadedTexture_80_size[1] = size[1];
                m_internal.texture__loadedTexture_80_size[2] = size[2];
                m_internal.texture__loadedTexture_80_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_80_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_80 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_80_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_80" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_80, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_81
        {
            if (!m_internal.texture__loadedTexture_81)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_bakery_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_bakery_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_bakery_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_81_size[0] = size[0];
                m_internal.texture__loadedTexture_81_size[1] = size[1];
                m_internal.texture__loadedTexture_81_size[2] = size[2];
                m_internal.texture__loadedTexture_81_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_81_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_81 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_81_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_81" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_81, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_82
        {
            if (!m_internal.texture__loadedTexture_82)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Metal_Chrome_01\\Metal_Chrome_01_banner_metal_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Metal_Chrome_01\\Metal_Chrome_01_banner_metal_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Metal_Chrome_01\\Metal_Chrome_01_banner_metal_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_82_size[0] = size[0];
                m_internal.texture__loadedTexture_82_size[1] = size[1];
                m_internal.texture__loadedTexture_82_size[2] = size[2];
                m_internal.texture__loadedTexture_82_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_82_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_82 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_82_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_82" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_82, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_83
        {
            if (!m_internal.texture__loadedTexture_83)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_bookshop_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_bookshop_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_bookshop_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_83_size[0] = size[0];
                m_internal.texture__loadedTexture_83_size[1] = size[1];
                m_internal.texture__loadedTexture_83_size[2] = size[2];
                m_internal.texture__loadedTexture_83_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_83_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_83 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_83_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_83" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_83, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_84
        {
            if (!m_internal.texture__loadedTexture_84)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_pharmacy_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_pharmacy_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_pharmacy_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_84_size[0] = size[0];
                m_internal.texture__loadedTexture_84_size[1] = size[1];
                m_internal.texture__loadedTexture_84_size[2] = size[2];
                m_internal.texture__loadedTexture_84_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_84_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_84 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_84_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_84" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_84, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_85
        {
            if (!m_internal.texture__loadedTexture_85)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_ties shop_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_ties shop_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_ShopSign_01\\Paris_ShopSign_ties shop_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_85_size[0] = size[0];
                m_internal.texture__loadedTexture_85_size[1] = size[1];
                m_internal.texture__loadedTexture_85_size[2] = size[2];
                m_internal.texture__loadedTexture_85_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_85_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_85 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_85_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_85" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_85, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_86
        {
            if (!m_internal.texture__loadedTexture_86)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_BistroExteriorSpotLight_01\\Paris_BistroExteriorSpotLight_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_BistroExteriorSpotLight_01\\Paris_BistroExteriorSpotLight_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_BistroExteriorSpotLight_01\\Paris_BistroExteriorSpotLight_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_86_size[0] = size[0];
                m_internal.texture__loadedTexture_86_size[1] = size[1];
                m_internal.texture__loadedTexture_86_size[2] = size[2];
                m_internal.texture__loadedTexture_86_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_86_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_86 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_86_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_86" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_86, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_87
        {
            if (!m_internal.texture__loadedTexture_87)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_StreetSign_01\\Paris_StreetSign_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_StreetSign_01\\Paris_StreetSign_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_StreetSign_01\\Paris_StreetSign_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_87_size[0] = size[0];
                m_internal.texture__loadedTexture_87_size[1] = size[1];
                m_internal.texture__loadedTexture_87_size[2] = size[2];
                m_internal.texture__loadedTexture_87_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_87_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_87 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_87_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_87" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_87, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_88
        {
            if (!m_internal.texture__loadedTexture_88)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_TrafficSign_01\\Paris_TrafficSign_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_TrafficSign_01\\Paris_TrafficSign_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_TrafficSign_01\\Paris_TrafficSign_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_88_size[0] = size[0];
                m_internal.texture__loadedTexture_88_size[1] = size[1];
                m_internal.texture__loadedTexture_88_size[2] = size[2];
                m_internal.texture__loadedTexture_88_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_88_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_88 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_88_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_88" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_88, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_89
        {
            if (!m_internal.texture__loadedTexture_89)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_MenuSign_01\\Paris_MenuSign_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_MenuSign_01\\Paris_MenuSign_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_MenuSign_01\\Paris_MenuSign_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_89_size[0] = size[0];
                m_internal.texture__loadedTexture_89_size[1] = size[1];
                m_internal.texture__loadedTexture_89_size[2] = size[2];
                m_internal.texture__loadedTexture_89_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_89_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_89 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_89_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_89" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_89, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_90
        {
            if (!m_internal.texture__loadedTexture_90)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_MenuSign_01\\Paris_MenuSign_01B_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_MenuSign_01\\Paris_MenuSign_01B_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_MenuSign_01\\Paris_MenuSign_01B_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_90_size[0] = size[0];
                m_internal.texture__loadedTexture_90_size[1] = size[1];
                m_internal.texture__loadedTexture_90_size[2] = size[2];
                m_internal.texture__loadedTexture_90_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_90_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_90 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_90_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_90" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_90, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_91
        {
            if (!m_internal.texture__loadedTexture_91)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Glass_Dirty_01\\Glass_Dirty_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Glass_Dirty_01\\Glass_Dirty_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Glass_Dirty_01\\Glass_Dirty_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_91_size[0] = size[0];
                m_internal.texture__loadedTexture_91_size[1] = size[1];
                m_internal.texture__loadedTexture_91_size[2] = size[2];
                m_internal.texture__loadedTexture_91_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_91_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_91 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_91_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_91" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_91, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_92
        {
            if (!m_internal.texture__loadedTexture_92)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_TrashCan_01\\Paris_TrashCan_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_TrashCan_01\\Paris_TrashCan_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_TrashCan_01\\Paris_TrashCan_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_92_size[0] = size[0];
                m_internal.texture__loadedTexture_92_size[1] = size[1];
                m_internal.texture__loadedTexture_92_size[2] = size[2];
                m_internal.texture__loadedTexture_92_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_92_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_92 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_92_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_92" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_92, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_93
        {
            if (!m_internal.texture__loadedTexture_93)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Colors\\Green.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Colors\\Green.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Colors\\Green.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_93_size[0] = size[0];
                m_internal.texture__loadedTexture_93_size[1] = size[1];
                m_internal.texture__loadedTexture_93_size[2] = size[2];
                m_internal.texture__loadedTexture_93_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_93_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_93 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_93_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_93" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_93, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_94
        {
            if (!m_internal.texture__loadedTexture_94)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Colors\\Red_Full.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Colors\\Red_Full.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Colors\\Red_Full.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_94_size[0] = size[0];
                m_internal.texture__loadedTexture_94_size[1] = size[1];
                m_internal.texture__loadedTexture_94_size[2] = size[2];
                m_internal.texture__loadedTexture_94_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_94_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_94 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_94_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_94" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_94, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_95
        {
            if (!m_internal.texture__loadedTexture_95)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_StringLights_01\\Paris_StringLights_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_StringLights_01\\Paris_StringLights_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_StringLights_01\\Paris_StringLights_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_95_size[0] = size[0];
                m_internal.texture__loadedTexture_95_size[1] = size[1];
                m_internal.texture__loadedTexture_95_size[2] = size[2];
                m_internal.texture__loadedTexture_95_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_95_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_95 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_95_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_95" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_95, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_96
        {
            if (!m_internal.texture__loadedTexture_96)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Colors\\Purple.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Colors\\Purple.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Colors\\Purple.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_96_size[0] = size[0];
                m_internal.texture__loadedTexture_96_size[1] = size[1];
                m_internal.texture__loadedTexture_96_size[2] = size[2];
                m_internal.texture__loadedTexture_96_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_96_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_96 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_96_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_96" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_96, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_97
        {
            if (!m_internal.texture__loadedTexture_97)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Colors\\Orange.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Colors\\Orange.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Colors\\Orange.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_97_size[0] = size[0];
                m_internal.texture__loadedTexture_97_size[1] = size[1];
                m_internal.texture__loadedTexture_97_size[2] = size[2];
                m_internal.texture__loadedTexture_97_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_97_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_97 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_97_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_97" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_97, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_98
        {
            if (!m_internal.texture__loadedTexture_98)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_Bollard_01\\Paris_Bollard_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_Bollard_01\\Paris_Bollard_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_Bollard_01\\Paris_Bollard_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_98_size[0] = size[0];
                m_internal.texture__loadedTexture_98_size[1] = size[1];
                m_internal.texture__loadedTexture_98_size[2] = size[2];
                m_internal.texture__loadedTexture_98_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_98_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_98 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_98_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_98" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_98, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_99
        {
            if (!m_internal.texture__loadedTexture_99)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_VespaScooter_01\\Paris_VespaScooter_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_VespaScooter_01\\Paris_VespaScooter_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_VespaScooter_01\\Paris_VespaScooter_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_99_size[0] = size[0];
                m_internal.texture__loadedTexture_99_size[1] = size[1];
                m_internal.texture__loadedTexture_99_size[2] = size[2];
                m_internal.texture__loadedTexture_99_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_99_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_99 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_99_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_99" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_99, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_100
        {
            if (!m_internal.texture__loadedTexture_100)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_VespaScooter_01\\Paris_VespaScooter_01_odometer_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_VespaScooter_01\\Paris_VespaScooter_01_odometer_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_VespaScooter_01\\Paris_VespaScooter_01_odometer_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_100_size[0] = size[0];
                m_internal.texture__loadedTexture_100_size[1] = size[1];
                m_internal.texture__loadedTexture_100_size[2] = size[2];
                m_internal.texture__loadedTexture_100_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_100_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_100 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_100_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_100" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_100, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_101
        {
            if (!m_internal.texture__loadedTexture_101)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Metal_Clean_01\\Metal_Clean_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Metal_Clean_01\\Metal_Clean_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Metal_Clean_01\\Metal_Clean_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_101_size[0] = size[0];
                m_internal.texture__loadedTexture_101_size[1] = size[1];
                m_internal.texture__loadedTexture_101_size[2] = size[2];
                m_internal.texture__loadedTexture_101_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_101_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_101 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_101_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_101" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_101, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_102
        {
            if (!m_internal.texture__loadedTexture_102)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Plastic_02\\Plastic_02_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Plastic_02\\Plastic_02_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Plastic_02\\Plastic_02_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_102_size[0] = size[0];
                m_internal.texture__loadedTexture_102_size[1] = size[1];
                m_internal.texture__loadedTexture_102_size[2] = size[2];
                m_internal.texture__loadedTexture_102_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_102_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_102 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_102_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_102" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_102, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_103
        {
            if (!m_internal.texture__loadedTexture_103)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_BistroAwning_01\\Paris_BistroAwning_Fabric_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_BistroAwning_01\\Paris_BistroAwning_Fabric_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_BistroAwning_01\\Paris_BistroAwning_Fabric_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_103_size[0] = size[0];
                m_internal.texture__loadedTexture_103_size[1] = size[1];
                m_internal.texture__loadedTexture_103_size[2] = size[2];
                m_internal.texture__loadedTexture_103_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_103_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_103 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_103_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_103" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_103, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_104
        {
            if (!m_internal.texture__loadedTexture_104)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_BistroAwning_01\\Paris_BistroAwning_Beams_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_BistroAwning_01\\Paris_BistroAwning_Beams_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_BistroAwning_01\\Paris_BistroAwning_Beams_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_104_size[0] = size[0];
                m_internal.texture__loadedTexture_104_size[1] = size[1];
                m_internal.texture__loadedTexture_104_size[2] = size[2];
                m_internal.texture__loadedTexture_104_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_104_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_104 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_104_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_104" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_104, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_105
        {
            if (!m_internal.texture__loadedTexture_105)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_BistroAwning_02\\Paris_BistroAwning_02_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_BistroAwning_02\\Paris_BistroAwning_02_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_BistroAwning_02\\Paris_BistroAwning_02_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_105_size[0] = size[0];
                m_internal.texture__loadedTexture_105_size[1] = size[1];
                m_internal.texture__loadedTexture_105_size[2] = size[2];
                m_internal.texture__loadedTexture_105_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_105_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_105 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_105_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_105" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_105, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_106
        {
            if (!m_internal.texture__loadedTexture_106)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_BistroFrontBanner_01\\Paris_BistroFrontBanner_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_BistroFrontBanner_01\\Paris_BistroFrontBanner_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_BistroFrontBanner_01\\Paris_BistroFrontBanner_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_106_size[0] = size[0];
                m_internal.texture__loadedTexture_106_size[1] = size[1];
                m_internal.texture__loadedTexture_106_size[2] = size[2];
                m_internal.texture__loadedTexture_106_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_106_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_106 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_106_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_106" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_106, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_107
        {
            if (!m_internal.texture__loadedTexture_107)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Colors\\Grey_80.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Colors\\Grey_80.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Colors\\Grey_80.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_107_size[0] = size[0];
                m_internal.texture__loadedTexture_107_size[1] = size[1];
                m_internal.texture__loadedTexture_107_size[2] = size[2];
                m_internal.texture__loadedTexture_107_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_107_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_107 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_107_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_107" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_107, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_108
        {
            if (!m_internal.texture__loadedTexture_108)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_PlantPot_01\\Paris_PlantPot_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_PlantPot_01\\Paris_PlantPot_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_PlantPot_01\\Paris_PlantPot_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_108_size[0] = size[0];
                m_internal.texture__loadedTexture_108_size[1] = size[1];
                m_internal.texture__loadedTexture_108_size[2] = size[2];
                m_internal.texture__loadedTexture_108_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_108_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_108 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_108_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_108" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_108, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_109
        {
            if (!m_internal.texture__loadedTexture_109)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_SidewalkBarrier_01\\Paris_SidewalkBarrier_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_SidewalkBarrier_01\\Paris_SidewalkBarrier_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_SidewalkBarrier_01\\Paris_SidewalkBarrier_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_109_size[0] = size[0];
                m_internal.texture__loadedTexture_109_size[1] = size[1];
                m_internal.texture__loadedTexture_109_size[2] = size[2];
                m_internal.texture__loadedTexture_109_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_109_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_109 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_109_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_109" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_109, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_110
        {
            if (!m_internal.texture__loadedTexture_110)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Concrete_Smooth_02\\Concrete_Smooth_02_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Concrete_Smooth_02\\Concrete_Smooth_02_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Concrete_Smooth_02\\Concrete_Smooth_02_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_110_size[0] = size[0];
                m_internal.texture__loadedTexture_110_size[1] = size[1];
                m_internal.texture__loadedTexture_110_size[2] = size[2];
                m_internal.texture__loadedTexture_110_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_110_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_110 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_110_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_110" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_110, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_111
        {
            if (!m_internal.texture__loadedTexture_111)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Brick_Large_01\\Brick_Large_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Brick_Large_01\\Brick_Large_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Brick_Large_01\\Brick_Large_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_111_size[0] = size[0];
                m_internal.texture__loadedTexture_111_size[1] = size[1];
                m_internal.texture__loadedTexture_111_size[2] = size[2];
                m_internal.texture__loadedTexture_111_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_111_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_111 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_111_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_111" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_111, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_112
        {
            if (!m_internal.texture__loadedTexture_112)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Concrete_Smooth_01\\Concrete_Smooth_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Concrete_Smooth_01\\Concrete_Smooth_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Concrete_Smooth_01\\Concrete_Smooth_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_112_size[0] = size[0];
                m_internal.texture__loadedTexture_112_size[1] = size[1];
                m_internal.texture__loadedTexture_112_size[2] = size[2];
                m_internal.texture__loadedTexture_112_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_112_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_112 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_112_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_112" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_112, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_113
        {
            if (!m_internal.texture__loadedTexture_113)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Concrete_Grooved_02\\Concrete_Grooved_02_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Concrete_Grooved_02\\Concrete_Grooved_02_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Concrete_Grooved_02\\Concrete_Grooved_02_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_113_size[0] = size[0];
                m_internal.texture__loadedTexture_113_size[1] = size[1];
                m_internal.texture__loadedTexture_113_size[2] = size[2];
                m_internal.texture__loadedTexture_113_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_113_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_113 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_113_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_113" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_113, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_114
        {
            if (!m_internal.texture__loadedTexture_114)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Grain_Metal_01\\Grain_Metal_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Grain_Metal_01\\Grain_Metal_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Grain_Metal_01\\Grain_Metal_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_114_size[0] = size[0];
                m_internal.texture__loadedTexture_114_size[1] = size[1];
                m_internal.texture__loadedTexture_114_size[2] = size[2];
                m_internal.texture__loadedTexture_114_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_114_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_114 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_114_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_114" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_114, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_115
        {
            if (!m_internal.texture__loadedTexture_115)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_Lantern_01\\Paris_Lantern_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_Lantern_01\\Paris_Lantern_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_Lantern_01\\Paris_Lantern_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_115_size[0] = size[0];
                m_internal.texture__loadedTexture_115_size[1] = size[1];
                m_internal.texture__loadedTexture_115_size[2] = size[2];
                m_internal.texture__loadedTexture_115_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_115_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_115 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_115_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_115" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_115, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_116
        {
            if (!m_internal.texture__loadedTexture_116)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Chair_01\\Paris_Chair_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Chair_01\\Paris_Chair_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Chair_01\\Paris_Chair_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_116_size[0] = size[0];
                m_internal.texture__loadedTexture_116_size[1] = size[1];
                m_internal.texture__loadedTexture_116_size[2] = size[2];
                m_internal.texture__loadedTexture_116_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_116_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_116 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_116_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_116" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_116, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_117
        {
            if (!m_internal.texture__loadedTexture_117)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Table_01\\Paris_Table_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Table_01\\Paris_Table_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Table_01\\Paris_Table_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_117_size[0] = size[0];
                m_internal.texture__loadedTexture_117_size[1] = size[1];
                m_internal.texture__loadedTexture_117_size[2] = size[2];
                m_internal.texture__loadedTexture_117_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_117_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_117 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_117_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_117" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_117, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_118
        {
            if (!m_internal.texture__loadedTexture_118)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Ashtray_01\\Paris_Ashtray_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Ashtray_01\\Paris_Ashtray_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Ashtray_01\\Paris_Ashtray_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_118_size[0] = size[0];
                m_internal.texture__loadedTexture_118_size[1] = size[1];
                m_internal.texture__loadedTexture_118_size[2] = size[2];
                m_internal.texture__loadedTexture_118_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_118_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_118 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_118_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_118" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_118, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_119
        {
            if (!m_internal.texture__loadedTexture_119)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_NapkinHolder_01\\Paris_Napkinholder_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_NapkinHolder_01\\Paris_Napkinholder_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_NapkinHolder_01\\Paris_Napkinholder_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_119_size[0] = size[0];
                m_internal.texture__loadedTexture_119_size[1] = size[1];
                m_internal.texture__loadedTexture_119_size[2] = size[2];
                m_internal.texture__loadedTexture_119_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_119_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_119 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_119_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_119" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_119, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_120
        {
            if (!m_internal.texture__loadedTexture_120)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Colors\\Grey_30.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Colors\\Grey_30.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Colors\\Grey_30.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_120_size[0] = size[0];
                m_internal.texture__loadedTexture_120_size[1] = size[1];
                m_internal.texture__loadedTexture_120_size[2] = size[2];
                m_internal.texture__loadedTexture_120_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_120_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_120 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_120_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_120" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_120, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_121
        {
            if (!m_internal.texture__loadedTexture_121)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_LiquorBottle_01\\Paris_LiquorBottle_01_Cap_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_LiquorBottle_01\\Paris_LiquorBottle_01_Cap_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_LiquorBottle_01\\Paris_LiquorBottle_01_Cap_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_121_size[0] = size[0];
                m_internal.texture__loadedTexture_121_size[1] = size[1];
                m_internal.texture__loadedTexture_121_size[2] = size[2];
                m_internal.texture__loadedTexture_121_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_121_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_121 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_121_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_121" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_121, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_122
        {
            if (!m_internal.texture__loadedTexture_122)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_LiquorBottle_01\\Paris_LiquorBottle_labels_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_LiquorBottle_01\\Paris_LiquorBottle_labels_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_LiquorBottle_01\\Paris_LiquorBottle_labels_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_122_size[0] = size[0];
                m_internal.texture__loadedTexture_122_size[1] = size[1];
                m_internal.texture__loadedTexture_122_size[2] = size[2];
                m_internal.texture__loadedTexture_122_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_122_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_122 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_122_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_122" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_122, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_123
        {
            if (!m_internal.texture__loadedTexture_123)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_LiquorBottle_01\\Paris_LiquorBottle_labels_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_LiquorBottle_01\\Paris_LiquorBottle_labels_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_LiquorBottle_01\\Paris_LiquorBottle_labels_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_123_size[0] = size[0];
                m_internal.texture__loadedTexture_123_size[1] = size[1];
                m_internal.texture__loadedTexture_123_size[2] = size[2];
                m_internal.texture__loadedTexture_123_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_123_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_123 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_123_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_123" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_123, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_124
        {
            if (!m_internal.texture__loadedTexture_124)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\wood_polished_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\wood_polished_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\wood_polished_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_124_size[0] = size[0];
                m_internal.texture__loadedTexture_124_size[1] = size[1];
                m_internal.texture__loadedTexture_124_size[2] = size[2];
                m_internal.texture__loadedTexture_124_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_124_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_124 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_124_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_124" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_124, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_125
        {
            if (!m_internal.texture__loadedTexture_125)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\wood_planks_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\wood_planks_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\wood_planks_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_125_size[0] = size[0];
                m_internal.texture__loadedTexture_125_size[1] = size[1];
                m_internal.texture__loadedTexture_125_size[2] = size[2];
                m_internal.texture__loadedTexture_125_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_125_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_125 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_125_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_125" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_125, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_126
        {
            if (!m_internal.texture__loadedTexture_126)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\concrete_smooth_02_red_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\concrete_smooth_02_red_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\concrete_smooth_02_red_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_126_size[0] = size[0];
                m_internal.texture__loadedTexture_126_size[1] = size[1];
                m_internal.texture__loadedTexture_126_size[2] = size[2];
                m_internal.texture__loadedTexture_126_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_126_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_126 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_126_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_126" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_126, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_127
        {
            if (!m_internal.texture__loadedTexture_127)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Grey_128.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Grey_128.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Grey_128.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_127_size[0] = size[0];
                m_internal.texture__loadedTexture_127_size[1] = size[1];
                m_internal.texture__loadedTexture_127_size[2] = size[2];
                m_internal.texture__loadedTexture_127_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_127_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_127 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_127_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_127" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_127, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_128
        {
            if (!m_internal.texture__loadedTexture_128)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\paris_brushed_metal_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\paris_brushed_metal_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\paris_brushed_metal_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_128_size[0] = size[0];
                m_internal.texture__loadedTexture_128_size[1] = size[1];
                m_internal.texture__loadedTexture_128_size[2] = size[2];
                m_internal.texture__loadedTexture_128_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_128_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_128 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_128_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_128" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_128, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_129
        {
            if (!m_internal.texture__loadedTexture_129)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\tile_hexagonal_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\tile_hexagonal_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\tile_hexagonal_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_129_size[0] = size[0];
                m_internal.texture__loadedTexture_129_size[1] = size[1];
                m_internal.texture__loadedTexture_129_size[2] = size[2];
                m_internal.texture__loadedTexture_129_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_129_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_129 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_129_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_129" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_129, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_130
        {
            if (!m_internal.texture__loadedTexture_130)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Colors\\Grey_128.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Colors\\Grey_128.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Colors\\Grey_128.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_130_size[0] = size[0];
                m_internal.texture__loadedTexture_130_size[1] = size[1];
                m_internal.texture__loadedTexture_130_size[2] = size[2];
                m_internal.texture__loadedTexture_130_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_130_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_130 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_130_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_130" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_130, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_131
        {
            if (!m_internal.texture__loadedTexture_131)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_BarTrim_01a_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_BarTrim_01a_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_BarTrim_01a_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_131_size[0] = size[0];
                m_internal.texture__loadedTexture_131_size[1] = size[1];
                m_internal.texture__loadedTexture_131_size[2] = size[2];
                m_internal.texture__loadedTexture_131_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_131_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_131 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_131_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_131" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_131, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_132
        {
            if (!m_internal.texture__loadedTexture_132)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\White.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\White.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\White.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_132_size[0] = size[0];
                m_internal.texture__loadedTexture_132_size[1] = size[1];
                m_internal.texture__loadedTexture_132_size[2] = size[2];
                m_internal.texture__loadedTexture_132_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_132_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_132 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_132_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_132" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_132, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_133
        {
            if (!m_internal.texture__loadedTexture_133)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Metal_Hexagonal_Grid_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Metal_Hexagonal_Grid_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Metal_Hexagonal_Grid_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_133_size[0] = size[0];
                m_internal.texture__loadedTexture_133_size[1] = size[1];
                m_internal.texture__loadedTexture_133_size[2] = size[2];
                m_internal.texture__loadedTexture_133_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_133_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_133 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_133_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_133" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_133, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_134
        {
            if (!m_internal.texture__loadedTexture_134)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_MenuSign_01B_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_MenuSign_01B_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_MenuSign_01B_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_134_size[0] = size[0];
                m_internal.texture__loadedTexture_134_size[1] = size[1];
                m_internal.texture__loadedTexture_134_size[2] = size[2];
                m_internal.texture__loadedTexture_134_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_134_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_134 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_134_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_134" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_134, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_135
        {
            if (!m_internal.texture__loadedTexture_135)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Street\\Paris_Lantern_01\\Paris_Lantern_01A_emi.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Street\\Paris_Lantern_01\\Paris_Lantern_01A_emi.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Street\\Paris_Lantern_01\\Paris_Lantern_01A_emi.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_135_size[0] = size[0];
                m_internal.texture__loadedTexture_135_size[1] = size[1];
                m_internal.texture__loadedTexture_135_size[2] = size[2];
                m_internal.texture__loadedTexture_135_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_135_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_135 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_135_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_135" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_135, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_136
        {
            if (!m_internal.texture__loadedTexture_136)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\BuildingTextures\\Paris_Lantern_01A_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\BuildingTextures\\Paris_Lantern_01A_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\BuildingTextures\\Paris_Lantern_01A_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_136_size[0] = size[0];
                m_internal.texture__loadedTexture_136_size[1] = size[1];
                m_internal.texture__loadedTexture_136_size[2] = size[2];
                m_internal.texture__loadedTexture_136_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_136_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_136 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_136_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_136" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_136, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_137
        {
            if (!m_internal.texture__loadedTexture_137)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Curtain_01\\Paris_Curtain_01B_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Curtain_01\\Paris_Curtain_01B_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Curtain_01\\Paris_Curtain_01B_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_137_size[0] = size[0];
                m_internal.texture__loadedTexture_137_size[1] = size[1];
                m_internal.texture__loadedTexture_137_size[2] = size[2];
                m_internal.texture__loadedTexture_137_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_137_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_137 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_137_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_137" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_137, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_138
        {
            if (!m_internal.texture__loadedTexture_138)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Curtain_01\\Paris_Curtain_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Curtain_01\\Paris_Curtain_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Curtain_01\\Paris_Curtain_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_138_size[0] = size[0];
                m_internal.texture__loadedTexture_138_size[1] = size[1];
                m_internal.texture__loadedTexture_138_size[2] = size[2];
                m_internal.texture__loadedTexture_138_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_138_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_138 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_138_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_138" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_138, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_139
        {
            if (!m_internal.texture__loadedTexture_139)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Ceiling_Lamp_01\\Paris_Ceiling_Lamp_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Ceiling_Lamp_01\\Paris_Ceiling_Lamp_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Ceiling_Lamp_01\\Paris_Ceiling_Lamp_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_139_size[0] = size[0];
                m_internal.texture__loadedTexture_139_size[1] = size[1];
                m_internal.texture__loadedTexture_139_size[2] = size[2];
                m_internal.texture__loadedTexture_139_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_139_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_139 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_139_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_139" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_139, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_140
        {
            if (!m_internal.texture__loadedTexture_140)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Ceiling_Lamp_01\\Paris_Ceiling_Lamp_01_emi.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Ceiling_Lamp_01\\Paris_Ceiling_Lamp_01_emi.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Ceiling_Lamp_01\\Paris_Ceiling_Lamp_01_emi.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_140_size[0] = size[0];
                m_internal.texture__loadedTexture_140_size[1] = size[1];
                m_internal.texture__loadedTexture_140_size[2] = size[2];
                m_internal.texture__loadedTexture_140_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_140_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_140 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_140_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_140" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_140, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_141
        {
            if (!m_internal.texture__loadedTexture_141)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Wall_Light_Interior_01\\Paris_Wall_Light_Interior_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Wall_Light_Interior_01\\Paris_Wall_Light_Interior_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Wall_Light_Interior_01\\Paris_Wall_Light_Interior_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_141_size[0] = size[0];
                m_internal.texture__loadedTexture_141_size[1] = size[1];
                m_internal.texture__loadedTexture_141_size[2] = size[2];
                m_internal.texture__loadedTexture_141_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_141_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_141 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_141_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_141" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_141, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_142
        {
            if (!m_internal.texture__loadedTexture_142)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Wall_Light_Interior_01\\Paris_Wall_Light_Interior_Emi.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Wall_Light_Interior_01\\Paris_Wall_Light_Interior_Emi.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Wall_Light_Interior_01\\Paris_Wall_Light_Interior_Emi.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_142_size[0] = size[0];
                m_internal.texture__loadedTexture_142_size[1] = size[1];
                m_internal.texture__loadedTexture_142_size[2] = size[2];
                m_internal.texture__loadedTexture_142_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_142_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_142 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_142_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_142" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_142, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_143
        {
            if (!m_internal.texture__loadedTexture_143)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Bronze_01\\Bronze_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Bronze_01\\Bronze_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Bronze_01\\Bronze_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_143_size[0] = size[0];
                m_internal.texture__loadedTexture_143_size[1] = size[1];
                m_internal.texture__loadedTexture_143_size[2] = size[2];
                m_internal.texture__loadedTexture_143_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_143_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_143 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_143_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_143" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_143, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_144
        {
            if (!m_internal.texture__loadedTexture_144)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_CeilingFan_01\\Paris_CeilingFan_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_CeilingFan_01\\Paris_CeilingFan_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_CeilingFan_01\\Paris_CeilingFan_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_144_size[0] = size[0];
                m_internal.texture__loadedTexture_144_size[1] = size[1];
                m_internal.texture__loadedTexture_144_size[2] = size[2];
                m_internal.texture__loadedTexture_144_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_144_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_144 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_144_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_144" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_144, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_145
        {
            if (!m_internal.texture__loadedTexture_145)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_BeerTap_01\\Paris_BeerTap_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_BeerTap_01\\Paris_BeerTap_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_BeerTap_01\\Paris_BeerTap_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_145_size[0] = size[0];
                m_internal.texture__loadedTexture_145_size[1] = size[1];
                m_internal.texture__loadedTexture_145_size[2] = size[2];
                m_internal.texture__loadedTexture_145_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_145_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_145 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_145_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_145" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_145, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_146
        {
            if (!m_internal.texture__loadedTexture_146)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Wood_Planks_01\\Wood_Planks_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Wood_Planks_01\\Wood_Planks_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Wood_Planks_01\\Wood_Planks_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_146_size[0] = size[0];
                m_internal.texture__loadedTexture_146_size[1] = size[1];
                m_internal.texture__loadedTexture_146_size[2] = size[2];
                m_internal.texture__loadedTexture_146_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_146_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_146 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_146_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_146" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_146, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_147
        {
            if (!m_internal.texture__loadedTexture_147)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Plastic_01\\Plastic_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Plastic_01\\Plastic_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Plastic_01\\Plastic_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_147_size[0] = size[0];
                m_internal.texture__loadedTexture_147_size[1] = size[1];
                m_internal.texture__loadedTexture_147_size[2] = size[2];
                m_internal.texture__loadedTexture_147_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_147_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_147 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_147_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_147" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_147, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_148
        {
            if (!m_internal.texture__loadedTexture_148)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Painting_01\\Paris_Painting_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Painting_01\\Paris_Painting_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Painting_01\\Paris_Painting_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_148_size[0] = size[0];
                m_internal.texture__loadedTexture_148_size[1] = size[1];
                m_internal.texture__loadedTexture_148_size[2] = size[2];
                m_internal.texture__loadedTexture_148_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_148_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_148 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_148_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_148" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_148, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_149
        {
            if (!m_internal.texture__loadedTexture_149)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Painting_01\\Paris_Paintings_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Painting_01\\Paris_Paintings_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Painting_01\\Paris_Paintings_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_149_size[0] = size[0];
                m_internal.texture__loadedTexture_149_size[1] = size[1];
                m_internal.texture__loadedTexture_149_size[2] = size[2];
                m_internal.texture__loadedTexture_149_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_149_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_149 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_149_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_149" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_149, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_150
        {
            if (!m_internal.texture__loadedTexture_150)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_BarStool_01\\Paris_BarStool_01A_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_BarStool_01\\Paris_BarStool_01A_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_BarStool_01\\Paris_BarStool_01A_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_150_size[0] = size[0];
                m_internal.texture__loadedTexture_150_size[1] = size[1];
                m_internal.texture__loadedTexture_150_size[2] = size[2];
                m_internal.texture__loadedTexture_150_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_150_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_150 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_150_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_150" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_150, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_151
        {
            if (!m_internal.texture__loadedTexture_151)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Metal_Chrome_01\\Metal_Chrome_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Metal_Chrome_01\\Metal_Chrome_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Metal_Chrome_01\\Metal_Chrome_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_151_size[0] = size[0];
                m_internal.texture__loadedTexture_151_size[1] = size[1];
                m_internal.texture__loadedTexture_151_size[2] = size[2];
                m_internal.texture__loadedTexture_151_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_151_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_151 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_151_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_151" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_151, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_152
        {
            if (!m_internal.texture__loadedTexture_152)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_CookieJar\\Cookie_01_Lo_default_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_CookieJar\\Cookie_01_Lo_default_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_CookieJar\\Cookie_01_Lo_default_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_152_size[0] = size[0];
                m_internal.texture__loadedTexture_152_size[1] = size[1];
                m_internal.texture__loadedTexture_152_size[2] = size[2];
                m_internal.texture__loadedTexture_152_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_152_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_152 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_152_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_152" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_152, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_153
        {
            if (!m_internal.texture__loadedTexture_153)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Radiator_01\\Paris_Radiator_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Radiator_01\\Paris_Radiator_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Radiator_01\\Paris_Radiator_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_153_size[0] = size[0];
                m_internal.texture__loadedTexture_153_size[1] = size[1];
                m_internal.texture__loadedTexture_153_size[2] = size[2];
                m_internal.texture__loadedTexture_153_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_153_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_153 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_153_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_153" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_153, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_154
        {
            if (!m_internal.texture__loadedTexture_154)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Metal_Chrome_02\\Metal_Chrome_02_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Metal_Chrome_02\\Metal_Chrome_02_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Metal_Chrome_02\\Metal_Chrome_02_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_154_size[0] = size[0];
                m_internal.texture__loadedTexture_154_size[1] = size[1];
                m_internal.texture__loadedTexture_154_size[2] = size[2];
                m_internal.texture__loadedTexture_154_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_154_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_154 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_154_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_154" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_154, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_155
        {
            if (!m_internal.texture__loadedTexture_155)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Cutlery_01\\Paris_Cutlery_01_details_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Cutlery_01\\Paris_Cutlery_01_details_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Cutlery_01\\Paris_Cutlery_01_details_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_155_size[0] = size[0];
                m_internal.texture__loadedTexture_155_size[1] = size[1];
                m_internal.texture__loadedTexture_155_size[2] = size[2];
                m_internal.texture__loadedTexture_155_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_155_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_155 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_155_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_155" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_155, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_156
        {
            if (!m_internal.texture__loadedTexture_156)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Wood_Polished_01\\Wood_Polished_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Wood_Polished_01\\Wood_Polished_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Wood_Polished_01\\Wood_Polished_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_156_size[0] = size[0];
                m_internal.texture__loadedTexture_156_size[1] = size[1];
                m_internal.texture__loadedTexture_156_size[2] = size[2];
                m_internal.texture__loadedTexture_156_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_156_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_156 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_156_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_156" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_156, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_157
        {
            if (!m_internal.texture__loadedTexture_157)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Plates_01\\Paris_Plates_details_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Plates_01\\Paris_Plates_details_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Plates_01\\Paris_Plates_details_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_157_size[0] = size[0];
                m_internal.texture__loadedTexture_157_size[1] = size[1];
                m_internal.texture__loadedTexture_157_size[2] = size[2];
                m_internal.texture__loadedTexture_157_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_157_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_157 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_157_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_157" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_157, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_158
        {
            if (!m_internal.texture__loadedTexture_158)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Plates_01\\Paris_Plates_details_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Plates_01\\Paris_Plates_details_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Plates_01\\Paris_Plates_details_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_158_size[0] = size[0];
                m_internal.texture__loadedTexture_158_size[1] = size[1];
                m_internal.texture__loadedTexture_158_size[2] = size[2];
                m_internal.texture__loadedTexture_158_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_158_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_158 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_158_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_158" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_158, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_159
        {
            if (!m_internal.texture__loadedTexture_159)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Ceramic_01\\Ceramic_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Ceramic_01\\Ceramic_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Ceramic_01\\Ceramic_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_159_size[0] = size[0];
                m_internal.texture__loadedTexture_159_size[1] = size[1];
                m_internal.texture__loadedTexture_159_size[2] = size[2];
                m_internal.texture__loadedTexture_159_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_159_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_159 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_159_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_159" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_159, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_160
        {
            if (!m_internal.texture__loadedTexture_160)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Cotton_Placemat_01\\Paris_Cotton_Placemat_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Cotton_Placemat_01\\Paris_Cotton_Placemat_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Cotton_Placemat_01\\Paris_Cotton_Placemat_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_160_size[0] = size[0];
                m_internal.texture__loadedTexture_160_size[1] = size[1];
                m_internal.texture__loadedTexture_160_size[2] = size[2];
                m_internal.texture__loadedTexture_160_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_160_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_160 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_160_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_160" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_160, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_161
        {
            if (!m_internal.texture__loadedTexture_161)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Wine_Cooler_01\\Paris_Cloths_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Wine_Cooler_01\\Paris_Cloths_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Wine_Cooler_01\\Paris_Cloths_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_161_size[0] = size[0];
                m_internal.texture__loadedTexture_161_size[1] = size[1];
                m_internal.texture__loadedTexture_161_size[2] = size[2];
                m_internal.texture__loadedTexture_161_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_161_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_161 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_161_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_161" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_161, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_162
        {
            if (!m_internal.texture__loadedTexture_162)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Flower_Pot_01\\Paris_interior_plants_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Flower_Pot_01\\Paris_interior_plants_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Flower_Pot_01\\Paris_interior_plants_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_162_size[0] = size[0];
                m_internal.texture__loadedTexture_162_size[1] = size[1];
                m_internal.texture__loadedTexture_162_size[2] = size[2];
                m_internal.texture__loadedTexture_162_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_162_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_162 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_162_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_162" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_162, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_163
        {
            if (!m_internal.texture__loadedTexture_163)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Flower_Pot_01\\Paris_interior_plants_01_mask.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Flower_Pot_01\\Paris_interior_plants_01_mask.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Flower_Pot_01\\Paris_interior_plants_01_mask.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_163_size[0] = size[0];
                m_internal.texture__loadedTexture_163_size[1] = size[1];
                m_internal.texture__loadedTexture_163_size[2] = size[2];
                m_internal.texture__loadedTexture_163_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_163_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_163 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_163_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_163" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_163, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_164
        {
            if (!m_internal.texture__loadedTexture_164)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Wood_Painted_02\\Wood_Painted_02_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Wood_Painted_02\\Wood_Painted_02_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Wood_Painted_02\\Wood_Painted_02_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_164_size[0] = size[0];
                m_internal.texture__loadedTexture_164_size[1] = size[1];
                m_internal.texture__loadedTexture_164_size[2] = size[2];
                m_internal.texture__loadedTexture_164_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_164_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_164 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_164_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_164" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_164, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_165
        {
            if (!m_internal.texture__loadedTexture_165)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_WickerBasket_01\\Paris_WickerBasket_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_WickerBasket_01\\Paris_WickerBasket_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_WickerBasket_01\\Paris_WickerBasket_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_165_size[0] = size[0];
                m_internal.texture__loadedTexture_165_size[1] = size[1];
                m_internal.texture__loadedTexture_165_size[2] = size[2];
                m_internal.texture__loadedTexture_165_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_165_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_165 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_165_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_165" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_165, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_166
        {
            if (!m_internal.texture__loadedTexture_166)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Coasters_01\\Paris_Coasters_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Coasters_01\\Paris_Coasters_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Coasters_01\\Paris_Coasters_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_166_size[0] = size[0];
                m_internal.texture__loadedTexture_166_size[1] = size[1];
                m_internal.texture__loadedTexture_166_size[2] = size[2];
                m_internal.texture__loadedTexture_166_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_166_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_166 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_166_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_166" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_166, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_167
        {
            if (!m_internal.texture__loadedTexture_167)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_CashRegister_01\\Paris_CashRegister_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_CashRegister_01\\Paris_CashRegister_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_CashRegister_01\\Paris_CashRegister_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_167_size[0] = size[0];
                m_internal.texture__loadedTexture_167_size[1] = size[1];
                m_internal.texture__loadedTexture_167_size[2] = size[2];
                m_internal.texture__loadedTexture_167_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_167_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_167 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_167_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_167" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_167, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_168
        {
            if (!m_internal.texture__loadedTexture_168)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_CashRegister_01\\Paris_CashRegister_Buttons_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_CashRegister_01\\Paris_CashRegister_Buttons_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_CashRegister_01\\Paris_CashRegister_Buttons_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_168_size[0] = size[0];
                m_internal.texture__loadedTexture_168_size[1] = size[1];
                m_internal.texture__loadedTexture_168_size[2] = size[2];
                m_internal.texture__loadedTexture_168_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_168_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_168 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_168_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_168" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_168, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_169
        {
            if (!m_internal.texture__loadedTexture_169)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\PropTextures\\Bistro\\Paris_Doormats\\Paris_Doormat_01_diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\PropTextures\\Bistro\\Paris_Doormats\\Paris_Doormat_01_diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\PropTextures\\Bistro\\Paris_Doormats\\Paris_Doormat_01_diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_169_size[0] = size[0];
                m_internal.texture__loadedTexture_169_size[1] = size[1];
                m_internal.texture__loadedTexture_169_size[2] = size[2];
                m_internal.texture__loadedTexture_169_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_169_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_169 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_169_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_169" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_169, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_170
        {
            if (!m_internal.texture__loadedTexture_170)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\OtherTextures\\Tiling\\Rubber_Bar_Mat_01\\Rubber_Bar_Mat_01_Diff.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\OtherTextures\\Tiling\\Rubber_Bar_Mat_01\\Rubber_Bar_Mat_01_Diff.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, true, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\OtherTextures\\Tiling\\Rubber_Bar_Mat_01\\Rubber_Bar_Mat_01_Diff.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_170_size[0] = size[0];
                m_internal.texture__loadedTexture_170_size[1] = size[1];
                m_internal.texture__loadedTexture_170_size[2] = size[2];
                m_internal.texture__loadedTexture_170_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_170_format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
                m_internal.texture__loadedTexture_170 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, m_internal.texture__loadedTexture_170_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_170" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_170, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_171
        {
            if (!m_internal.texture__loadedTexture_171)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\FAST\\vector2_uniform_gauss1_0_Gauss10_separate05_%i.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_171_size[0] = size[0];
                m_internal.texture__loadedTexture_171_size[1] = size[1];
                m_internal.texture__loadedTexture_171_size[2] = size[2];
                m_internal.texture__loadedTexture_171_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_171_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_171 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_171_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_171" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_171, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_172
        {
            if (!m_internal.texture__loadedTexture_172)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\NoiseTextures\\UniformCircle\\UniformCircle.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\NoiseTextures\\UniformCircle\\UniformCircle.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\NoiseTextures\\UniformCircle\\UniformCircle.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_172_size[0] = size[0];
                m_internal.texture__loadedTexture_172_size[1] = size[1];
                m_internal.texture__loadedTexture_172_size[2] = size[2];
                m_internal.texture__loadedTexture_172_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_172_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_172 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_172_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_172" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_172, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_173
        {
            if (!m_internal.texture__loadedTexture_173)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\NoiseTextures\\UniformHexagon\\UniformHexagon.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\NoiseTextures\\UniformHexagon\\UniformHexagon.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\NoiseTextures\\UniformHexagon\\UniformHexagon.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_173_size[0] = size[0];
                m_internal.texture__loadedTexture_173_size[1] = size[1];
                m_internal.texture__loadedTexture_173_size[2] = size[2];
                m_internal.texture__loadedTexture_173_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_173_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_173 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_173_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_173" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_173, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_174
        {
            if (!m_internal.texture__loadedTexture_174)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\NoiseTextures\\UniformStar\\UniformStar.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\NoiseTextures\\UniformStar\\UniformStar.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\NoiseTextures\\UniformStar\\UniformStar.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_174_size[0] = size[0];
                m_internal.texture__loadedTexture_174_size[1] = size[1];
                m_internal.texture__loadedTexture_174_size[2] = size[2];
                m_internal.texture__loadedTexture_174_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_174_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_174 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_174_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_174" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_174, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_175
        {
            if (!m_internal.texture__loadedTexture_175)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\NoiseTextures\\NonUniformStar\\NonUniformStar.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\NoiseTextures\\NonUniformStar\\NonUniformStar.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\NoiseTextures\\NonUniformStar\\NonUniformStar.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_175_size[0] = size[0];
                m_internal.texture__loadedTexture_175_size[1] = size[1];
                m_internal.texture__loadedTexture_175_size[2] = size[2];
                m_internal.texture__loadedTexture_175_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_175_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_175 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_175_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_175" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_175, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_176
        {
            if (!m_internal.texture__loadedTexture_176)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\NoiseTextures\\NonUniformStar2\\NonUniformStar2.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\NoiseTextures\\NonUniformStar2\\NonUniformStar2.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\NoiseTextures\\NonUniformStar2\\NonUniformStar2.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_176_size[0] = size[0];
                m_internal.texture__loadedTexture_176_size[1] = size[1];
                m_internal.texture__loadedTexture_176_size[2] = size[2];
                m_internal.texture__loadedTexture_176_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_176_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_176 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_176_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_176" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_176, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_177
        {
            if (!m_internal.texture__loadedTexture_177)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\NoiseTextures\\Lens_kernel_compositingpro.006\\Lens_kernel_compositingpro.006.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\NoiseTextures\\Lens_kernel_compositingpro.006\\Lens_kernel_compositingpro.006.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\NoiseTextures\\Lens_kernel_compositingpro.006\\Lens_kernel_compositingpro.006.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_177_size[0] = size[0];
                m_internal.texture__loadedTexture_177_size[1] = size[1];
                m_internal.texture__loadedTexture_177_size[2] = size[2];
                m_internal.texture__loadedTexture_177_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_177_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_177 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_177_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_177" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_177, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_178
        {
            if (!m_internal.texture__loadedTexture_178)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\NoiseTextures\\Lens_kernel_compositingpro.204\\Lens_kernel_compositingpro.204.png");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\NoiseTextures\\Lens_kernel_compositingpro.204\\Lens_kernel_compositingpro.204.png", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\NoiseTextures\\Lens_kernel_compositingpro.204\\Lens_kernel_compositingpro.204.png");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_178_size[0] = size[0];
                m_internal.texture__loadedTexture_178_size[1] = size[1];
                m_internal.texture__loadedTexture_178_size[2] = size[2];
                m_internal.texture__loadedTexture_178_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_178_format = DXGI_FORMAT_R8_UNORM;
                m_internal.texture__loadedTexture_178 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8_UNORM, m_internal.texture__loadedTexture_178_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_178" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_178, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_179
        {
            if (!m_internal.texture__loadedTexture_179)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\UniformCircle\\UniformCircle_%i.0.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_179_size[0] = size[0];
                m_internal.texture__loadedTexture_179_size[1] = size[1];
                m_internal.texture__loadedTexture_179_size[2] = size[2];
                m_internal.texture__loadedTexture_179_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_179_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_179 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_179_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_179" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_179, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_180
        {
            if (!m_internal.texture__loadedTexture_180)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\UniformCircle\\UniformCircle_%i.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_180_size[0] = size[0];
                m_internal.texture__loadedTexture_180_size[1] = size[1];
                m_internal.texture__loadedTexture_180_size[2] = size[2];
                m_internal.texture__loadedTexture_180_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_180_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_180 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_180_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_180" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_180, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_181
        {
            if (!m_internal.texture__loadedTexture_181)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\UniformHexagon\\UniformHexagon_%i.0.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_181_size[0] = size[0];
                m_internal.texture__loadedTexture_181_size[1] = size[1];
                m_internal.texture__loadedTexture_181_size[2] = size[2];
                m_internal.texture__loadedTexture_181_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_181_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_181 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_181_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_181" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_181, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_182
        {
            if (!m_internal.texture__loadedTexture_182)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\UniformHexagon\\UniformHexagon_%i.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_182_size[0] = size[0];
                m_internal.texture__loadedTexture_182_size[1] = size[1];
                m_internal.texture__loadedTexture_182_size[2] = size[2];
                m_internal.texture__loadedTexture_182_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_182_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_182 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_182_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_182" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_182, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_183
        {
            if (!m_internal.texture__loadedTexture_183)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R32_FLOAT, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\NoiseTextures\\UniformHexagon\\UniformHexagon.icdf.exr");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\NoiseTextures\\UniformHexagon\\UniformHexagon.icdf.exr", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\NoiseTextures\\UniformHexagon\\UniformHexagon.icdf.exr");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_183_size[0] = size[0];
                m_internal.texture__loadedTexture_183_size[1] = size[1];
                m_internal.texture__loadedTexture_183_size[2] = size[2];
                m_internal.texture__loadedTexture_183_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_183_format = DXGI_FORMAT_R32_FLOAT;
                m_internal.texture__loadedTexture_183 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R32_FLOAT, m_internal.texture__loadedTexture_183_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_183" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_183, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_184
        {
            if (!m_internal.texture__loadedTexture_184)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\UniformStar\\UniformStar_%i.0.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_184_size[0] = size[0];
                m_internal.texture__loadedTexture_184_size[1] = size[1];
                m_internal.texture__loadedTexture_184_size[2] = size[2];
                m_internal.texture__loadedTexture_184_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_184_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_184 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_184_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_184" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_184, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_185
        {
            if (!m_internal.texture__loadedTexture_185)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\UniformStar\\UniformStar_%i.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_185_size[0] = size[0];
                m_internal.texture__loadedTexture_185_size[1] = size[1];
                m_internal.texture__loadedTexture_185_size[2] = size[2];
                m_internal.texture__loadedTexture_185_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_185_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_185 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_185_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_185" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_185, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_186
        {
            if (!m_internal.texture__loadedTexture_186)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R32_FLOAT, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\NoiseTextures\\UniformStar\\UniformStar.icdf.exr");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\NoiseTextures\\UniformStar\\UniformStar.icdf.exr", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\NoiseTextures\\UniformStar\\UniformStar.icdf.exr");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_186_size[0] = size[0];
                m_internal.texture__loadedTexture_186_size[1] = size[1];
                m_internal.texture__loadedTexture_186_size[2] = size[2];
                m_internal.texture__loadedTexture_186_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_186_format = DXGI_FORMAT_R32_FLOAT;
                m_internal.texture__loadedTexture_186 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R32_FLOAT, m_internal.texture__loadedTexture_186_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_186" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_186, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_187
        {
            if (!m_internal.texture__loadedTexture_187)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\NonUniformStar\\NonUniformStar_%i.0.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_187_size[0] = size[0];
                m_internal.texture__loadedTexture_187_size[1] = size[1];
                m_internal.texture__loadedTexture_187_size[2] = size[2];
                m_internal.texture__loadedTexture_187_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_187_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_187 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_187_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_187" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_187, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_188
        {
            if (!m_internal.texture__loadedTexture_188)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\NonUniformStar\\NonUniformStar_%i.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_188_size[0] = size[0];
                m_internal.texture__loadedTexture_188_size[1] = size[1];
                m_internal.texture__loadedTexture_188_size[2] = size[2];
                m_internal.texture__loadedTexture_188_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_188_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_188 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_188_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_188" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_188, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_189
        {
            if (!m_internal.texture__loadedTexture_189)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\NonUniformStar2\\NonUniformStar2_%i.0.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_189_size[0] = size[0];
                m_internal.texture__loadedTexture_189_size[1] = size[1];
                m_internal.texture__loadedTexture_189_size[2] = size[2];
                m_internal.texture__loadedTexture_189_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_189_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_189 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_189_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_189" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_189, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_190
        {
            if (!m_internal.texture__loadedTexture_190)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\NonUniformStar2\\NonUniformStar2_%i.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_190_size[0] = size[0];
                m_internal.texture__loadedTexture_190_size[1] = size[1];
                m_internal.texture__loadedTexture_190_size[2] = size[2];
                m_internal.texture__loadedTexture_190_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_190_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_190 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_190_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_190" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_190, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_191
        {
            if (!m_internal.texture__loadedTexture_191)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\Lens_kernel_compositingpro.006\\Lens_kernel_compositingpro.006_%i.0.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_191_size[0] = size[0];
                m_internal.texture__loadedTexture_191_size[1] = size[1];
                m_internal.texture__loadedTexture_191_size[2] = size[2];
                m_internal.texture__loadedTexture_191_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_191_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_191 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_191_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_191" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_191, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_192
        {
            if (!m_internal.texture__loadedTexture_192)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\Lens_kernel_compositingpro.006\\Lens_kernel_compositingpro.006_%i.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_192_size[0] = size[0];
                m_internal.texture__loadedTexture_192_size[1] = size[1];
                m_internal.texture__loadedTexture_192_size[2] = size[2];
                m_internal.texture__loadedTexture_192_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_192_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_192 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_192_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_192" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_192, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_193
        {
            if (!m_internal.texture__loadedTexture_193)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\Lens_kernel_compositingpro.204\\Lens_kernel_compositingpro.204_%i.0.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_193_size[0] = size[0];
                m_internal.texture__loadedTexture_193_size[1] = size[1];
                m_internal.texture__loadedTexture_193_size[2] = size[2];
                m_internal.texture__loadedTexture_193_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_193_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_193 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_193_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_193" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_193, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_194
        {
            if (!m_internal.texture__loadedTexture_194)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R8G8_UNORM, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type");

                int textureIndex = -1;
                while(1)
                {
                    textureIndex++;
                    char indexedFileName[1024];
                    sprintf_s(indexedFileName, "%lsassets/Assets\\NoiseTextures\\Lens_kernel_compositingpro.204\\Lens_kernel_compositingpro.204_%i.png", s_techniqueLocation.c_str(), textureIndex);
                    DX12Utils::TextureCache::Texture loadedTextureSlice = DX12Utils::TextureCache::GetAs(indexedFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount);

                    if(!loadedTextureSlice.Valid())
                    {
                        if (textureIndex == 0)
                            Context::LogFn(LogLevel::Error, "Could not load image: %s", indexedFileName);
                        break;
                    }

                    if (textureIndex > 0 && (loadedTextureSlice.width != loadedTextureSlices[0].width || loadedTextureSlice.height != loadedTextureSlices[0].height))
                        Context::LogFn(LogLevel::Error, "%s does not match dimensions of the first texture loaded!", indexedFileName);

                    loadedTextureSlices.push_back(loadedTextureSlice);
                }

                unsigned int size[3] = { (unsigned int)loadedTextureSlices[0].width, (unsigned int)loadedTextureSlices[0].height, (unsigned int)loadedTextureSlices.size() };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_194_size[0] = size[0];
                m_internal.texture__loadedTexture_194_size[1] = size[1];
                m_internal.texture__loadedTexture_194_size[2] = size[2];
                m_internal.texture__loadedTexture_194_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_194_format = DXGI_FORMAT_R8G8_UNORM;
                m_internal.texture__loadedTexture_194 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R8G8_UNORM, m_internal.texture__loadedTexture_194_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2DArray, (c_debugNames ? L"_loadedTexture_194" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_194, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _loadedTexture_195
        {
            if (!m_internal.texture__loadedTexture_195)
            {
                // Load the texture
                std::vector<DX12Utils::TextureCache::Texture> loadedTextureSlices;
                DX12Utils::DXGI_FORMAT_Info formatInfo = DX12Utils::Get_DXGI_FORMAT_Info(DXGI_FORMAT_R32_FLOAT, Context::LogFn);
                DX12Utils::TextureCache::Type desiredType = DX12Utils::TextureCache::Type::U8;
                if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_uint8_t)
                    desiredType = DX12Utils::TextureCache::Type::U8;
                else if (formatInfo.channelType == DX12Utils::DXGI_FORMAT_Info::ChannelType::_float)
                    desiredType = DX12Utils::TextureCache::Type::F32;
                else
                    Context::LogFn(LogLevel::Error, "Unhandled channel type for image: Assets\\NoiseTextures\\Lens_kernel_compositingpro.204\\Lens_kernel_compositingpro.204.icdf.exr");

                char loadedTextureFileName[1024];
                sprintf_s(loadedTextureFileName, "%lsassets/Assets\\NoiseTextures\\Lens_kernel_compositingpro.204\\Lens_kernel_compositingpro.204.icdf.exr", s_techniqueLocation.c_str());

                loadedTextureSlices.push_back(DX12Utils::TextureCache::GetAs(loadedTextureFileName, false, desiredType, formatInfo.sRGB, formatInfo.channelCount));
                DX12Utils::TextureCache::Texture& loadedTexture = loadedTextureSlices[0];
                if(!loadedTexture.Valid())
                    Context::LogFn(LogLevel::Error, "Could not load image: Assets\\NoiseTextures\\Lens_kernel_compositingpro.204\\Lens_kernel_compositingpro.204.icdf.exr");

                unsigned int size[3] = { (unsigned int)loadedTexture.width, (unsigned int)loadedTexture.height, 1 };

                static const unsigned int desiredNumMips = 1;

                // Create the texture
                dirty = true;
                m_internal.texture__loadedTexture_195_size[0] = size[0];
                m_internal.texture__loadedTexture_195_size[1] = size[1];
                m_internal.texture__loadedTexture_195_size[2] = size[2];
                m_internal.texture__loadedTexture_195_numMips = desiredNumMips;
                m_internal.texture__loadedTexture_195_format = DXGI_FORMAT_R32_FLOAT;
                m_internal.texture__loadedTexture_195 = DX12Utils::CreateTexture(device, size, desiredNumMips, DXGI_FORMAT_R32_FLOAT, m_internal.texture__loadedTexture_195_flags, D3D12_RESOURCE_STATE_COPY_DEST, DX12Utils::ResourceType::Texture2D, (c_debugNames ? L"_loadedTexture_195" : nullptr), Context::LogFn);


                std::vector<unsigned char> pixels;
                for (const DX12Utils::TextureCache::Texture& texture : loadedTextureSlices)
                    pixels.insert(pixels.end(), texture.pixels.begin(), texture.pixels.end());

                DX12Utils::UploadTextureToGPUAndMakeMips(device, commandList, s_ubTracker, m_internal.texture__loadedTexture_195, pixels, size, desiredNumMips, D3D12_RESOURCE_STATE_COPY_DEST, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, LogFn);
            }
        }

        // _RayGenCB
        if (m_internal.constantBuffer__RayGenCB == nullptr)
        {
            dirty = true;
            m_internal.constantBuffer__RayGenCB = DX12Utils::CreateBuffer(device, 512, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_DEFAULT, (c_debugNames ? L"_RayGenCB" : nullptr), Context::LogFn);
        }

        // _GatherDOF_SetupCSCB
        if (m_internal.constantBuffer__GatherDOF_SetupCSCB == nullptr)
        {
            dirty = true;
            m_internal.constantBuffer__GatherDOF_SetupCSCB = DX12Utils::CreateBuffer(device, 256, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_DEFAULT, (c_debugNames ? L"_GatherDOF_SetupCSCB" : nullptr), Context::LogFn);
        }

        // _GatherDOF_BlurFarCSCB
        if (m_internal.constantBuffer__GatherDOF_BlurFarCSCB == nullptr)
        {
            dirty = true;
            m_internal.constantBuffer__GatherDOF_BlurFarCSCB = DX12Utils::CreateBuffer(device, 256, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_DEFAULT, (c_debugNames ? L"_GatherDOF_BlurFarCSCB" : nullptr), Context::LogFn);
        }

        // _GatherDOF_NearBlurCB
        if (m_internal.constantBuffer__GatherDOF_NearBlurCB == nullptr)
        {
            dirty = true;
            m_internal.constantBuffer__GatherDOF_NearBlurCB = DX12Utils::CreateBuffer(device, 256, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_DEFAULT, (c_debugNames ? L"_GatherDOF_NearBlurCB" : nullptr), Context::LogFn);
        }

        // _GatherDOF_RecombineCSCB
        if (m_internal.constantBuffer__GatherDOF_RecombineCSCB == nullptr)
        {
            dirty = true;
            m_internal.constantBuffer__GatherDOF_RecombineCSCB = DX12Utils::CreateBuffer(device, 256, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_DEFAULT, (c_debugNames ? L"_GatherDOF_RecombineCSCB" : nullptr), Context::LogFn);
        }

        // _GaussBlur_GaussBlurCSCB
        if (m_internal.constantBuffer__GaussBlur_GaussBlurCSCB == nullptr)
        {
            dirty = true;
            m_internal.constantBuffer__GaussBlur_GaussBlurCSCB = DX12Utils::CreateBuffer(device, 256, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_DEFAULT, (c_debugNames ? L"_GaussBlur_GaussBlurCSCB" : nullptr), Context::LogFn);
        }

        // _TemporalAccumulation_AccumulateCB
        if (m_internal.constantBuffer__TemporalAccumulation_AccumulateCB == nullptr)
        {
            dirty = true;
            m_internal.constantBuffer__TemporalAccumulation_AccumulateCB = DX12Utils::CreateBuffer(device, 256, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_DEFAULT, (c_debugNames ? L"_TemporalAccumulation_AccumulateCB" : nullptr), Context::LogFn);
        }

        // _ToneMap_TonemapCB
        if (m_internal.constantBuffer__ToneMap_TonemapCB == nullptr)
        {
            dirty = true;
            m_internal.constantBuffer__ToneMap_TonemapCB = DX12Utils::CreateBuffer(device, 256, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_DEFAULT, (c_debugNames ? L"_ToneMap_TonemapCB" : nullptr), Context::LogFn);
        }

        // _GatherDOF_FloodFillFarCS_0CB
        if (m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB == nullptr)
        {
            dirty = true;
            m_internal.constantBuffer__GatherDOF_FloodFillFarCS_0CB = DX12Utils::CreateBuffer(device, 256, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_DEFAULT, (c_debugNames ? L"_GatherDOF_FloodFillFarCS_0CB" : nullptr), Context::LogFn);
        }

        // _GatherDOF_FloodFillFarCS_1CB
        if (m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB == nullptr)
        {
            dirty = true;
            m_internal.constantBuffer__GatherDOF_FloodFillFarCS_1CB = DX12Utils::CreateBuffer(device, 256, D3D12_RESOURCE_FLAG_NONE, D3D12_RESOURCE_STATE_COMMON, D3D12_HEAP_TYPE_DEFAULT, (c_debugNames ? L"_GatherDOF_FloodFillFarCS_1CB" : nullptr), Context::LogFn);
        }
        EnsureDrawCallPSOsCreated(device, dirty);
    }

    bool Context::EnsureDrawCallPSOsCreated(ID3D12Device* device, bool dirty)
    {
        return true;
    }
};
